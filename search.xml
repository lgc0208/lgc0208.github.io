<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于微信小程序的北邮信息门户通知查询系统</title>
    <url>/2021/06/10/%E4%BF%A1%E6%81%AF%E9%97%A8%E6%88%B7%E9%80%9A%E7%9F%A5%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-项目目标"><a href="#1-项目目标" class="headerlink" title="1 项目目标"></a>1 项目目标</h1><h2 id="1-1-基础目标"><a href="#1-1-基础目标" class="headerlink" title="1.1 基础目标"></a>1.1 基础目标</h2><p>（1）实现北邮信息门户校内通知、学术讲座、公示公告、校园新闻的<strong>查询</strong><br>（2）将从北邮信息门户校内通知、学术讲座、公示公告、校园新闻的内容<strong>更新到数据库</strong><br>（3）将微信小程序与数据库进行连接，使得小程序可以<strong>实时调取数据库内容</strong><br>（4）在微信小程序上实现<strong>搜索功能</strong><br>（5）在微信小程序上实现<strong>用户登录功能</strong> </p>
<h2 id="1-2-进阶目标"><a href="#1-2-进阶目标" class="headerlink" title="1.2 进阶目标"></a>1.2 进阶目标</h2><p>（1）用户可以在微信小程序上对重要通知进行<strong>收藏和取消收藏</strong><br>（2）将用户收藏的通知<strong>与用户微信号挂钩</strong>，使用户可以随时读取自己收藏的内容</p>
<span id="more"></span>
<h1 id="2-技术栈及相关环境要求"><a href="#2-技术栈及相关环境要求" class="headerlink" title="2 技术栈及相关环境要求"></a>2 技术栈及相关环境要求</h1><h2 id="2-1-技术栈"><a href="#2-1-技术栈" class="headerlink" title="2.1 技术栈"></a>2.1 技术栈</h2><ol>
<li>微信小程序<br>用户“无需下载，用完即走”，增加了用户使用的便捷性<br> 不受手机操作系统的限制，只需要开发一套程序</li>
<li><p>腾讯云<br>支撑微信小程序云开发，可以将数据操作与用户绑定</p>
</li>
<li><p>JAVA 服务器<br>开发的服务器稳定性和安全性都在长期实践中被得以证明</p>
</li>
<li><p>Microsoft SQL Server 数据库<br>具备完全Web支持，具有易用性和良好的性价比</p>
</li>
<li><p>Python<br>具有海量的第三方库，实现功能迅速、稳定、便捷</p>
</li>
</ol>
<h2 id="2-2-系统运行环境"><a href="#2-2-系统运行环境" class="headerlink" title="2.2 系统运行环境"></a>2.2 系统运行环境</h2><h3 id="2-2-1-软件环境"><a href="#2-2-1-软件环境" class="headerlink" title="2.2.1 软件环境"></a>2.2.1 软件环境</h3><div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>名称</th>
<th>版本</th>
<th>语种</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC 操作系统</td>
<td>Windows 10</td>
<td>家庭中文版</td>
<td>简体中文</td>
</tr>
<tr>
<td>移动端操作系统</td>
<td>iOS/Android</td>
<td>/</td>
<td>简体中文</td>
</tr>
<tr>
<td>应用平台</td>
<td>微信小程序</td>
<td>/</td>
<td>简体中文</td>
</tr>
<tr>
<td>数据库平台</td>
<td>Microsoft SQL Server</td>
<td>2019</td>
<td>Sql</td>
</tr>
<tr>
<td>服务器端</td>
<td>IntelliJ IDEA</td>
<td>2020.1</td>
<td>Java</td>
</tr>
<tr>
<td></td>
<td>Tomcat</td>
<td>9.0.44</td>
</tr>
<tr>
<td>数据爬取端</td>
<td>Spyder</td>
<td>3.0.0</td>
<td>Python</td>
</tr>
<tr>
<td>开发环境</td>
<td>Python</td>
<td>3.7 及以上</td>
<td>Python</td>
</tr>
<tr>
<td></td>
<td>Java</td>
<td>14.0.1</td>
<td>Java</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-2-2-硬件平台"><a href="#2-2-2-硬件平台" class="headerlink" title="2.2.2 硬件平台"></a>2.2.2 硬件平台</h3><div class="table-container">
<table>
<thead>
<tr>
<th>设备名称</th>
<th>设备要求</th>
</tr>
</thead>
<tbody>
<tr>
<td>智能手机/平板电脑</td>
<td>安装微信（IOS:7.0.20 及以上版本，Andriod： 7.0.22 及以上版本）</td>
</tr>
<tr>
<td>PC</td>
<td>装有 python 3.7 及以上版本、Java 14.0.1 及 以上版本、 Apache Tomcat 对应版本 、 Microsoft SQL Server 数据库 2019及以上版本</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-2-3-开发环境"><a href="#2-2-3-开发环境" class="headerlink" title="2.2.3 开发环境"></a>2.2.3 开发环境</h3><div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>名称</th>
<th>版本</th>
<th>语种</th>
</tr>
</thead>
<tbody>
<tr>
<td>PC 操作系统</td>
<td>Windows 10</td>
<td>家庭中文版</td>
<td>简体中文</td>
</tr>
<tr>
<td>开发平台</td>
<td>微信小程序开发者工具</td>
<td>Stable 1.03.2101150</td>
<td>JavaScript/WXSS/ WXML</td>
</tr>
<tr>
<td>开发平台</td>
<td>IntelliJ IDEA</td>
<td>2020.1</td>
<td>Java</td>
</tr>
<tr>
<td>开发平台</td>
<td>Tomcat</td>
<td>9.0.44</td>
<td>Java</td>
</tr>
<tr>
<td>开发平台</td>
<td>Spyder</td>
<td>3.0.0</td>
<td>Python</td>
</tr>
<tr>
<td>数据库平台</td>
<td>Microsoft SQL Server</td>
<td>2019</td>
<td>Sql</td>
</tr>
</tbody>
</table>
</div>
<h1 id="3-设计思想"><a href="#3-设计思想" class="headerlink" title="3 设计思想"></a>3 设计思想</h1><p>整个系统被划分为四个部分：Python 爬虫程序、Microsoft SQL Server 数据库、Java Web的Tomcat 以及微信小程序。划分基于每一个部分对系统的贡献和使用的语言。</p>
<p>Python 由于其具有海量的第三方库，可以迅速、稳定、便捷地实现爬虫程序和数据库的更新，因此选用Python 作为数据的获取和处理部分的主要语言。</p>
<p>Microsoft SQL Server 的是一个具备完全Web 支持的数据库产品，提供了对可扩展标记语言(XML)的核心支持以及在Internet 上和防火墙外进行查询的能力，具有易用性和良好的性价比，这些都是我们选择其作为数据库的原因。</p>
<p>Java 用于Web 开发具有天然的优势。长期以来Java 开发者为其提供了良好的开发基础，使得其具有成熟的设计模式，而且还有成熟的框架，可以用很多表达式以及标签来展示我们需要的内容；Java 开发的稳定性和安全性都在长期实践中被得以证明，因此我们选用Java 作为连接数据库和微信小程序的程序设计语言。</p>
<p>微信小程序从出生以来一直受到开发者的青睐，其背靠10 亿+微信用户，用户“无需下载，用完即走”，增加了用户使用的便捷性，降低了使用门槛。此外，微信小程序的开发不受手机操作系统的限制，只需要开发一套程序即可在不同操作系统的手机进行展示。基于此，我们使用微信小程序作为我们的前端展示工具。</p>
<p>整体技术路线如下图所示</p>
<p><img src="/2021/06/10/%E4%BF%A1%E6%81%AF%E9%97%A8%E6%88%B7%E9%80%9A%E7%9F%A5%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438716298986.png" alt=" "></p>
<h1 id="4-模块设计"><a href="#4-模块设计" class="headerlink" title="4 模块设计"></a>4 模块设计</h1><h2 id="4-1-Python爬虫及数据库更新模块"><a href="#4-1-Python爬虫及数据库更新模块" class="headerlink" title="4.1 Python爬虫及数据库更新模块"></a>4.1 Python爬虫及数据库更新模块</h2><p>该部分包含一个portalToSQL 类。该类用于将门户中特定的消息更新到Microsoft SQL Server 数据库中，该类的设计如下图所示。</p>
<p><img src="/2021/06/10/%E4%BF%A1%E6%81%AF%E9%97%A8%E6%88%B7%E9%80%9A%E7%9F%A5%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438716262244.png" alt=" "></p>
<p>主体代码具体实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">portalToSQL</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 基础信息</span></span><br><span class="line">    username = <span class="string">&#x27;&#x27;</span>               <span class="comment"># 信息门户登录用户名</span></span><br><span class="line">    password = <span class="string">&#x27;&#x27;</span>               <span class="comment"># 信息门户登录密码</span></span><br><span class="line">    server = <span class="string">&quot;127.0.0.1&quot;</span>        <span class="comment"># 服务器地址，该处为本地地址</span></span><br><span class="line">    sqlUsername = <span class="string">&quot;&quot;</span>            <span class="comment"># 数据库用户名</span></span><br><span class="line">    sqlPassword = <span class="string">&quot;&quot;</span>            <span class="comment"># 数据库密码</span></span><br><span class="line">    database = <span class="string">&quot;&quot;</span>               <span class="comment"># 数据库名</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Input:      loginUrl:   登录网址</span></span><br><span class="line"><span class="string">                cookkie:    登录cookie</span></span><br><span class="line"><span class="string">                infoUrl:    信息所在的网址</span></span><br><span class="line"><span class="string">                infoHref:   信息所在的Href标识</span></span><br><span class="line"><span class="string">                lableName:  预存入的数据库的表名</span></span><br><span class="line"><span class="string">    Output:     None</span></span><br><span class="line"><span class="string">    Function:   构造函数，初始化</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, loginUrl, cookie, infoUrl, infoHref, lableName</span>):</span>     </span><br><span class="line">        self.loginUrl = loginUrl</span><br><span class="line">        self.cookie = cookie</span><br><span class="line">        self.infoUrl = infoUrl</span><br><span class="line">        self.infoHref = infoHref</span><br><span class="line">        self.lableName = lableName</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Input:      HTTP GET请求 loginUrl 所得到的内容的字符串 str</span></span><br><span class="line"><span class="string">    Output:     包含本次登录的网站信息的字典 dic (包括用户名、密码、Lt等参数)</span></span><br><span class="line"><span class="string">    Function:   从 loginUrl 里获取本次登录所特有的参数，如 lt， execution 等</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLt</span>(<span class="params">self, <span class="built_in">str</span></span>):</span></span><br><span class="line">        lt=bs(<span class="built_in">str</span>,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">        dic=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> inp <span class="keyword">in</span> lt.form.find_all(<span class="string">&#x27;input&#x27;</span>):</span><br><span class="line">            <span class="keyword">if</span>(inp.get(<span class="string">&#x27;name&#x27;</span>))!=<span class="literal">None</span>:</span><br><span class="line">                dic[inp.get(<span class="string">&#x27;name&#x27;</span>)]=inp.get(<span class="string">&#x27;value&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> dic</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Input:      目标地址 objectUrl，实例化的 Session 对象</span></span><br><span class="line"><span class="string">    Output:     含有标题、日期和文章主体的字典 result</span></span><br><span class="line"><span class="string">    Function:   获得所需要爬取的页面的标题、日期和文章主体</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNewsDetail</span>(<span class="params">self, objectUrl, session</span>):</span></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        res = session.get(objectUrl, headers=self.cookie)</span><br><span class="line">        res.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">        soup = bs(res.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">        result[<span class="string">&#x27;Title&#x27;</span>] = soup.select(<span class="string">&#x27;.text-center&#x27;</span>)[<span class="number">0</span>].text</span><br><span class="line">        </span><br><span class="line">        date=[]</span><br><span class="line">        <span class="comment"># 学术讲座和其他通知的标签不同，故做两种处理。&#x27;singlemeta text-center&#x27;为学术讲座的格式。</span></span><br><span class="line">        <span class="keyword">if</span> soup.find_all(class_ = <span class="string">&#x27;pmeta ptime&#x27;</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> soup.find_all(class_ = <span class="string">&#x27;pmeta ptime&#x27;</span>):</span><br><span class="line">                date.append(j.text)</span><br><span class="line">                eachDate = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> date:</span><br><span class="line">                eachDate = i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> soup.find_all(class_ = <span class="string">&#x27;singlemeta text-center&#x27;</span>):</span><br><span class="line">                date.append(j.text)</span><br><span class="line">                eachDate = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> date:</span><br><span class="line">                eachDate = i</span><br><span class="line">            eachDate = (eachDate.split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">1</span>] + <span class="string">&quot;    &quot;</span> + eachDate.split(<span class="string">&#x27; &#x27;</span>)[-<span class="number">2</span>])</span><br><span class="line">        result[<span class="string">&#x27;date&#x27;</span>] = eachDate</span><br><span class="line">        article = []</span><br><span class="line">        image = []</span><br><span class="line">        tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        allP = soup.select(<span class="string">&#x27;.singleinfo #vsb_content .v_news_content p&#x27;</span>)</span><br><span class="line">                           </span><br><span class="line">        <span class="comment"># 插入图片                           </span></span><br><span class="line">        allPicture = soup.select(<span class="string">&#x27;.singleinfo #vsb_content .v_news_content p img&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">for</span> pictures <span class="keyword">in</span> allPicture:</span><br><span class="line">                imgsUrl = <span class="string">&#x27;http://my.bupt.edu.cn&#x27;</span> + pictures.get(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">                image.append(imgsUrl)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span> <span class="comment"># 解决不含img信息时的报错问题</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> allP:</span><br><span class="line">            article.append(<span class="string">&#x27;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&#x27;</span> + p.text.strip() + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(article)):</span><br><span class="line">            tmp += article[i] </span><br><span class="line">        result[<span class="string">&#x27;article&#x27;</span>] = tmp</span><br><span class="line">        </span><br><span class="line">        tmp = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> unitImg <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(image)):   </span><br><span class="line">            <span class="keyword">if</span> unitImg == <span class="built_in">len</span>(image) - <span class="number">1</span>:</span><br><span class="line">                tmp += image[unitImg]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp += image[unitImg] + <span class="string">&#x27;,&#x27;</span></span><br><span class="line">        result[<span class="string">&#x27;image&#x27;</span>] = tmp</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将数据写入数据库</span></span><br><span class="line">    <span class="comment"># 连接数据库</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Input:      需要写入数据库的 DataFrame 型数据 df</span></span><br><span class="line"><span class="string">    Output:     写入数据库的结果</span></span><br><span class="line"><span class="string">    Function:   将 df 写入 database 数据库的 lablename 表中</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toSqlServer</span>(<span class="params">self, df</span>):</span></span><br><span class="line">        connect = pymssql.connect(self.server, self.sqlUsername, self.sqlPassword, self.database)</span><br><span class="line">        <span class="comment"># 一次插入多条数据</span></span><br><span class="line">        cols = <span class="string">&#x27;,&#x27;</span>.join(df.columns)</span><br><span class="line">        val = (<span class="built_in">tuple</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> df.values) <span class="comment"># 这里需要转成tuple类型才能写入到数据库中</span></span><br><span class="line">        sqlstr = <span class="string">&quot;INSERT INTO &#123;&#125;(&#123;&#125;) VALUES (&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(self.lableName, cols, <span class="string">&#x27;,&#x27;</span>.join([<span class="string">&#x27;%s&#x27;</span>]*<span class="built_in">len</span>(df.columns)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> connect.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">                cursor.executemany(sqlstr, val)</span><br><span class="line">                sqlDel = <span class="string">&#x27;Delete T From (Select Row_Number() Over(Partition By title order By date) As RowNumber,* From &#123;&#125;)T Where T.RowNumber &gt; 1&#x27;</span>.<span class="built_in">format</span>(self.lableName)</span><br><span class="line">                cursor.execute(sqlDel)</span><br><span class="line">                sqlDelNull = <span class="string">&#x27;delete from &#123;&#125; where (datalength (article) = 0 or datalength (article) is null) and (datalength (image) = 0 or datalength (image) is null)&#x27;</span>.<span class="built_in">format</span>(self.lableName)</span><br><span class="line">                cursor.execute(sqlDelNull)</span><br><span class="line">            connect.commit()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; 插入数据成功，表 &#123;&#125; 共插入 &#123;&#125; 行数据&#x27;</span>.<span class="built_in">format</span>(self.lableName, <span class="built_in">len</span>(df)))</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; 表 &#123;&#125; 删除重复数据、空白数据成功&#x27;</span>.<span class="built_in">format</span>(self.lableName))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;&gt;&gt;&gt; 插入数据失败&#x27;</span>, e)</span><br><span class="line">            connect.rollback()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            connect.close()</span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    Input:      None</span></span><br><span class="line"><span class="string">    Output:     含有需要爬取信息的 Excel 文件并更新到数据库</span></span><br><span class="line"><span class="string">    Function:   将所需要爬取的信息保存到 Excel 文件和 SQL Server 数据库</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getInformation</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment">#模拟一个浏览器头</span></span><br><span class="line">        header=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:47.0) Gecko/20100101 Firefox/47.0&#x27;</span>&#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">#实例化session</span></span><br><span class="line">        session = requests.Session()</span><br><span class="line">        session.cookies = cookielib.CookieJar()</span><br><span class="line">        response=session.get(self.loginUrl, headers=header)</span><br><span class="line">        <span class="comment"># 得到含有输入的用户名、密码、Lt的字典格式</span></span><br><span class="line">        dic = self.getLt(response.text)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新post信息</span></span><br><span class="line">        postdata=&#123;</span><br><span class="line">                <span class="string">&#x27;username&#x27;</span>:self.username,</span><br><span class="line">                <span class="string">&#x27;password&#x27;</span>:self.password,</span><br><span class="line">                <span class="string">&#x27;lt&#x27;</span>:dic[<span class="string">&#x27;lt&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;execution&#x27;</span>:dic[<span class="string">&#x27;execution&#x27;</span>],</span><br><span class="line">                <span class="string">&#x27;_eventId&#x27;</span>:<span class="string">&#x27;submit&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;rmShown&#x27;</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#携带登陆数据，以post方式登录，</span></span><br><span class="line">        response = session.post(self.loginUrl, data=postdata, headers=header)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#用 GET 方式访问“校内通知”的页面</span></span><br><span class="line">        res = session.get(self.infoUrl, headers=self.cookie)</span><br><span class="line">        <span class="comment">#用 beautifulsoup 解析 html</span></span><br><span class="line">        soup = bs(res.text,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 获取各个通知的详细URL</span></span><br><span class="line">        url = []</span><br><span class="line">        urls = soup.find_all(href = re.<span class="built_in">compile</span>(self.infoHref))</span><br><span class="line">        isPrompt = <span class="literal">False</span> <span class="comment"># 让提示代码只执行一次</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> urls:</span><br><span class="line">            <span class="keyword">if</span>((<span class="string">&#x27;http://my.bupt.edu.cn/&#x27;</span> + j.get(<span class="string">&#x27;href&#x27;</span>)) <span class="keyword">not</span> <span class="keyword">in</span> url):</span><br><span class="line">                url.append(<span class="string">&#x27;http://my.bupt.edu.cn/&#x27;</span> + j.get(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">                <span class="keyword">if</span> url != [] <span class="keyword">and</span> isPrompt == <span class="literal">False</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; 网址爬取成功&quot;</span>)</span><br><span class="line">                    isPrompt = <span class="literal">True</span></span><br><span class="line">                    </span><br><span class="line">                </span><br><span class="line">        news_total=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(url)):</span><br><span class="line">            newsary = self.getNewsDetail(url[i], session) <span class="comment"># 读取网址中的内容详情</span></span><br><span class="line">            news_total.append(newsary)</span><br><span class="line">        df = pd.DataFrame(news_total)</span><br><span class="line">        self.toSqlServer(df) <span class="comment"># 将数据存入数据库</span></span><br></pre></td></tr></table></figure>
<p>该类中包含四个功能函数，其中getLt(str) 函数用于从loginUrl 里获取本次登录所特有的参数，如lt， execution 等； getNewsDetaill(objectUrl, session) 函数用于获得所需要爬取的页面的标题、日期和文章主体； toSqlServer(df) 函数用于将df 写入database 数据库的lablename 表中； getInformation() 函数用于将所需要爬取的信息保存到SQL Server 数据库。设计图如下图所示。</p>
<p><img src="/2021/06/10/%E4%BF%A1%E6%81%AF%E9%97%A8%E6%88%B7%E9%80%9A%E7%9F%A5%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438716190252.png" alt=" "></p>
<p>该部分的接口描述如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口名称</th>
<th>输入信息</th>
<th>输出信息</th>
<th>异常处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>toSqlServer</td>
<td>需要存入数据库的DataFrame 类型数据df</td>
<td>None</td>
<td>Try: 将数据插入对应表中Except: 无法插入，则提示插入数据失败，并显示报错结果</td>
</tr>
<tr>
<td>getInformaion</td>
<td>登录页面的URL、登录页面后获得的cookie、需要爬取消息列表对应的URL、需要爬取的消息对应的Href、对应的数据库中的表名</td>
<td>获取的URL和是否成功插入数据</td>
<td>Try: 成功获取信息Except: 获取失败，则提示执行失败的模块，并显示报错结果</td>
</tr>
</tbody>
</table>
</div>
<h2 id="4-2-JAVA-Tomcat服务器模块"><a href="#4-2-JAVA-Tomcat服务器模块" class="headerlink" title="4.2 JAVA Tomcat服务器模块"></a>4.2 JAVA Tomcat服务器模块</h2><p>该部分包含9个类，设计图如下图所示。</p>
<p><img src="/2021/06/10/%E4%BF%A1%E6%81%AF%E9%97%A8%E6%88%B7%E9%80%9A%E7%9F%A5%E6%9F%A5%E8%AF%A2%E7%B3%BB%E7%BB%9F/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png" alt=" "></p>
<p>该模块接口描述如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口名称</th>
<th>输入信息</th>
<th>输出信息</th>
<th>异常处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>informationDatabase</td>
<td>需要连入的数据库及列表名</td>
<td>查询到的数据结果</td>
<td>Try: 将数据存入数组中 Except: 无法存入，则提示失败，并显示报错结果</td>
</tr>
<tr>
<td>userDatabase</td>
<td>需要连入的数据库及列表名</td>
<td>查询到的数据结果</td>
<td>Try: 将数据存入数组中 Except: 无法存入，则提示失败，并显示报错结果</td>
</tr>
<tr>
<td><a href="http://localhost:8080/userServer/userServlet">http://localhost:8080/userServer/userServlet</a></td>
<td>用户名username 密码password</td>
<td>成功：success 失败：error</td>
<td>Try：在网页上显示数据内容 Except：打印错误报告</td>
</tr>
<tr>
<td><a href="http://localhost:8080/articleServer/notificationServlet">http://localhost:8080/articleServer/notificationServlet</a></td>
<td>None</td>
<td>返回对应JSON数据</td>
<td>Try：在网页上显示数据内容 Except：打印错误报告</td>
</tr>
<tr>
<td><a href="http://localhost:8080/articleServer/newsServlet">http://localhost:8080/articleServer/newsServlet</a></td>
<td>None</td>
<td>返回对应JSON数据</td>
<td>Try：在网页上显示数据内容 Except：打印错误报告</td>
</tr>
<tr>
<td><a href="http://localhost:8080/articleServer/announcementServlet">http://localhost:8080/articleServer/announcementServlet</a></td>
<td>None</td>
<td>返回对应JSON数据</td>
<td>Try：在网页上显示数据内容 Except：打印错误报告</td>
</tr>
<tr>
<td><a href="http://localhost:8080/articleServer/lectureServlet">http://localhost:8080/articleServer/lectureServlet</a></td>
<td>None</td>
<td>返回对应JSON数据</td>
<td>Try：在网页上显示数据内容 Except：打印错误报告</td>
</tr>
</tbody>
</table>
</div>
<p>返回的JSON参数格式如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数类型</th>
<th>说明</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>String</td>
<td>信息标题</td>
<td>None</td>
</tr>
<tr>
<td>date</td>
<td>String</td>
<td>信息发布日期</td>
<td>若为学术讲座，该部分包含主办学院</td>
</tr>
<tr>
<td>article</td>
<td>String</td>
<td>信息主体</td>
<td>None</td>
</tr>
<tr>
<td>image</td>
<td>Array</td>
<td>图片的 URL 地址</td>
<td>None</td>
</tr>
</tbody>
</table>
</div>
<p>主体代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> model.Information;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">informationDatabase</span> </span>&#123;</span><br><span class="line">    String lableName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Connection ct = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pestmt = <span class="keyword">null</span>;</span><br><span class="line">    String jsonOutput = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Information&gt; information = <span class="keyword">new</span> ArrayList&lt;Information&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">informationDatabase</span><span class="params">(String lableName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lableName = lableName;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>);</span><br><span class="line">            ct = DriverManager.getConnection(<span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=schoolNews&quot;</span>, <span class="string">&quot;这里输入数据库用户名&quot;</span>, <span class="string">&quot;这里输入数据库密码&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (ct != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库连接成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库连接失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通知信息并存储到Notification数组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInformation</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在打包发送 校内通知&quot;</span>);</span><br><span class="line"></span><br><span class="line">            pestmt = ct.prepareStatement(<span class="string">&quot;select * from &quot;</span> + <span class="keyword">this</span>.lableName + <span class="string">&quot; order by date desc&quot;</span>);</span><br><span class="line">            ResultSet rs = pestmt.executeQuery(); <span class="comment">// 将数据库响应的查询结果放在rs中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            	<span class="comment">//System.out.println(rs.getString(1)+&quot;,&quot;);	//标题</span></span><br><span class="line">            	<span class="comment">//System.out.println(rs.getString(2)+&quot;,&quot;);</span></span><br><span class="line">            	<span class="comment">//System.out.println(rs.getString(3)+&quot;,&quot;);</span></span><br><span class="line">                String[] imgUrls = rs.getString(<span class="number">4</span>).split(<span class="string">&quot;,&quot;</span>); <span class="comment">// 将image字符串按逗号分割，成为数组</span></span><br><span class="line">                Information information = <span class="keyword">new</span> Information(rs.getString(<span class="number">1</span>),rs.getString(<span class="number">2</span>),rs.getString(<span class="number">3</span>),imgUrls);</span><br><span class="line">                <span class="keyword">this</span>.information.add(information);</span><br><span class="line">            &#125;</span><br><span class="line">            jsonOutput = JSON.toJSONString(information);</span><br><span class="line">            System.out.println(jsonOutput);</span><br><span class="line">            <span class="keyword">return</span> jsonOutput;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;转换JSON出错&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ct.close();</span><br><span class="line">            pestmt.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> database;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> model.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userDatabase</span> </span>&#123;</span><br><span class="line">    Connection ct = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pestmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">userDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>);</span><br><span class="line">            ct=DriverManager.getConnection(<span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=schoolNews&quot;</span>, <span class="string">&quot;数据库用户名&quot;</span>, <span class="string">&quot;数据库密码&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(ct != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库连接成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库连接失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确认登录信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">checkUser</span><span class="params">(String username,String password)</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在确认登录信息&quot;</span>);</span><br><span class="line">            <span class="comment">// 该处报错原因：nvarchar和ntext的类型不匹配。解决方案参考：https://blog.csdn.net/weixin_34343000/article/details/92824471</span></span><br><span class="line">            pestmt=ct.prepareStatement(<span class="string">&quot;select * from [User] where convert(nvarchar(255),username)=? and convert(nvarchar(255),password)=?&quot;</span>);</span><br><span class="line">            pestmt.setString(<span class="number">1</span>, username);</span><br><span class="line">            pestmt.setString(<span class="number">2</span>, password);</span><br><span class="line">            ResultSet rs=pestmt.executeQuery(); <span class="comment">// 将数据库响应的查询结果放在rs中</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库响应结果为：&quot;</span> + rs.toString());</span><br><span class="line"></span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                user.setUsername(rs.getString(<span class="number">1</span>));<span class="comment">//第一个属性</span></span><br><span class="line">                user.setPassword(rs.getString(<span class="number">2</span>));<span class="comment">//第二个属性</span></span><br><span class="line">                System.out.println(<span class="string">&quot;用户信息为：&quot;</span> + user.getUsername() + <span class="string">&quot; &quot;</span> + user.getPassword());</span><br><span class="line">                <span class="keyword">return</span> user;	<span class="comment">///查到就返回对象</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            ct.close();</span><br><span class="line">            pestmt.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-3-前端登录页面"><a href="#4-3-前端登录页面" class="headerlink" title="4.3 前端登录页面"></a>4.3 前端登录页面</h2><p>本模块实现登陆功能。用户输入用户名（学号）与密码，前端进行简单的表单校验后， 通过 login 接口将数据传到数据库进行账号与密码的比对，如果成功的话，将跳转到消息页 面，反之将提醒用户账号与密码错误。</p>
<ul>
<li>输入：用户名（学号）与密码 </li>
<li>输出：登陆成功与否的信息 </li>
<li>异常处理：用户名或密码为空时，前端将告知用户名或密码为空，这时数据将不被传到后端</li>
<li>安全处理：密码传输过程采用国密SM3加密</li>
</ul>
<p>该部分主体代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">login: <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> password =  e.detail.value.password</span><br><span class="line">  <span class="keyword">let</span> username =  e.detail.value.username</span><br><span class="line">  <span class="keyword">var</span> unameNULL = (username.length === <span class="number">0</span>) ? <span class="literal">true</span> : <span class="literal">false</span>   <span class="comment">// 判断用户名是否为空</span></span><br><span class="line">  <span class="keyword">var</span> pwdVaild = (password.length &lt; <span class="number">6</span>) ? <span class="literal">false</span> : <span class="literal">true</span>      <span class="comment">// 判断密码是否大于6位</span></span><br><span class="line">  <span class="keyword">var</span> unameSpace = username.lastIndexOf(<span class="string">&#x27; &#x27;</span>)               <span class="comment">// 判断用户名中有没有空格,值为-1时没有</span></span><br><span class="line">  <span class="keyword">var</span> pwdSpace = password.lastIndexOf(<span class="string">&#x27; &#x27;</span>)                 <span class="comment">// 判断密码中有没有空格,值为-1时没有</span></span><br><span class="line">  <span class="built_in">console</span>.log(pwdVaild,unameNULL)</span><br><span class="line">  <span class="built_in">console</span>.log(sm3(<span class="string">&#x27;nihao&#x27;</span>))</span><br><span class="line">  <span class="comment">// 用户名不为空以及密码大于6位且其中都没有空格时，才传递登录表单</span></span><br><span class="line">  <span class="keyword">if</span>(!unameNULL &amp;&amp; pwdVaild &amp;&amp; unameSpace === -<span class="number">1</span> &amp;&amp; pwdSpace === -<span class="number">1</span>)&#123;</span><br><span class="line">    password = sm3(password)  <span class="comment">// 上传前，先基于国密算法sm3将密码加密</span></span><br><span class="line">    <span class="built_in">console</span>.log(password)</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:8080/userServer/userServlet&#x27;</span>, <span class="comment">//后端的url地址  </span></span><br><span class="line">      <span class="comment">// 传给后端的数据 —— 用户名与加密后的密码</span></span><br><span class="line">      <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">username</span>: username,</span><br><span class="line">        <span class="attr">password</span>: password,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">      <span class="attr">header</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span> <span class="comment">// 默认值</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// res为从后端获取的数据</span></span><br><span class="line">      <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        <span class="built_in">console</span>.log(res.statusCode === <span class="number">200</span>);</span><br><span class="line">        <span class="comment">// 只要后端返回的状态码以2开头，即请求成功的情况</span></span><br><span class="line">        <span class="keyword">if</span> (res.statusCode === <span class="number">200</span>) &#123;</span><br><span class="line">          <span class="comment">// 登录成功，将跳转至首页</span></span><br><span class="line">          <span class="keyword">if</span>(res.data === <span class="string">&#x27;success&#x27;</span>) &#123;</span><br><span class="line">            wx.showToast(&#123;</span><br><span class="line">              <span class="attr">title</span>: <span class="string">&#x27;登录成功！&#x27;</span>,</span><br><span class="line">              <span class="attr">duration</span>: <span class="number">1000</span></span><br><span class="line">            &#125;)</span><br><span class="line">            wx.switchTab(&#123;</span><br><span class="line">              <span class="attr">url</span>: <span class="string">&#x27;../index/index&#x27;</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="comment">// 这个是登录失败的处理，界面将显示提示字段,告知用户是哪个部分出错</span></span><br><span class="line">          <span class="keyword">else</span> that.setData(&#123; <span class="attr">flag</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          wx.showToast(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;服务器异常&#x27;</span>,</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">fail</span>: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        wx.showToast(&#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;网络异常！&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;失败！！！！！！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 设置标志位，不管什么时候都进行</span></span><br><span class="line">  <span class="built_in">this</span>.setData(&#123;</span><br><span class="line">    <span class="attr">unameNULL</span>: unameNULL,</span><br><span class="line">    <span class="attr">pwdVaild</span>: pwdVaild,</span><br><span class="line">    <span class="attr">unameSpace</span>: unameSpace,</span><br><span class="line">    <span class="attr">pwdSpace</span>: pwdSpace</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2 id="4-4-前端信息展示模块"><a href="#4-4-前端信息展示模块" class="headerlink" title="4.4 前端信息展示模块"></a>4.4 前端信息展示模块</h2><p>渲染效果上，利用组件 mp-cells &amp; mp-cell 组件为用户带来一致的视觉体验。将事先设计一个信息展示的模板（信息详情页），以确保所有的信息都可以规范地展示出来，让用户的视觉体验更加统一。 </p>
<p>逻辑实现上，四种类型的消息每一个都对应着一个列表。运用条件渲染语句 wx:for（类 似于 C/C++中的 for 语句）来对列表数据进行循环渲染，以实现消息的展示效果。使用搜索 时，利用条件渲染语句 wx:if 将主页面隐藏，只留下搜索部分。利用 JS 的字符串方法将搜 索内容与全局消息进行匹配，将结果放入列表当中，由条件渲染语句 wx:for 来展示。当用 户点击对应信息后，由小程序自带的函数来获取这条消息对应的列表索引。获取这条消息的 详情信息，随后携带其详情信息跳转到信息详情页。</p>
<p>该部分主体代码实现如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">van-tab</span> <span class="attr">title</span>=<span class="string">&quot;校内通知&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mp-cells</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mp-cell</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;noticeList&#125;&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span> <span class="attr">link</span> <span class="attr">hover</span>=<span class="string">&quot;true&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;getDetail&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;font-size:14px;margin-bottom:8px&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;margin:4px;font-weight:bolder&quot;</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">text</span> <span class="attr">style</span>=<span class="string">&quot;margin:4px&quot;</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mp-cell</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mp-cells</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">van-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">van-tab</span> <span class="attr">title</span>=<span class="string">&quot;校内新闻&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mp-cells</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mp-cell</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;newList&#125;&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span> <span class="attr">link</span> <span class="attr">hover</span>=<span class="string">&quot;true&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;getDetail&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;font-size:14px;margin-bottom:8px&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;margin:4px;font-weight:bolder&quot;</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">text</span> <span class="attr">style</span>=<span class="string">&quot;margin:4px&quot;</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mp-cell</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mp-cells</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">van-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">van-tab</span> <span class="attr">title</span>=<span class="string">&quot;公示公告&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mp-cells</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mp-cell</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;signiList&#125;&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span> <span class="attr">link</span> <span class="attr">hover</span>=<span class="string">&quot;true&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;getDetail&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;font-size:14px;margin-bottom:8px&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;margin:4px;font-weight:bolder&quot;</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">text</span> <span class="attr">style</span>=<span class="string">&quot;margin:4px&quot;</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mp-cell</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mp-cells</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">van-tab</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">van-tab</span> <span class="attr">title</span>=<span class="string">&quot;学术讲座&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mp-cells</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mp-cell</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;academicList&#125;&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&#123;&#123;index&#125;&#125;&quot;</span> <span class="attr">link</span> <span class="attr">hover</span>=<span class="string">&quot;true&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;getDetail&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;font-size:14px;margin-bottom:8px&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;margin:4px;font-weight:bolder&quot;</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">view</span> <span class="attr">style</span>=<span class="string">&quot;margin:4px&quot;</span>&gt;</span>&#123;&#123;item.tutor&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">text</span> <span class="attr">style</span>=<span class="string">&quot;margin:4px&quot;</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mp-cell</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mp-cells</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">van-tab</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-tabs</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-5-前端个人信息展示模块"><a href="#4-5-前端个人信息展示模块" class="headerlink" title="4.5 前端个人信息展示模块"></a>4.5 前端个人信息展示模块</h2><p>本模块展示用户的个人信息。同时提供用户个人收藏消息的管理</p>
<p>该部分主体实现代码如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mp-cells</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mp-cell</span> <span class="attr">id</span>=<span class="string">&quot;avatar&quot;</span> <span class="attr">title</span>=<span class="string">&quot;头像：&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;userinfo-avatar&quot;</span> <span class="attr">src</span>=<span class="string">&quot;&#123;&#123;avatar&#125;&#125;&quot;</span> <span class="attr">mode</span>=<span class="string">&quot;cover&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mp-cell</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mp-cell</span> <span class="attr">id</span>=<span class="string">&quot;nickname&quot;</span> <span class="attr">title</span>=<span class="string">&quot;昵称: &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">style</span>=<span class="string">&quot;margin-left:55vw&quot;</span>&gt;</span>&#123;&#123;nickname&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mp-cell</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mp-cell</span> <span class="attr">id</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">title</span>=<span class="string">&quot;性别：&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">style</span>=<span class="string">&quot;margin-left:65vw&quot;</span>&gt;</span>&#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mp-cell</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mp-cell</span> <span class="attr">title</span>=<span class="string">&quot;收藏管理&quot;</span> <span class="attr">hover</span>=<span class="string">&quot;true&quot;</span> <span class="attr">link</span> <span class="attr">url</span>=<span class="string">&quot;../collectInfo/collectInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mp-cell</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mp-cells</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-6-前端收藏管理模块"><a href="#4-6-前端收藏管理模块" class="headerlink" title="4.6 前端收藏管理模块"></a>4.6 前端收藏管理模块</h2><p>本模块提供收藏模块的管理功能（查看收藏的消息，或者对消息取消收藏），分为信息的展示页以及信息详情页两部分。</p>
<p>该部分主体实现代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getDetail: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e)</span><br><span class="line">  <span class="keyword">var</span> index = <span class="built_in">parseInt</span>(e.currentTarget.id)</span><br><span class="line">  <span class="keyword">var</span> tab = <span class="built_in">this</span>.data.nowTab</span><br><span class="line">  <span class="keyword">var</span> info = <span class="built_in">this</span>.data.collectionList[index]</span><br><span class="line">  <span class="keyword">var</span> title = info.title</span><br><span class="line">  <span class="keyword">var</span> date = info.date</span><br><span class="line">  <span class="keyword">var</span> article = <span class="built_in">encodeURIComponent</span>(info.article)</span><br><span class="line">  <span class="keyword">var</span> image = info.image</span><br><span class="line">  <span class="keyword">var</span> like = <span class="literal">true</span>                           <span class="comment">// 本部分的like肯定是true</span></span><br><span class="line">  <span class="keyword">var</span> id = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">var</span> collectList = <span class="built_in">this</span>.data.collectionList</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; collectList.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(title === collectList[i].title)&#123;</span><br><span class="line">      id = collectList[i]._id</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tab === <span class="string">&#x27;学术讲座&#x27;</span>) </span><br><span class="line">    tutor = info.tutor</span><br><span class="line">  wx.navigateTo(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;../noticeDetail/noticeDetail?title=&#x27;</span> + title + <span class="string">&#x27;&amp;date=&#x27;</span> + date + <span class="string">&#x27;&amp;id=&#x27;</span> + id + </span><br><span class="line">    <span class="string">&#x27;&amp;article=&#x27;</span> + article + <span class="string">&#x27;&amp;tab=&#x27;</span> + tab + <span class="string">&#x27;&amp;image=&#x27;</span> + image + <span class="string">&#x27;&amp;like=&#x27;</span> + like,</span><br><span class="line">    <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fail</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">request</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="built_in">this</span></span><br><span class="line">  DB.get(&#123;</span><br><span class="line">    <span class="attr">_openid</span>: app.globalData.openid,</span><br><span class="line">    <span class="function"><span class="title">success</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">      that.setData(&#123;</span><br><span class="line">        <span class="attr">collectionList</span>: res.data</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(that.data.collectionList)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fail</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h1 id="5-数据库与数据结构设计"><a href="#5-数据库与数据结构设计" class="headerlink" title="5 数据库与数据结构设计"></a>5 数据库与数据结构设计</h1><p>本系统内使用的数据库系统为 Microsoft SQL Server 2019 数据库，数据库中包含表 User, schoolAnnouncements, schoolArticles, schoolLectures 和 schoolNews 五张表，分别用于 用户登录鉴权、公告公示、校内通知、学术讲座和校内新闻的存储。</p>
<p>五张表中，User 表的数据结构设计如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>允许 Null 值</th>
</tr>
</thead>
<tbody>
<tr>
<td>username</td>
<td>nchar(10)</td>
<td>√</td>
</tr>
<tr>
<td>password</td>
<td>ntext</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
<p>schoolAnnouncements, schoolArticles, schoolLectures 和 schoolNews 表的数据结构设计如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>数据类型</th>
<th>允许 Null 值</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>nvarchar(50)</td>
<td>√</td>
</tr>
<tr>
<td>date</td>
<td>nvarchar(50)</td>
<td>√</td>
</tr>
<tr>
<td>article</td>
<td>ntext</td>
<td>√</td>
</tr>
<tr>
<td>image</td>
<td>ntext</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
<p>数据存储设计：</p>
<ul>
<li>访问方法：程序登录数据库后，通过 SQL 语句直接取用；</li>
<li>每次取用整组数据，对整组数据进行搜索，最终将得到的数据在程序中处理；</li>
<li>所有数据存储在电脑硬盘中，由程序按期删除；</li>
<li>数据库内容的保密通过连接数据库时所使用的用户名、密码所对应的权限来进行区分。</li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
        <category>Python</category>
        <category>微信小程序</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Java</tag>
        <tag>SQL Server</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2022/03/30/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>欢迎来到我的博客！这里将记录我学习和生活的一些日常~</p>
<p>下面是我的一些基本信息</p>
<ul>
<li>北京邮电大学/信息与通信工程学院/本科生</li>
<li>北京邮电大学/人工智能学院/硕士研究生</li>
<li>邮箱：lgc0208@foxmail.com</li>
<li>Github: <a href="https://github.com/lgc0208">https://github.com/lgc0208</a></li>
<li>CSDN：<a href="https://blog.csdn.net/weixin_45817309?spm=1000.2115.3001.5343">https://blog.csdn.net/weixin_45817309?spm=1000.2115.3001.5343</a></li>
</ul>
<p>您可以访问我的 <a href="https://github.com/lgc0208">GitHub</a> 主页进一步了解我在学业方面的一些成果</p>
<p>我开发的一些其他小工具：</p>
<ul>
<li><a href="https://lgc0208.github.io/course_reference_SICE_BUPT/">北京邮电大学信息与通信工程学院选课指南</a></li>
<li><a href="https://lgc0208.github.io/reference_format_generation/">参考文献格式生成器（目前支持 GB/T 7714-2015 和 IEEE）</a></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>北京邮电大学信息与通信工程学院选课参考指南</title>
    <url>/2022/02/18/%E9%A1%B9%E7%9B%AE-HTML-%E5%8C%97%E9%82%AE%E4%BF%A1%E9%80%9A%E9%99%A2%E9%80%89%E8%AF%BE%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>大部分人都希望选到一个分高活少性价比高的选修课，这就导致了每次选课之前需要花费大量的时间向学长学姐们打听消息。基于此，我就想不如做一个简单的自助查询前端，让有需求的同学可以随时查询其他学长学姐们对课程和授课老师的评价，学长学姐们也可以对课程和授课老师进行评价。因此，就有了这个选课指南的诞生。</p>
<span id="more"></span>
<h2 id="网页预览"><a href="#网页预览" class="headerlink" title="网页预览"></a>网页预览</h2><p><img src="/2022/02/18/%E9%A1%B9%E7%9B%AE-HTML-%E5%8C%97%E9%82%AE%E4%BF%A1%E9%80%9A%E9%99%A2%E9%80%89%E8%AF%BE%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/image-20220218174729162.png" alt="首页"></p>
<p><img src="/2022/02/18/%E9%A1%B9%E7%9B%AE-HTML-%E5%8C%97%E9%82%AE%E4%BF%A1%E9%80%9A%E9%99%A2%E9%80%89%E8%AF%BE%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/image-20220218174944886.png" alt="课程类别"></p>
<p><img src="/2022/02/18/%E9%A1%B9%E7%9B%AE-HTML-%E5%8C%97%E9%82%AE%E4%BF%A1%E9%80%9A%E9%99%A2%E9%80%89%E8%AF%BE%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/image-20220218175011188.png" alt="课程名称"></p>
<p><img src="/2022/02/18/%E9%A1%B9%E7%9B%AE-HTML-%E5%8C%97%E9%82%AE%E4%BF%A1%E9%80%9A%E9%99%A2%E9%80%89%E8%AF%BE%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/image-20220218175052249.png" alt="授课教师选择"></p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="只想检索数据"><a href="#只想检索数据" class="headerlink" title="只想检索数据"></a>只想检索数据</h3><ol>
<li>网址：www.xtxkzn.ml （信通选课指南.机器学习）</li>
<li>Github Page 网址（备用）：<a href="https://lgc0208.github.io/course_reference_SICE_BUPT/">https://lgc0208.github.io/course_reference_SICE_BUPT/</a></li>
<li>进入仓库 <a href="https://github.com/lgc0208/course_reference_SICE_BUPT">https://github.com/lgc0208/course_reference_SICE_BUPT</a> 下载源代码。下载文件后，使用浏览器打开 <code>index.html</code> 文件（此时最好保持联网状态，因为代码里使用了<code>bootstrap</code>和<code>jquery</code>，不联网可能 UI 会很乱）</li>
</ol>
<h3 id="想要获取原始数据"><a href="#想要获取原始数据" class="headerlink" title="想要获取原始数据"></a>想要获取原始数据</h3><p>进入 <a href="https://github.com/lgc0208/course_reference_SICE_BUPT">Github 仓库</a> 后，可以下载其中的 <code>data.js</code> 文件</p>
<ul>
<li><code>data.js</code> 文件中储存了原始数据，初始数据来自于2021年年底信通院18级 ZJR 同学创建的共享文档。后续数据来自于使用问卷星征集到的投稿。投稿链接：<a href="https://www.wjx.cn/vj/wGw4GYE.aspx">https://www.wjx.cn/vj/wGw4GYE.aspx</a></li>
<li>数据开源存储，不排除可能因为不可抗力因素关闭本平台</li>
<li><code>data.js</code> 中的数据格式为<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;course_type&quot;: &quot;&quot;, </span><br><span class="line">    &quot;course&quot;: &quot;&quot;, </span><br><span class="line">    &quot;teacher&quot;: &quot;&quot;, </span><br><span class="line">    &quot;score&quot;: &quot;&quot;, </span><br><span class="line">    &quot;description&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="UI-界面"><a href="#UI-界面" class="headerlink" title="UI 界面"></a>UI 界面</h2><p><code>index.html</code>是使用<code>bootstrap</code>和<code>jquery</code>完成的简易的检索页面，页面所需要的数据存储在<code>data.js</code>中，页面背景存储在 <code>figure</code> 文件夹中。初始背景为 <code>figure/blue_snow.png</code></p>
<h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>在非选课期间，数据更新频率会保持在半个月至一个月一次。在选课期间，数据更新频率会保持在一天两次。也可以通过该项目的issue催更</p>
<p>为了便于管理，请统一使用投稿链接：<a href="https://www.wjx.cn/vj/wGw4GYE.aspx">https://www.wjx.cn/vj/wGw4GYE.aspx</a> 进行投稿。问卷星收集到的问卷完全匿名，请尽量客观。对于具有明显人身攻击的投稿无法进行更新，请您见谅</p>
<p><strong>祝大家都能选到轻松愉悦分还高的选修课！</strong></p>
]]></content>
      <categories>
        <category>项目</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>【Docker】 Docker attach 命令卡死的解决方案</title>
    <url>/2023/12/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Docker-Docker%20attach%E5%8D%A1%E6%AD%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在启动较早期的容器时，出现了使用 <code>docker attach container_name</code> 命令后卡死的问题。本文介绍了如何解决该问题。</p>
<span id="more"></span>
<p>首先，在使用 <code>docker attach container_name</code> 命令前需要先保证容器已经开启。此时，输入 <code>docker attach container_name</code> 命令后卡死的原因大概率是容器的驻守程序设定为 sshd 而非 bash。然而，sshd 驻守进程是不接受输入的，因此任何输入在该容器内都无效，在命令行中表现为卡死状态。</p>
<p>了解症结后，解决方案就非常简单了，只需要把不接受输入的 sshd 驻守进程更换为交互式的 bash 进程即可。对一个正在运行的程序而言，只需要输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it container_name /bin/bash</span><br></pre></td></tr></table></figure>
<p>即可进入对应容器。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>【系统】 Docker 镜像打包过程</title>
    <url>/2022/11/26/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Docker-Docker%E9%95%9C%E5%83%8F%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>介绍了 Docker 中镜像的打包过程。</p>
<span id="more"></span>
<h2 id="镜像打包过程"><a href="#镜像打包过程" class="headerlink" title="镜像打包过程"></a>镜像打包过程</h2><p>首先进入管理员模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure>
<p>再查看当前现有的容器，查询需要保存镜像的 ID</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>先关闭准备打包的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop 容器ID</span><br></pre></td></tr></table></figure>
<p>使用 commit 参数将容器打包为镜像，其中 -a 后跟着提交人的姓名，-m 后跟着提交内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -a <span class="string">&quot;作者名&quot;</span> -m <span class="string">&quot;附加信息&quot;</span> 容器ID 保存后的镜像名称:版本号</span><br></pre></td></tr></table></figure>
<p>运行完成后，查看镜像是否保存成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>看到刚才打包的镜像 pfrp:v1.0.0 出现，说明保存成功了。</p>
<p>若要删除镜像，可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure>
<p>接下来将其保存为 tar 镜像，使用 save 参数进行打包，其中，-o 后面参数是 tar 文件的名称，接着是镜像 Repository:TAG</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o 镜像名.tar 保存后的镜像名称:版本号</span><br></pre></td></tr></table></figure>
<p>后续需要加载 tar 镜像的话，可以使用 load 命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i 镜像名.tar</span><br></pre></td></tr></table></figure>
<p>然后查看是否出现镜像即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>【Win10】 HM 软件安装</title>
    <url>/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HM-HM_setup/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录了 HM 软件的安装过程。</p>
<span id="more"></span>
<h1 id="HEVC"><a href="#HEVC" class="headerlink" title="HEVC"></a>HEVC</h1><p>高效视频编码（HEVC）是ITU-T视频编码专家组(ITU-T Q.6/SG 16) 和 ISO/IEC运动图像专家组 (ISO/IEC JTC 1/ SC 29/WG 11) 成立了视频编码联合协作小组(JCT-VC)来开展该项目。该小组的范围已扩展为继续研究格式范围扩展 (RExt)、可扩展HEVC (SHVC) 和屏幕内容编码 (SCC) 作为 HEVC 的扩展。HEVC 标准的第一个版本于 2013 年 4 月完成。HEVC 的第二个版本，包括RExt、SHVC和MV-HEVC扩展，于 2014 年 10 月完成。包括3D-HEVC扩展在内的第三版HEVC已于 2015 年 2 月完成。</p>
<h1 id="HM"><a href="#HM" class="headerlink" title="HM"></a>HM</h1><p>HM（HEVC Test Model）是官方定义的HEVC参考软件，包括编码器和解码器功能。</p>
<p>HM软件有助于帮助视频编码标准的用户建立和测试一致性和可操作性，具有用于教育和展示标准的功能。该软件由ITU-T 视频编码专家组（VCEG，ITU-T 第 16 研究组第 6 题）和 ISO/IEC运动图像专家组（MPEG，ISO/IEC 第 29 分委员会第 11 工作组）联合开发联合技术委员会)，由联合视频专家组 (JVET) 维护，该组是 ITU-T 视频编码专家组（VCEG，ITU-T 第 16 研究组的第 6 题）和 ISO/IEC 运动图像专家组(MPEG , ISO/IEC 联合技术委员会 1) 第 29 分委员会第 5 工作组。</p>
<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><ul>
<li><p>实验软件：HM 16.20，Vitural Stuidio 2019</p>
</li>
<li><p>实验设备：Legion Y7000 2019 PG0。</p>
</li>
<li><p>操作系统：Windows 10 家庭中文版20H2版本</p>
</li>
</ul>
<h1 id="HM安装步骤及操作说明"><a href="#HM安装步骤及操作说明" class="headerlink" title="HM安装步骤及操作说明"></a>HM安装步骤及操作说明</h1><h2 id="Tortoise-SVN下载"><a href="#Tortoise-SVN下载" class="headerlink" title="Tortoise SVN下载"></a>Tortoise SVN下载</h2><p>HM采用SVN进行代码管理，不能直接从网页下载。因此需要利用SVN软件下载。Tortoise SVN下载链接：<a href="https://tortoisesvn.net/">https://tortoisesvn.net/</a> 。打开链接后，点击 Download 标签栏，在出现的下载选项中选择合适的版本进行下载。</p>
<p><img src="/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HM-HM_setup/48ae278c0cfc6eb93a3d2ff05c0d79ff.png" alt="图 1 Tortise SVN下载"></p>
<h2 id="HM下载"><a href="#HM下载" class="headerlink" title="HM下载"></a>HM下载</h2><p>完成上一节的下载后，回到桌面，右键空白处即可看到Tortise SVN选项，如图2所示。点击后进入Repo-browser，在弹出的URL输入框中输入HM的下载地址：<a href="https://hevc.hhi.fraunhofer.de/svn/svn_HEVCSoftware/tags/">https://hevc.hhi.fraunhofer.de/svn/svn_HEVCSoftware/tags/</a> 。输入后点击OK，可以获得不同版本的HM软件，如图3所示。选定合适的版本后右击其对应的文件夹，点击Checkout即可下载。</p>
<p><img src="/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HM-HM_setup/0605ec886e6b1d6d9d43845524910406.png" alt="图 2 桌面右击空白处"></p>
<p><img src="/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HM-HM_setup/3a9c09b737511fe3f6fb35f4580f6fd0.png" alt="图 3 HM版本选择"></p>
<h2 id="HM安装"><a href="#HM安装" class="headerlink" title="HM安装"></a>HM安装</h2><p>完成HM下载后，打开对应的文件夹，进入 <code>build</code> 文件夹，如图4所示。其中包含了不同环境下的编译文件，支持Linux系统和Windows系统。根据电脑中存在的编译环境，选择并打开 <code>HM_vc2015.sln</code> 文件。</p>
<p><img src="/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HM-HM_setup/384e754746e92ec81759a32345cdfa2b.png" alt="图 4 build文件夹内容"></p>
<p>打开sln文件后，可以看到解决方案资源管理器中有10个项目，如图5所示。右击 <code>解决方案”HM_vc2015”</code>，选择 <code>属性</code>，选择 <code>单启动项目</code>，单启动项目中选择 <code>TAppEncoder</code>，如图6所示。此处为对其进行编码。如果需要进行解码，则在单启动项目中应选择<code>AppDecoder</code>。点击 <code>确定</code> 保存设置。完成后右击 <code>解决方案</code>，在弹出的菜单栏中点击 <code>生成解决方案</code>。</p>
<p>生成解决方案成功后，在 <code>HM</code> 文件夹下会生成一个 <code>bin</code> 文件夹。进入 <code>bin</code> 文件夹，看到有一个 <code>vc2015</code> 文件夹。继续进入 <code>vc2015</code> 文件夹，点击 <code>Win32</code> 文件夹，可以看到 <code>debug</code> 文件夹。进入 <code>debug</code> 文件夹，可以看到有两个可执行文件 <code>TAppDecoder.exe</code> 和<code>TAppEncoder.exe</code></p>
<p><img src="/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HM-HM_setup/b3bd39a8477009783cd73f514678b3b6.png" alt="图 5 sln文件打开后的解决方案"></p>
<p><img src="/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HM-HM_setup/e9c37afd340954c8deda1b18e4d8921e.png" alt="图 6 解决方案属性"></p>
<h2 id="编码配置"><a href="#编码配置" class="headerlink" title="编码配置"></a>编码配置</h2><p>完成上述步骤后，回到 <code>Virtual Studio</code> 软件。点击顶部菜单栏中的 <code>调试</code>，选择 <code>TAppEncoder调试属性</code> ，在配置属性中点击 <code>调试</code> 进行配置。这里需要更改 <code>工作目录</code> 和 <code>命令参数</code>。在配置工作目录时，需要现在 <code>HM</code> 文件夹下创建一个 <code>workspace</code> 文件夹作为工作目录，再在工作目录中选择新建的 <code>workspace</code> 路径。在命令参数中输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-c encoder_intra_main.cfg -c bitstream.cfg&gt; &gt;out.txt</span><br></pre></td></tr></table></figure>
<p>并将 <code>HM</code> 文件夹中 <code>cfg</code> 文件夹里的 <code>encoder_intra_main.cfg</code> 文件复制到 <code>workspace</code> 文件夹下。此外，还需要在 <code>workspace</code>文件夹下新建 <code>bitstream.cfg</code> 文件。<code>bitstream.cfg</code> 文件格式可以直接复制 <code>HM</code> 文件夹中 <code>per-sequence</code> 文件夹下的任意配置文件。<code>bitstream.cfg</code> 文件的内容如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#======== File I/O =============== </span></span><br><span class="line">InputFile                  : E:\HM-16.20+SCM-8.8\workspace\yuv\salesman_qcif.yuv </span><br><span class="line">InputBitDepth              : 8           <span class="comment"># Input bitdepth </span></span><br><span class="line">InputChromaFormat          : 420         <span class="comment"># Ratio of luminance to chrominance samples </span></span><br><span class="line">FrameRate                  : 50          <span class="comment"># Frame Rate per second </span></span><br><span class="line">FrameSkip                  : 0           <span class="comment"># Number of frames to be skipped in input </span></span><br><span class="line">SourceWidth                : 176         <span class="comment"># Input  frame width </span></span><br><span class="line">SourceHeight               : 144         <span class="comment"># Input  frame height </span></span><br><span class="line">FramesToBeEncoded          : 449         <span class="comment"># Number of frames to be coded </span></span><br><span class="line">Level                      : 3.1</span><br></pre></td></tr></table></figure>
<p>其中，参数由上至下分别为输入文件路径、位深度、亮度与色度比值、帧率、输入帧跳过帧数、输入帧宽度、输入帧高度以及编码帧数。这些参数需要根据输入的文件进行调整。</p>
<p>完成上述步骤后，就可以对YUV文件进行编码了。</p>
<h1 id="YUV到HEVC的编码过程和结果分析"><a href="#YUV到HEVC的编码过程和结果分析" class="headerlink" title="YUV到HEVC的编码过程和结果分析"></a>YUV到HEVC的编码过程和结果分析</h1><h2 id="YUV视频下载"><a href="#YUV视频下载" class="headerlink" title="YUV视频下载"></a>YUV视频下载</h2><p>YUV视频可以通过网址 <a href="http://trace.eas.asu.edu/yuv/">http://trace.eas.asu.edu/yuv/</a> 进行下载。该网址中还提供了我们所需要的 YUV 视频的各种参数。下载好视频后，将其放在 workspace 的 yuv 文件夹中，并将文件路径和参数更新到 bitstream.cfg 文件中。</p>
<h2 id="HEVC编码"><a href="#HEVC编码" class="headerlink" title="HEVC编码"></a>HEVC编码</h2><p>完成5.1节中的操作后，回到 <code>Visual Stuidio</code>，按下 <code>Ctrl + F5</code> 开始执行。执行后会弹出一个命令行窗口，如图7所示。</p>
<p><img src="/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HM-HM_setup/2da8c8a546605e186a6576418f411534.png" alt="图 7 执行过程中的命令行窗口"></p>
<p>完成执行后，在 <code>workspace</code> 文件夹下会多出3个文件，分别为 <code>out.txt</code>，<code>rec.yuv</code>，<code>str.bin</code>。<code>out.txt</code> 文件是基本编码信息的输出文件，包含编码后的比特数、编码信息、编码时间等各种信息。<code>rec.yuv</code> 是编码过程中重建的YUV图像。<code>str.bin</code> 是压缩后的二进制码流文件。可以利用 Elecard HEVC Analyzer 软件进行查看，软件下载链接为：<a href="https://elecard-hevc-analyzer.software.informer.com/download/">https://elecard-hevc-analyzer.software.informer.com/download/</a>。</p>
<p>5.3 结果分析</p>
<p>使用Elecard HEVC Analyzer打开str.bin文件后，得到的结果如图8所示。左上角选择chart</p>
<p>bar可以查看每帧视频码流的分配情况。thumbnails可以查看视频的缩略图以及对应的编码索引和时间索引，左侧可以看到帧级别的统计信息，如色度、格式、分辨率、各类行帧所分配的比特比率等，并可以更换查看vps、sps等其他级别的信息，右侧可以查看cu级别的信息，包括块的位置、尺寸、预测方向等。</p>
<p><img src="/2022/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HM-HM_setup/d05c9ff383155befd58bed6e7c173d13.png" alt="图 8 Elecard HEVC Analyzer查看结果"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>HM</category>
      </categories>
      <tags>
        <tag>HM</tag>
        <tag>软件安装</tag>
      </tags>
  </entry>
  <entry>
    <title>OMNeT++ 基础知识：仿真过程和配置文件</title>
    <url>/2022/08/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9A%E4%BB%BF%E7%9C%9F%E8%BF%87%E7%A8%8B%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="仿真过程"><a href="#仿真过程" class="headerlink" title="仿真过程"></a>仿真过程</h2><p><code>OMNeT++</code> 的源代码通常包括以下文件：</p>
<ul>
<li>C++ 文件（<code>.h</code> 和 <code>.cc</code>）：包含简单模块的实现和其他代码；</li>
<li>消息文件（<code>.msg</code>）：包含要转换为 C++ 类的消息定义；</li>
<li>带有组件声明和拓扑描述的 NED 文件（<code>.ned</code>）；</li>
<li>具有模型参数分配和其他设置的配置文件（<code>.ini</code>）。</li>
</ul>
<span id="more"></span>
<p>简单地说，<code>OMNeT++</code> 将源代码转换为可执行文件的过程如下：</p>
<ol>
<li>使用消息编译器 <code>opp_msgc</code> 将 <code>.msg</code> 文件翻译为 C++ 文件；</li>
<li>将 C++ 文件编译为对象形式（<code>.o</code> 文件）；</li>
<li>目标文件与仿真内核和其他库连接以得到可执行文件或共享库</li>
</ol>
<p>需要注意的是，NED 文件与 <code>.ini</code> 文件是由仿真程序在运行时加载的。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>仿真的配置文件和输入数据通常放置在 <code>.ini</code> 文件中。</p>
<h3 id="配置文件语法"><a href="#配置文件语法" class="headerlink" title="配置文件语法"></a>配置文件语法</h3><p><code>OMNeT++</code> 配置文件是一个面向行的文本文件。编码主要是 ASCII，但在注释和字符串文字中允许使用非 ASCII 字符。</p>
<p>注释以 <code>#</code> 开头，程序也允许并在执行时忽略空行。可以通过尾随反斜杠的方式将很长的一行代码拆分为多行。即使在名称、数字或字符串常量的中间，这也允许换行。</p>
<p>配置文件中共有三种类型的行：节标题行、 键值行和指令行：</p>
<ul>
<li><p>节标题行是用方括号括起来的节名称。</p>
</li>
<li><p>键值行表现形式为 <code>&lt;key&gt;=&lt;value&gt;</code>；如果一行包含多个等号，则最左边的一个等号作为键值分隔符。</p>
</li>
<li><p>指令行以 <code>include</code> 开头，后跟要包含的文件的名称。</p>
</li>
</ul>
<p>键可以仅根据语法进一步分类：</p>
<ol>
<li>不包含点的键代表全局或每次都要运行的配置选项。</li>
<li>如果键包含一个点，则考虑其最后一个组件（最后一个点之后的子字符串）。如果最后一个组件包含连字符或等于 <code>typename</code>，则该键表示每个对象的配置选项。</li>
<li>否则，键代表<em>参数赋值</em>。因此，参数分配键包含一个点，并且在最后一个点之后没有连字符。</li>
</ol>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"># 注释行</span><br><span class="line">[General]                       # 节标题行</span><br><span class="line">network = Foo                   # 配置选项</span><br><span class="line">debug-on-errors = <span class="literal">false</span>         # 配置选项</span><br><span class="line"></span><br><span class="line">**.vector-recording = <span class="literal">false</span>     # 每个对象的配置选项</span><br><span class="line">**.app*.<span class="keyword">typename</span> = <span class="string">&quot;HttpClient&quot;</span> # 每个对象的配置选项</span><br><span class="line"></span><br><span class="line">**.app*.interval = <span class="number">3</span>s           # 参数值</span><br><span class="line">**.app*.requestURL = <span class="string">&quot;http://www.example.com/this-is-a-very-very-very-very\</span></span><br><span class="line"><span class="string">-very-long-url?q=123456789&quot;</span>     # 一个两行的参数值</span><br></pre></td></tr></table></figure>
<h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p><code>OMNeT++</code> 通过 <code>include</code> 关键词在配置文件中引入另一个 <code>.ini</code> 文件，使得大型 <code>.ini</code>  文件可以被划分为逻辑单元、固定单元和可变单元等。例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta"># omnetpp.ini</span></span><br><span class="line">...</span><br><span class="line">include params1.ini</span><br><span class="line">include params2.ini</span><br><span class="line">include ../common/config.ini</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="节标题"><a href="#节标题" class="headerlink" title="节标题"></a>节标题</h3><p>一个 <code>.ini</code> 文件可以包含一个 <code>[general]</code> 部分和多个 <code>[&lt;configname&gt;]</code> 或 <code>[Config &lt;configname&gt;]</code> 部分。也就是说，<code>[Foo]</code> 和 <code>[Config Foo]</code> 等价。各部分的顺序并不重要。</p>
<h3 id="分配模块参数"><a href="#分配模块参数" class="headerlink" title="分配模块参数"></a>分配模块参数</h3><p>模拟通过模块参数获取输入，这些参数可以在 NED 文件或 <code>omnetpp.ini</code> 中按顺序分配值。由于在 NED 文件中分配的参数不能在 <code>omnetpp.ini</code> 中被覆盖，因此可以将 NED 文件中的参数分配视为“硬编码”。相比之下，在 <code>omnetpp.ini</code> 中维护模块参数设置更容易、更灵活。</p>
<p>在<code>omnetpp.ini</code>中，模块参数由它们的完整路径（分层名称）引用。该名称由以点分隔的模块名称列表（从顶级模块到包含参数的模块）以及参数名称组成。</p>
<p>模型可以有大量的参数需要配置，在<code>omnetpp.ini</code>中一一设置会很繁琐。<code>OMNeT++</code> 支持通配符模式，允许一次设置多个模型参数。通配规则最明显的区别是<code>*</code>和<code>**</code>之间的区别。此外，表示字符范围时应该用大括号而不是方括号，因为方括号是为模块向量索引的表示法保留的。</p>
<p>模式语法：</p>
<ul>
<li><code>?</code>: 匹配除点 (.) 以外的任何字符</li>
<li><code>*</code> : 匹配零个或多个字符，除了点 (.)</li>
<li><code>**</code>：匹配零个或多个字符（任何字符）</li>
<li><code>&#123;af&#125;</code> : 集合: 匹配 af 范围内的字符</li>
<li><code>&#123;^af&#125;</code> :否定集: 匹配不在 af 范围内的字符</li>
<li><code>&#123;38..150&#125;</code>：数字范围：38..150 范围内的任何数字（即数字序列），包括在内；两个限制都是可选的</li>
<li><code>[38..150]</code>：索引范围：方括号中的任何数字，范围为 38..150，包括 38..150；两个限制都是可选的</li>
<li>反斜杠（\）：去掉后面字符的特殊含义</li>
</ul>
<p>使用通配符时，条目的顺序非常重要。当一个键匹配多个通配符模式时，将使用第一个匹配项，即需要先列出特定设置，然后再列出更一般的设置。示例如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[General] </span><br><span class="line">*.*.queue[<span class="number">3.</span><span class="number">.5</span>].bufSize = <span class="number">10</span> </span><br><span class="line">*.*.queue[<span class="number">12.</span>.].bufSize = <span class="number">18</span> </span><br><span class="line">*.*.queue[*].bufSize = <span class="number">6</span> # 这只会影响队列<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span> 和 <span class="number">6.</span><span class="number">.11</span></span><br></pre></td></tr></table></figure>
<p><code>*</code> 通配符用于匹配路径名中的单个模块或参数名称，而 <code>**</code> 可用于匹配路径中的多个组件。例如，<code>**.queue*.bufSize</code> 匹配模型中名称以 <code>queue</code> 开头的所有模块的 <code>bufSize</code> 参数，而 <code>*.queue*.bufSize</code> 或 <code>net.queue*.bufSize</code> 仅选择网络级别的队列。此外，<code>**.queue**.bufSize</code> 也会匹配如 <code>net.queue1.foo.bar.bufSize</code> 的参数。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>OMNeT++</category>
      </categories>
      <tags>
        <tag>OMNeT++</tag>
      </tags>
  </entry>
  <entry>
    <title>OMNeT++ 基础语法：NED 语言</title>
    <url>/2022/07/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9ANED%20%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>NED 语言用于定义网络模型的拓扑结构，通过对一组元件（信道、模型等）的描述刻画网络模型。对组件的描述可以在其他网络描述中进行复用。</p>
<p>包含网络描述的文件带有 <code>.ned</code> 后缀，在仿真过程中动态载入到模拟程序或使用 <code>NED</code> 编译器/ <code>C++</code> 代码连接到模拟器执行。</p>
<span id="more"></span>
<h2 id="NED-组件"><a href="#NED-组件" class="headerlink" title="NED 组件"></a>NED 组件</h2><p>一个 NED 描述包括了以下组件：</p>
<h3 id="NED-包"><a href="#NED-包" class="headerlink" title="NED 包"></a>NED 包</h3><p>NED 包的概念与 Java 包类似。当一个仿真运行时，必须告诉仿真内核包的根目录，即源文件夹。仿真内核会遍历整个目录树，然后载入每个目录下的 NED 文件。在目录下可以存在若干 NED 目录树，将它们的根目录（NED 源文件夹）给 NEDPATH 变量里的仿真内核。</p>
<p>NED 源树中的目录和包对应。如果在 <code>＜root＞/a/b/c</code> 目录下（<code>＜root＞</code> 在 <code>NEDPATH</code> 里被列出）有 NED 文件，那么包的名称就是 <code>a.b.c</code>。包名称必须在 NED 文件的顶部进行声明，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package a.b.c;</span><br></pre></td></tr></table></figure>
<p>目录名后面的包名称必须和已声明的包相符，如果不相符就会出错。</p>
<p>包并不一定强制使用。如果所有的 NED 文件在 NEDPATH 的一个单独目录下时，包声明就可以忽略，因为这些文件被认为放在默认包里。</p>
<h3 id="输入指示"><a href="#输入指示" class="headerlink" title="输入指示"></a>输入指示</h3><p>输入指示用于引入其他网络描述文件。当引入其他网络描述后，可以使用该网络描述中包含的模块、信道等组件。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import inet.applications.contract.IApp;</span><br></pre></td></tr></table></figure>
<h3 id="信道定义"><a href="#信道定义" class="headerlink" title="信道定义"></a>信道定义</h3><p>信道定义用来说明一个连接类型的特征。<code>OMNeT++</code> 有 3 种最基本的信道类型，分别是 <code>IdealChannel</code>、<code>DelayChannel</code> 和 <code>DatarateChannel</code>。其中的参数都是可选择的，且出现的先后顺序没有影响。</p>
<h4 id="ned-IdealChannel"><a href="#ned-IdealChannel" class="headerlink" title="ned.IdealChannel"></a><code>ned.IdealChannel</code></h4><p><code>ned.IdealChannel</code> 是理想信道，不含参数，将无时延、无失真地传输信息。</p>
<h4 id="ned-DelayChannel"><a href="#ned-DelayChannel" class="headerlink" title="ned.DelayChannel"></a><code>ned.DelayChannel</code></h4><p><code>ned.DelayChannel</code> 包含 2 个参数，分别是：</p>
<ul>
<li><code>delay</code>：每仿真秒的传输时延，单位为 <code>s/ms/us</code>；</li>
<li><code>disabled</code>：默认值为 <code>false</code>。当值为 <code>true</code> 时信道丢弃所有的信息。</li>
</ul>
<h4 id="ned-DatarateChannel"><a href="#ned-DatarateChannel" class="headerlink" title="ned.DatarateChannel"></a><code>ned.DatarateChannel</code></h4><p><code>ned.DatarateChannel</code> 包含 3 个参数，分别是：</p>
<ul>
<li><code>delay</code>：每仿真秒的传输时延；</li>
<li><code>datarate</code>：信道带宽；</li>
<li><code>ber</code> 或 <code>per</code>：比特错误率 <code>ber</code> 或包错误率 <code>per</code>。</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">channel Channel extends ned.DelayChannel &#123;</span><br><span class="line">            delay = 100ms;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块定义"><a href="#模块定义" class="headerlink" title="模块定义"></a>模块定义</h3><h4 id="简单模块"><a href="#简单模块" class="headerlink" title="简单模块"></a>简单模块</h4><p>简单模块是复合模块的基本构建成分，通过对其参数和门进行申明来定义。其语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">simple SimpleModuleName &#123;</span><br><span class="line">	parameters:</span><br><span class="line">		//...</span><br><span class="line">	gates:</span><br><span class="line">		//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复合模块"><a href="#复合模块" class="headerlink" title="复合模块"></a>复合模块</h4><p>复合模块由一个或多个子模块组成。不管是简单模块还是复合模块都可以当作子模块。在简单模块能使用的任何地方都可以使用复合模块。复合模块相较简单模块多出了子模块和链接两部分。其语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module CompoundModule &#123;</span><br><span class="line">	parameters:</span><br><span class="line">		//...</span><br><span class="line">	gates:</span><br><span class="line">		//...</span><br><span class="line">	submodules:</span><br><span class="line">		//...</span><br><span class="line">	connections:</span><br><span class="line">		//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，参数、门、子模块、链接都是可选项。</p>
<h4 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h4><p>模块声明仅仅定义了模块类型，要得到仿真软件可以运行的模块，需要编写网络模块。网络模块将前面定义的模块类型声明为一个仿真模块实例，且在 NED 文件中可以存在多个网络定义仿真程序。网络模块的定义语法规则如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network wirelessLan : WirelessLAN &#123;</span><br><span class="line">	parameters:</span><br><span class="line">		//...</span><br><span class="line">	types:</span><br><span class="line">		//...</span><br><span class="line">	submodules:</span><br><span class="line">		//...</span><br><span class="line">	connections:</span><br><span class="line">		//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="模块之间的关系"><a href="#模块之间的关系" class="headerlink" title="模块之间的关系"></a>模块之间的关系</h4><p><img src="/2022/07/29/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9ANED%20%E8%AF%AD%E8%A8%80/image-20220729233559636.png" alt="模块之间的关系"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>OMNeT++</category>
      </categories>
      <tags>
        <tag>OMNeT++</tag>
      </tags>
  </entry>
  <entry>
    <title>OMNeT++ 基础语法：模块参数、门和连接的访问</title>
    <url>/2022/08/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8F%82%E6%95%B0%E3%80%81%E9%97%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="消息参数的访问"><a href="#消息参数的访问" class="headerlink" title="消息参数的访问"></a>消息参数的访问</h2><p>在 <code>NED</code> 文件中申明的模块参数在运行时用 <code>cPar</code> 类表示。在调用 <code>cComponent</code> 中的成员函数 <code>par()</code> 可以访问模块指针，如：</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cPar&amp; delayPar = <span class="built_in">par</span>(<span class="string">&quot;delay&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>其中，<code>cPar</code> 类是一个存储值的对象。可以使用与参数的 <code>NED</code> 类型对应的方法读取<code>cPar</code> 的值： <code>boolValue()</code>、<code>intValue()</code>、 <code>doubleValue()</code>、<code>stringValue()</code>、<code>stdstringValue()</code>、 <code>xmlValue()</code>，例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> numJobs = <span class="built_in">par</span>(<span class="string">&quot;numJobs&quot;</span>).<span class="built_in">intValue</span>();</span><br><span class="line"><span class="keyword">double</span> processingDelay = <span class="built_in">par</span>(<span class="string">&quot;processingDelay&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>cPar</code> 有两种返回字符串值的方法： <code>stringValue()</code>：返回<code>const char *</code>，和 <code>stdstringValue()</code>：返回<code>std::string</code>。对于时常改变的参数，只能使用<code>stdstringValue()</code>。</p>
<p>如果在表达式中使用 <code>par(&quot;foo&quot;)</code> 参数（例如 <code>4*par(&quot;foo&quot;)+2</code>），C++ 编译器可能无法在重载运算符之间做出决定并报告歧义。可以通过添加显式转换（例如 <code>(double)par(&quot;foo&quot;) ）</code>、使用 <code>doubleValue()</code> 或 <code>intValue()</code> 方法来解决此问题。</p>
<p>对于需要随时间动态读取常数的值时，可以使用表示随机数据包生成间隔参数的函数或者将参数对象的指针存储到类变量中，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Source::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>() + <span class="built_in">par</span>(<span class="string">&quot;interval&quot;</span>).<span class="built_in">doubleValue</span>(), timerMsg);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Source</span> :</span> <span class="keyword">public</span> cSimpleModule</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    cPar *intervalp;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(cMessage *msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Source::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    intervalp = &amp;<span class="built_in">par</span>(<span class="string">&quot;interval&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Source::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>() + intervalp-&gt;<span class="built_in">doubleValue</span>(), timerMsg);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，参数的类型不能在运行时改变，必须保持在 NED 文件中声明的类型。也不能在运行时添加或删除模块参数。设置参数值的方法有 <code>setBoolValue()</code>、 <code>setLongValue()</code>、<code>setStringValue()</code>、 <code>setDoubleValue()</code>、<code>setXMLValue()</code> 等。</p>
<h2 id="门的访问"><a href="#门的访问" class="headerlink" title="门的访问"></a>门的访问</h2><p>门模块由 <code>cGate</code> 对象表示，该对象知道其连接到那些门，也知道与其关联的连接对象。</p>
<h3 id="按名称访问"><a href="#按名称访问" class="headerlink" title="按名称访问"></a>按名称访问</h3><p>对于输入输出门，可以使用 <code>gate()</code> 函数按名称查找门，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cGate *outGate = <span class="built_in">gate</span>(<span class="string">&quot;out&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>当我们不能确定一个门是否存在时，可以使用 <code>hasGate()</code> 函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">hasGate</span>(<span class="string">&quot;optOut&quot;</span>))</span><br><span class="line">   <span class="built_in">send</span>(<span class="keyword">new</span> <span class="built_in">cMessage</span>(), <span class="string">&quot;optOut&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>此外，也可以通过门的数字 ID 来识别和查找门。可以从门本身或通过门名称获取 ID：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> gateId = <span class="built_in">gate</span>(<span class="string">&quot;in&quot;</span>)-&gt;<span class="built_in">getId</span>();</span><br><span class="line"><span class="keyword">int</span> gateId = <span class="built_in">findGate</span>(<span class="string">&quot;in&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="门向量"><a href="#门向量" class="headerlink" title="门向量"></a>门向量</h3><p>门向量每个元素拥有一个 <code>cGate</code> 对象。要访问向量中的各个门，需要使用附加索引参数调用 <code>gate()</code> 函数。可以使用<code>gateSize()</code> 方法读取门向量的大小，如果门向量存在并且索引在界限内，<code>gate()</code> 永远不会返回 <code>nullptr</code> 或抛出错误。</p>
<p>遍历一个门向量中的所有元素可以通过以下方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">gateSize</span>(<span class="string">&quot;out&quot;</span>); i++) &#123;</span><br><span class="line">     cGate *gate = <span class="built_in">gate</span>(<span class="string">&quot;out&quot;</span>, i); </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于添加和删除门的 <code>cModule</code> 方法是 <code>addGate(name, type, isvector=false)</code> 和 <code>deleteGate(name)</code>。可以使用 <code>setGateSize(name,size)</code> 更改门矢量大小。</p>
<h3 id="门-ID"><a href="#门-ID" class="headerlink" title="门 ID"></a>门 ID</h3><p>通过门 ID 也可以访问到对应的门。门 ID 在门向量中是连续的，也就是说，门 <code>g[k]</code> 的 ID 可以计算为 <code>g[0]</code> 的 ID 加上 <em>k</em>。这使得通过 ID 检索门比通过名称和索引更有效。第一个门的索引可以使用 <code>gate(&quot;out&quot;,0)-&gt;getId()</code> 获得，但最好使用专用方法<code>gateBaseId()</code>，因为它在门向量大小为零时也有效。使用门 ID 遍历门向量的示例如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> baseId = <span class="built_in">gateBaseId</span>(<span class="string">&quot;out&quot;</span>); </span><br><span class="line"><span class="keyword">int</span> size = <span class="built_in">gateSize</span>(<span class="string">&quot;out&quot;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; cGate *gate = <span class="built_in">gate</span>(baseId + i); </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>门 ID 有两个重要的特性是稳定和模块内唯一。稳定是指门的 ID 永远不会改变；唯一性不仅意味着在任何给定时间没有两个门具有相同的 ID，而且删除的门的 ID 以后不会被重用，因此门 ID 在模拟运行的生命周期中是唯一的。</p>
<h3 id="cGate-方法"><a href="#cGate-方法" class="headerlink" title="cGate 方法"></a><code>cGate</code> 方法</h3><p><code>cGate</code> 的 <code>getName()</code> 方法返回不带索引的门或门向量的名称。<code>getFullName()</code> 返回一个包含门索引的字符串；<code>getType()</code> 方法返回门类型，值为 <code>cGate::INPUT</code> 或 <code>cGate::OUTPUT</code>。<code>getId()</code> 方法返回门 ID。<code>getOwnerModule()</code> 方法返回门对象所属的模块。此外，还有 <code>isVector ()</code>、<code>getIndex()</code>、<code>getVectorSize()</code> 等方法。</p>
<h2 id="连接的访问"><a href="#连接的访问" class="headerlink" title="连接的访问"></a>连接的访问</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>简单的模块门通常通过一个连接通信。然而，复合模块门需要在模块的内部和外部都连接起来才能使用。一系列连接（与复合模块门连接）称为连接路径或路径。一条路径是有向的，它通常从一个简单模块的输出门开始，到一个简单模块的输入门结束，然后经过几个复合模块门。</p>
<p>每个 <code>cGate</code> 对象都包含指向路径中上一个门和下一个门的指针（由 <code>getPreviousGate()</code> 和 <code>getNextGate()</code> 方法返回），因此可以将路径视为双链表。</p>
<p><img src="/2022/08/01/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A%E6%A8%A1%E5%9D%97%E5%8F%82%E6%95%B0%E3%80%81%E9%97%A8%E5%92%8C%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%AE%BF%E9%97%AE/image-20220801173040667.png" alt="门类型"></p>
<p>可以使用 <code>getPathStartGate()</code>  和 <code>getPathEndGate()</code> 方法找到路径的开始门和结束门，它们一直访问前一个门或后一个门指针直到 <code>nullptr</code>。</p>
<p><code>isConnectedOutside()</code> 和 <code>isConnectedInside()</code> 方法返回门是连接在外部还是内部。他们根据门的类型（输入或输出）检查前一个或后一个指针。例如，如果后一个指针为非 <code>nullptr</code>，则输出门连接到外部；输入门以相同方式检查前一个指针。</p>
<p><code>isConnected()</code>方法有点不同：如果门是<em>全</em>连接的，则返回 true ，也就是说，对于内部和外部的复合模块门，以及对于外部的简单模块门。</p>
<h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>与连接相关联的信道对象可以通过存储在连接源节点的门的指针访问。指针由门的 <code>getChannel()</code> 函数返回：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cChannel *channel = gate-&gt;<span class="built_in">getChannel</span>();</span><br></pre></td></tr></table></figure>
<p>当没有关联的信道对象时，结果返回 <code>nullptr</code>。</p>
<p>当具有一个信道指针时，可以通过 <code>getSourceGate()</code> 函数获得源门：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cGate *gate = channel-&gt;<span class="built_in">getSourceGate</span>();</span><br></pre></td></tr></table></figure>
<p>信道示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> cDatarateChannel ::<span class="built_in">processMessage</span>( cMessage *msg, <span class="keyword">simtime_t</span> t, <span class="keyword">result_t</span>&amp; result) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 如果通道被禁用，则表示应该删除消息</span></span><br><span class="line">    <span class="keyword">if</span> (isDisabled) &#123; </span><br><span class="line">        result.discard = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据速率建模</span></span><br><span class="line">    <span class="keyword">if</span> (datarate!=<span class="number">0</span> &amp;&amp; msg-&gt;<span class="built_in">isPacket</span>()) &#123; </span><br><span class="line">        <span class="keyword">simtime_t</span> duration = ((cPacket *)msg)-&gt;<span class="built_in">getBitLength</span>() / datarate;</span><br><span class="line">        result.duration = duration;</span><br><span class="line">        txfinishtime = t + duration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        txfinishtime = t; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传播延迟建模</span></span><br><span class="line">    result.delay = delay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 误码建模</span></span><br><span class="line">    <span class="keyword">if</span> ((ber!=<span class="number">0</span> || per!=<span class="number">0</span>) &amp;&amp; msg-&gt;<span class="built_in">isPacket</span>()) &#123; cPacket *pkt = ( cPacket *)msg; </span><br><span class="line">        <span class="keyword">if</span> (ber!=<span class="number">0</span> &amp;&amp; <span class="built_in">dblrand</span>() &lt; <span class="number">1.0</span> - <span class="built_in">pow</span>(<span class="number">1.0</span>-ber, (<span class="keyword">double</span>)pkt-&gt;<span class="built_in">getBitLength</span>()) </span><br><span class="line">            pkt-&gt;<span class="built_in">setBitError</span>(<span class="literal">true</span>); </span><br><span class="line">        <span class="keyword">if</span> (per!=<span class="number">0</span> &amp;&amp; <span class="built_in">dblrand</span>() &lt; per) </span><br><span class="line">            pkt-&gt;<span class="built_in">setBitError</span>(<span class="literal">true</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>OMNeT++</category>
      </categories>
      <tags>
        <tag>OMNeT++</tag>
      </tags>
  </entry>
  <entry>
    <title>OMNeT++ 基础语法：仿真概念和简单模块</title>
    <url>/2022/07/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="仿真概念"><a href="#仿真概念" class="headerlink" title="仿真概念"></a>仿真概念</h2><h3 id="OMNeT-中的离散事件"><a href="#OMNeT-中的离散事件" class="headerlink" title="OMNeT++ 中的离散事件"></a><code>OMNeT++</code> 中的离散事件</h3><p>一个离散时间系统是指一个系统的状态改变方式是离散的。简而言之，系统状态的修改仅在事件发生时进行。离散时间系统可以使用离散事件模拟进行仿真。以计算机网络为例，计算机网络通常被看做是离散时间系统，他的一些离散事件包括了：</p>
<ul>
<li>数据包传输的开始</li>
<li>数据包传输的结束</li>
<li>重传超时到期</li>
</ul>
<span id="more"></span>
<p>这意味着在数据包传输开始和数据包传输结束等两个事件之间，数据包的状态仍然是正在传输。其中，事件发生的时间通常被称作<strong>事件时间戳</strong>，在 <code>OMNeT++</code> 中称为<strong>到达时间</strong>。模拟程序运行的时间称作模拟时间或虚拟时间。相对地，<code>CPU</code> 被消耗的时间称作真实时间或 <code>CPU</code> 时间。</p>
<h3 id="事件和事件执行顺序"><a href="#事件和事件执行顺序" class="headerlink" title="事件和事件执行顺序"></a>事件和事件执行顺序</h3><p><code>OMNeT++</code> 使用消息描述事件，每一个事件都通过一个 <code>cMessage</code> 类或其子类的实例来表示，从源模块发送到另一个目的模块，在这个过程中，事件将要发生的地方就是消息的目的模块，事件发生的模拟时间就是消息到达时间。此外，源模块也可以给自己发送一个消息。</p>
<p>事件按照到达时间顺序从 FES 中消耗以保持因果关系。举例说明，对给定的两条消息：</p>
<ol>
<li>到达时间较早的消息先被执行</li>
<li>若到达时间相等，受限制性具有较高调度优先级（较小数值）的消息</li>
<li>如果优先级相同，则较早发送/计划的消息先被执行</li>
</ol>
<p>其中，调度优先级是用户分配的整型消息属性。<code>OMNeT++</code> 的模拟时间存储在 <code>SimTime</code> 类型的变量 <code>simtime_t</code> 中。<code>SimTime</code> 类以 64 位整数存储仿真时间，且不存在从 <code>SimTime</code> 到 <code>double</code> 类型的隐式类型转换。如果需要进行转换，可以使用 <code>dbl()</code> 函数或者 <code>SIMTIME_DBL()</code> 宏。</p>
<p><code>SimTime</code> 的其他有用方法包括 <code>str()</code>，将值作为字符串返回；<code>parse()</code>，将字符串转换为 <code>SimTime</code>；<code>raw()</code>，返回底层的 64 位整数；<code>getScaleExp()</code>，返回全局比例指数；<code>isZero()</code>，测试模拟时间是否为0；<code>getMaxTime()</code>，返回可以以当前比例指数表示的最大模拟时间。零和最大仿真时间也可以通过 <code>SIMTIME_ZERO</code> 和 <code>SIMTIME_MAX</code> 宏访问。</p>
<h3 id="FES"><a href="#FES" class="headerlink" title="FES"></a>FES</h3><p>FES(Future Event Set) 的实现是离散事件模拟器性能的关键因素。在 <code>OMNeT++</code> 中，FES 是可替换的，默认的 FES 实现使用二进制堆作为数据结构。二进制堆通常被认为是离散事件模拟的最佳 FES 算法，因为它为大多数工作负载提供了良好、平衡的性能。</p>
<h2 id="包传输模型"><a href="#包传输模型" class="headerlink" title="包传输模型"></a>包传输模型</h2><h3 id="时延、比特误差率、数据速率"><a href="#时延、比特误差率、数据速率" class="headerlink" title="时延、比特误差率、数据速率"></a>时延、比特误差率、数据速率</h3><p>传播延迟是消息通过信道到达目的地的时间段，以秒为单位计算；比特误差率对消息的传播有影响，是一个比特被错误传播的几率；数据速率的单位为 <code>bit/second</code></p>
<h3 id="消息的发送时间"><a href="#消息的发送时间" class="headerlink" title="消息的发送时间"></a>消息的发送时间</h3><p>消息的发送时间与传输的第一个比特和接收的最后一个比特相关，如下图所示。</p>
<p><img src="/2022/07/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9D%97/image-20220731110859230.png" alt="消息的发送时间" style="zoom: 67%;"></p>
<p>上述模型不能模拟所有的协议。在 <code>Token Ring</code> 和 <code>FDDI</code> 协议中，如果一条消息沿途经过一系列的信道和模块，每个模块都将等待消息的最后一个比特到达后再开始发送。</p>
<h2 id="简单模块的定义"><a href="#简单模块的定义" class="headerlink" title="简单模块的定义"></a>简单模块的定义</h2><p>（1）直接定义一个 <code>CSimpleModule</code> 的子类；</p>
<p>（2）使用 <code>define_Module()</code> 或 <code>define_Module_Like()</code> 宏进行注册。其作用是声明一个 <code>simple module</code> 类型并且建立与对应 <code>NED</code> 文件的关联性。类名与 <code>NED</code> 定义的 <code>SimpleModule</code> 名相同时使用 <code>define_Module()</code>；当需要为一个 <code>NED</code> 描述的 <code>SimpleModule</code> 提供不同的实现时使用 <code>define_Module_Line()</code></p>
<p>（3）实现模块类的例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: HelloModule.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omnetpp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> omnetpp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloModule</span> :</span> <span class="keyword">public</span> cSimpleModule</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(cMessage *msg)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// register module class with OMNeT++</span></span><br><span class="line"><span class="built_in">Define_Module</span>(HelloModule);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloModule::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EV &lt;&lt; <span class="string">&quot;Hello World!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloModule::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> msg; <span class="comment">// just discard everything we receive</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相关的 NED 文件</span></span><br><span class="line"><span class="comment">// file: HelloModule.ned</span></span><br><span class="line">simple HelloModule</span><br><span class="line">&#123;</span><br><span class="line">    gates:</span><br><span class="line">        input in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）建立构造函数</p>
<p>使用宏 <code>Module_Class_Members(classname, baseclass, stacksize);</code> 。若使用 <code>activity()</code> 函数，则模块以协同模式执行，在内存中划分出一个独立的栈空间。如果栈空间为 0，则需要使用 <code>handleMessage()</code>。当初始化过程需要有变量参与时，就需要自己重写构造函数。</p>
<h2 id="简单模块中的主要成员函数"><a href="#简单模块中的主要成员函数" class="headerlink" title="简单模块中的主要成员函数"></a>简单模块中的主要成员函数</h2><h3 id="activity"><a href="#activity" class="headerlink" title="activity()"></a><code>activity()</code></h3><p><code>activity()</code> 可以使用户像编写一个进程一样编写简单模块、等待消息、延缓执行时间等。拥有这个函数的简单模块作为一系列协同程序协同进行，因此又被称为协同多任务。用户可以手动设置模块栈空间（一般为 <code>16K</code>）。如果模块存在递归或本地变量占用空间较大的时候，可以使用更大的栈空间。</p>
<h3 id="handleMessage"><a href="#handleMessage" class="headerlink" title="handleMessage()"></a><code>handleMessage()</code></h3><p>每当模块接收到消息时，系统都会以消息作为参数调用 <code>handleMessage()</code> 函数。需要注意的特点：</p>
<ul>
<li>每个 <code>message/event</code> 对 <code>handleMessage()</code> 进行调用</li>
<li>需要在 <code>initialize()</code> 函数中初始化变量，且无法调用如 <code>wait()</code>、<code>receive()</code> 等一些基于协同的函数</li>
<li><code>SimpleModule</code> 的 <code>stacksize</code> 一定要设置为 0</li>
</ul>
<p><code>handleMessage()</code> 函数在事件处理过程中被调用。对每一个简单模块而言，用户都需要重新定义该函数。在该函数中，可以使用一些消息相关的函数如发送信息 <code>send()</code>、自发信息 <code>scheduleAt()</code>、删除自发信息 <code>cancelEvent()</code> 等。</p>
<h3 id="Initialize"><a href="#Initialize" class="headerlink" title="Initialize()"></a><code>Initialize()</code></h3><p><code>Initialize()</code> 函数在初始化消息被放入 FES（Future Event Set）后和初始化消息被执行前被调用以初始化成员变量。复合模块的初始化优先于其子模块。</p>
<h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish()"></a><code>Finish()</code></h3><p>循环结束（FES 没有模拟事件时）后程序正常终止时被调用，模块的调用顺序与 <code>Initialize()</code> 相反。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>OMNeT++</category>
      </categories>
      <tags>
        <tag>OMNeT++</tag>
      </tags>
  </entry>
  <entry>
    <title>OMNeT++ tictoc 示例</title>
    <url>/2022/08/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E6%95%B2%E9%97%A8%E7%A0%96%EF%BC%9Atictoc%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    <code>tictoc</code> 是 <code>OMNeT++</code> 官方给出的入门示例。示例模拟了一个 2 结点网络，数据包在这两个节点之间（<code>tic</code> 结点和 <code>toc</code> 结点之间来回传输。<code>tictoc</code> 示例下总共有 18 个小实验。</p>
<span id="more"></span>
<h2 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h2><p>以 <code>tictoc 1</code> 为例。首先，需要激活 <code>omnet</code> 环境。通过在 <code>omnetpp-5.6.1/</code> 目录下使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. setenv</span><br></pre></td></tr></table></figure>
<p>随后，输入命令进入 <code>tictoc</code> 示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> sample/tictoc/</span><br></pre></td></tr></table></figure>
<p>进入之后，需要创建 <code>tictoc1.ned</code>、<code>txc1.cc</code>和 <code>omnetpp.ini</code> 文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tictoc1.ned</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义节点 Txc1</span></span><br><span class="line">simple Txc1</span><br><span class="line">&#123;</span><br><span class="line">    gates:</span><br><span class="line">        input in;</span><br><span class="line">        output out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义网络 Tictoc1</span></span><br><span class="line">network Tictoc1</span><br><span class="line">&#123;</span><br><span class="line">    submodules:</span><br><span class="line">        tic: Txc1;</span><br><span class="line">        toc: Txc1;</span><br><span class="line">    connections:</span><br><span class="line">        tic.out --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; toc.in;</span><br><span class="line">        tic.in &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- toc.out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// txc1.cc</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omnetpp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> omnetpp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Derive the Txc1 class from cSimpleModule. In the Tictoc1 network,</span></span><br><span class="line"><span class="comment"> * both the `tic&#x27; and `toc&#x27; modules are Txc1 objects, created by OMNeT++</span></span><br><span class="line"><span class="comment"> * at the beginning of the simulation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Txc1</span> :</span> <span class="keyword">public</span> cSimpleModule</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// The following redefined virtual function holds the algorithm.</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(cMessage *msg)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The module class needs to be registered with OMNeT++</span></span><br><span class="line"><span class="built_in">Define_Module</span>(Txc1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Txc1::initialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize is called at the beginning of the simulation.</span></span><br><span class="line">    <span class="comment">// To bootstrap the tic-toc-tic-toc process, one of the modules needs</span></span><br><span class="line">    <span class="comment">// to send the first message. Let this be `tic&#x27;.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Am I Tic or Toc?</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;tic&quot;</span>, <span class="built_in">getName</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// create and send first message on gate &quot;out&quot;. &quot;tictocMsg&quot; is an</span></span><br><span class="line">        <span class="comment">// arbitrary string which will be the name of the message object.</span></span><br><span class="line">        cMessage *msg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Txc1::handleMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>); <span class="comment">// send out the message</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># omnetpp.ini</span></span><br><span class="line">[General]</span><br><span class="line">network = Tictoc1</span><br></pre></td></tr></table></figure>
<p>创建好需要的文件后，先输入命令创建 <code>Makefile</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opp_makemake</span><br></pre></td></tr></table></figure>
<p>接下来，再输入 <code>make</code> 命令产生可执行文件 <code>tictoc</code>。最后开始仿真：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./tictoc -u Cmdenv</span><br></pre></td></tr></table></figure>
<p>得到的结果如下图所示：</p>
<p><img src="/2022/08/06/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E6%95%B2%E9%97%A8%E7%A0%96%EF%BC%9Atictoc%E7%A4%BA%E4%BE%8B/image-20220804122925352.png" alt="tictoc1" style="zoom:67%;"></p>
<p>此时表示仿真已经正常运行。</p>
<h2 id="示例笔记"><a href="#示例笔记" class="headerlink" title="示例笔记"></a>示例笔记</h2><h3 id="tictoc-1"><a href="#tictoc-1" class="headerlink" title="tictoc 1"></a><code>tictoc 1</code></h3><p>展示了网络、信道和结点的实例化方式以及两个结点相互通信的方式，具体方式如实验步骤章节所示。</p>
<h3 id="tictoc-2"><a href="#tictoc-2" class="headerlink" title="tictoc 2"></a><code>tictoc 2</code></h3><p>展示新命令：<code>EV</code>，相当于 <code>C++</code> 中的 <code>cout</code> 命令。<strong>但该命令在命令行仿真环境中无法实现预期功能。</strong></p>
<p>使用了 <code>@display</code> 命令对图形化窗口进行美化，但在命令行中没有太大意义。</p>
<h3 id="tictoc-3"><a href="#tictoc-3" class="headerlink" title="tictoc 3"></a><code>tictoc 3</code></h3><p>展示命令 <code>watch</code>，可以在图形化窗口中看到实时值，但在命令行中没有太大意义。</p>
<p>展示了一种停止仿真的方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> msg;</span><br></pre></td></tr></table></figure>
<h3 id="tictoc-4"><a href="#tictoc-4" class="headerlink" title="tictoc 4"></a><code>tictoc 4</code></h3><p>展示从 NED 文件中读取参数的方式：<code>par()</code>。例如 <code>par(&quot;sendMsgOnInit&quot;).boolValue()</code> 就是读取这个布尔型参数的值。</p>
<p>给参数赋初值可以在 NED 文件中完成，也可以在 <code>omnetpp.ini</code> 文件中完成。以给 <code>limit</code> 参数赋初值为例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// omnetpp.ini</span></span><br><span class="line">[Config Tictoc4]</span><br><span class="line">network = Tictoc4</span><br><span class="line">Tictoc4.toc.limit = <span class="number">5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tictoc4.ned</span></span><br><span class="line">simple Txc4</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        <span class="keyword">bool</span> sendMsgOnInit = <span class="built_in"><span class="keyword">default</span></span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">int</span> limit = <span class="built_in"><span class="keyword">default</span></span>(<span class="number">2</span>);</span><br><span class="line">    gates:</span><br><span class="line">        input in;</span><br><span class="line">        output out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tictoc-5"><a href="#tictoc-5" class="headerlink" title="tictoc 5"></a><code>tictoc 5</code></h3><p>在 <code>tictoc 4</code> 的基础上将 <code>tic</code> 和 <code>toc</code> 分为两个不同的对象。</p>
<h3 id="tictoc-6"><a href="#tictoc-6" class="headerlink" title="tictoc 6"></a><code>tictoc 6</code></h3><p>展示了利用 <code>scheduleAt()</code> 函数实现的定时功能，初始5秒后开始发送，之后每次接收到间隔1秒自发送：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// txc6.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Txc6::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    event = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;event&quot;</span>);</span><br><span class="line">    tictocMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;tic&quot;</span>, <span class="built_in">getName</span>()) == <span class="number">0</span>) &#123;</span><br><span class="line">        tictocMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="number">5.0</span>, event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Txc6::handleMessage</span><span class="params">(cMessage *msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg == event) &#123;</span><br><span class="line">        <span class="built_in">send</span>(tictocMsg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">        tictocMsg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tictocMsg = msg;</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+<span class="number">1.0</span>, event);	<span class="comment">// simTime() 为当前仿真时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tictoc-7"><a href="#tictoc-7" class="headerlink" title="tictoc 7"></a><code>tictoc 7</code></h3><p>在 <code>tictoc7.ned</code> 文件内新增语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">double</span> delayTime @<span class="built_in">unit</span>(s);</span><br></pre></td></tr></table></figure>
<p>定义了 <code>delayTime</code>，并且指明了单位为秒。此外，在 <code>omnetpp.ini</code> 文件中对 <code>tic</code> 和 <code>toc</code> 的值进行了初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[Config Tictoc7]</span><br><span class="line">network = Tictoc7</span><br><span class="line">Tictoc7.tic.delayTime = <span class="built_in">exponential</span>(<span class="number">3</span>s)</span><br><span class="line">Tictoc7.toc.delayTime = <span class="built_in">truncnormal</span>(<span class="number">3</span>s,<span class="number">1</span>s)</span><br></pre></td></tr></table></figure>
<p>其中的时延都是随机值，第一个是均值为3s，第二个是正态分布。</p>
<p>该示例中还展示了概率丢包的设计方式，即在 <code>txc7.cc</code> 文件中的 <code>handleMessage(cMessage *msg)</code> 中设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">1</span>) &lt; <span class="number">0.1</span>) &#123;</span><br><span class="line">            EV &lt;&lt; <span class="string">&quot;\&quot;Losing\&quot; message\n&quot;</span>;</span><br><span class="line">            <span class="keyword">delete</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">simtime_t</span> delay = <span class="built_in">par</span>(<span class="string">&quot;delayTime&quot;</span>);</span><br><span class="line">            tictocMsg = msg;</span><br><span class="line">            <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+delay, event);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>整个过程就是，首先延迟5秒发，收到后延迟随机时间回发，再收到后延迟随机时间发，并且期间还有一定概率数据丢失。</p>
<h3 id="tictoc-8"><a href="#tictoc-8" class="headerlink" title="tictoc 8"></a><code>tictoc 8</code></h3><p>首先该示例将 <code>tic</code> 和 <code>toc</code> 定义成了两个类，使得这两个模块可以实现不同的功能或者不同的输入输出。</p>
<p>此外，该示例展示了丢包重传的方式，即在 <code>txc8.cc</code> 文件中使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg == timeoutEvent) &#123;</span><br><span class="line">        EV &lt;&lt; <span class="string">&quot;Timeout expired, resending message and restarting timer\n&quot;</span>;</span><br><span class="line">        cMessage *newMsg = <span class="keyword">new</span> <span class="built_in">cMessage</span>(<span class="string">&quot;tictocMsg&quot;</span>);</span><br><span class="line">        <span class="built_in">send</span>(newMsg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+timeout, timeoutEvent);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>整体流程为 <code>tic</code> 先发出信息，并且等待1秒钟。如果1秒钟后收到了表示超时的自信息，则新建一个消息再发送一次。如果一秒内收到了非自信息，就说明成功发送，此时取消定时并且新建一个信息发送过去。<code>toc</code> 有0.1的概率丢失信息。</p>
<h3 id="tictoc-9"><a href="#tictoc-9" class="headerlink" title="tictoc 9"></a><code>tictoc 9</code></h3><p>对示例 8 的优化，即重传的时候传送消息的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg == timeoutEvent) &#123;</span><br><span class="line">    <span class="built_in">sendCopyOf</span>(message);</span><br><span class="line">    <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+timeout, timeoutEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tictoc-10"><a href="#tictoc-10" class="headerlink" title="tictoc 10"></a><code>tictoc 10</code></h3><p>展示了每个模块具有多个输入输出时的操作方式，即在 NED 文件中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">simple Txc10</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        input in[];  <span class="comment">// declare in[] and out[] to be vector gates</span></span><br><span class="line">        output out[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network Tictoc10</span><br><span class="line">&#123;</span><br><span class="line">    submodules:</span><br><span class="line">        tic[<span class="number">6</span>]: Txc10;</span><br><span class="line">    connections:</span><br><span class="line">        tic[<span class="number">0</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">1</span>].in++;</span><br><span class="line">        tic[<span class="number">0</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">1</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">1</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">2</span>].in++;</span><br><span class="line">        tic[<span class="number">1</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">2</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">1</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">4</span>].in++;</span><br><span class="line">        tic[<span class="number">1</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">4</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">3</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">4</span>].in++;</span><br><span class="line">        tic[<span class="number">3</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">4</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">4</span>].out++ --&gt; &#123;  delay = <span class="number">100</span>ms; &#125; --&gt; tic[<span class="number">5</span>].in++;</span><br><span class="line">        tic[<span class="number">4</span>].in++ &lt;-- &#123;  delay = <span class="number">100</span>ms; &#125; &lt;-- tic[<span class="number">5</span>].out++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>in</code> 和 <code>out</code> 后面的 ++ 是因为目前不知道要用多少个 <code>in</code> 和 <code>out</code>，就让他们每次执行完自加 1。</p>
<p><code>txc10.cc</code> 中随机选择输出口进行输出的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Txc10::forwardMessage</span><span class="params">(cMessage *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// In this example, we just pick a random gate to send it on.</span></span><br><span class="line">    <span class="comment">// We draw a random number between 0 and the size of gate `out[]&#x27;.</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">gateSize</span>(<span class="string">&quot;out&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">intuniform</span>(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tictoc-11"><a href="#tictoc-11" class="headerlink" title="tictoc 11"></a><code>tictoc 11</code></h3><p>定义了信道 <code>Channel</code>，其他与示例 10 一致：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">network Tictoc11</span><br><span class="line">&#123;</span><br><span class="line">    types:</span><br><span class="line">        channel Channel extends ned.DelayChannel &#123;</span><br><span class="line">            delay = <span class="number">100</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line">    submodules:</span><br><span class="line">        tic[<span class="number">6</span>]: Txc11;</span><br><span class="line">    connections:</span><br><span class="line">        tic[<span class="number">0</span>].out++ --&gt; Channel --&gt; tic[<span class="number">1</span>].in++;</span><br><span class="line">        tic[<span class="number">0</span>].in++ &lt;-- Channel &lt;-- tic[<span class="number">1</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">1</span>].out++ --&gt; Channel --&gt; tic[<span class="number">2</span>].in++;</span><br><span class="line">        tic[<span class="number">1</span>].in++ &lt;-- Channel &lt;-- tic[<span class="number">2</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">1</span>].out++ --&gt; Channel --&gt; tic[<span class="number">4</span>].in++;</span><br><span class="line">        tic[<span class="number">1</span>].in++ &lt;-- Channel &lt;-- tic[<span class="number">4</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">3</span>].out++ --&gt; Channel --&gt; tic[<span class="number">4</span>].in++;</span><br><span class="line">        tic[<span class="number">3</span>].in++ &lt;-- Channel &lt;-- tic[<span class="number">4</span>].out++;</span><br><span class="line"></span><br><span class="line">        tic[<span class="number">4</span>].out++ --&gt; Channel --&gt; tic[<span class="number">5</span>].in++;</span><br><span class="line">        tic[<span class="number">4</span>].in++ &lt;-- Channel &lt;-- tic[<span class="number">5</span>].out++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用的是延迟信道 <code>ned.DelayChannel</code> ，还有理想信道 <code>ned.IdealChannel</code>、数据率信道 <code>ned.DatarateChannel</code>。</p>
<h3 id="tictoc-12"><a href="#tictoc-12" class="headerlink" title="tictoc 12"></a><code>tictoc 12</code></h3><p>在 NED 文件中引入 <code>gate</code> 以代替 <code>in</code> 和 <code>out</code>，减少代码量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">simple Txc12</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;i=block/routing&quot;</span>);</span><br><span class="line">    gates:</span><br><span class="line">        inout gate[];  <span class="comment">// declare two way connections</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// using two way connections to further simplify the network definition</span></span><br><span class="line">network Tictoc12</span><br><span class="line">&#123;</span><br><span class="line">    types:</span><br><span class="line">        channel Channel extends ned.DelayChannel &#123;</span><br><span class="line">            delay = <span class="number">100</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line">    submodules:</span><br><span class="line">        tic[<span class="number">6</span>]: Txc12;</span><br><span class="line">    connections:</span><br><span class="line">        tic[<span class="number">0</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">1</span>].gate++;</span><br><span class="line">        tic[<span class="number">1</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">2</span>].gate++;</span><br><span class="line">        tic[<span class="number">1</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">4</span>].gate++;</span><br><span class="line">        tic[<span class="number">3</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">4</span>].gate++;</span><br><span class="line">        tic[<span class="number">4</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">5</span>].gate++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在使用 <code>gate</code> 代替 <code>in</code> 和 <code>out</code> 后，发送数据也要改变格式，即 <code>send(msg, &quot;gate$o&quot;, k);</code> 其中，<code>gate$o</code>这个 <code>o</code> 代表 <code>out</code>，如果是 <code>i</code> 则代表 <code>in</code>。</p>
<h3 id="tictoc-13"><a href="#tictoc-13" class="headerlink" title="tictoc 13"></a><code>tictoc 13</code></h3><p>使用 <code>.msg</code> 文件直接通过 <code>build</code> 生成 <code>.h</code> 文件和 <code>.cc</code> 文件，与命令行仿真关系不大。</p>
<h3 id="tictoc-14"><a href="#tictoc-14" class="headerlink" title="tictoc 14"></a><code>tictoc 14</code></h3><p>介绍了强制类型转换方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TicTocMsg13 *ttmsg = check_and_cast&lt;TicTocMsg13 *&gt;(msg);</span><br></pre></td></tr></table></figure>
<p>此外，消息经过传输后不仅包含了消息名，还包含源节点、目的节点和跳数信息。例如，可以通过函数 <code>msg-&gt;gerDestination()</code> 获取目的地信息。</p>
<h3 id="tictoc-15"><a href="#tictoc-15" class="headerlink" title="tictoc 15"></a><code>tictoc 15</code></h3><p>介绍了自动记录一个有关消息交换历史的详细日志方法，在 <code>omnetpp.ini</code> 文件中设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">record-eventlog = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>首先在类 <code>txc15</code> 的私有属性中写入变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cLongHistogram hopCountStats;</span><br><span class="line">cOutVector hopCountVector;</span><br></pre></td></tr></table></figure>
<p>然后在初始化中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hopCountStats.setName(<span class="string">&quot;hopCountStats&quot;</span>);</span><br><span class="line">hopCountVector.setName(<span class="string">&quot;HopCount&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>接着当消息到达目标节点时，更新统计信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hopCountVector.record(hopcount);</span><br><span class="line">hopCountStats.collect(hopcount);</span><br></pre></td></tr></table></figure>
<p>最后标量信息需要调用finish()函数手动记录：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">recordScalar(<span class="string">&quot;#sent&quot;</span>, numSent);</span><br><span class="line">recordScalar(<span class="string">&quot;#received&quot;</span>, numReceived);</span><br><span class="line"></span><br><span class="line">hopCountStats.recordAs(<span class="string">&quot;hop count&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>把跳数记录在一个输出向量里（横坐标是仿真时间，纵坐标是跳数）</p>
<h3 id="tictoc-16"><a href="#tictoc-16" class="headerlink" title="tictoc 16"></a><code>tictoc 16</code></h3><p>介绍了使用 <code>@signal</code> 进行数据统计的方式：</p>
<p><code>@signal [arrival](type = “long”)</code>：定义一个名为 <code>arrival</code> 的 <code>long</code> 类型信号。</p>
<p><code>@statistic[hopCount](title=&quot;hop count&quot;; source=&quot;arrival&quot;; record=vector,stats; interpolationmode=none);</code>：定义一个统计量，名字叫 <code>hopCount</code>，统计量标题名为 <code>hop count</code>，数据源是信号 <code>arrival</code>，记录形式为向量，<code>stats</code> 代表记录了平均值，方差等，是固定的。</p>
<p>在 <code>txc16.cc</code> 文件中，首先定义一个 <code>simsignal_t arrivalSignal;</code> 变量，并且对信号进行注册 <code>arrivalSignal = registerSignal(&quot;arrival&quot;);</code>。需要注意的是，每个统计信号都要注册。然后使用 <code>int hopcount = ttmsg-&gt;getHopCount();</code> 得出跳数，最后通过 <code>emit(arrivalSignal, hopcount);</code>函数来对信号进行统计量的输出。</p>
<p>其中，代码 <code>msg-&gt;setHopCount(msg-&gt;getHopCount()+1);</code> 实现了跳数的增加。</p>
<h3 id="tictoc-17"><a href="#tictoc-17" class="headerlink" title="tictoc 17"></a><code>tictoc 17</code></h3><p>在示例 16 的基础上增加了一些 GUI 的美化方式，与命令行关系不大。</p>
<h3 id="tictoc-18"><a href="#tictoc-18" class="headerlink" title="tictoc 18"></a><code>tictoc 18</code></h3><p>更改网络结构，在 NED 文件中引入了 <code>for</code> 循环。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">simple Txc18 extends Txc16</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network TicToc18</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        <span class="keyword">int</span> numCentralNodes = <span class="built_in"><span class="keyword">default</span></span>(<span class="number">2</span>);</span><br><span class="line">    types:</span><br><span class="line">        channel Channel extends ned.DelayChannel &#123;</span><br><span class="line">            delay = <span class="number">100</span>ms;</span><br><span class="line">        &#125;</span><br><span class="line">    submodules:</span><br><span class="line">        tic[numCentralNodes+<span class="number">4</span>]: Txc18;</span><br><span class="line">    connections:</span><br><span class="line">        <span class="comment">// connect the 2 nodes in one side to the central nodes</span></span><br><span class="line">        tic[<span class="number">0</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">2</span>].gate++;</span><br><span class="line">        tic[<span class="number">1</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[<span class="number">2</span>].gate++;</span><br><span class="line">        <span class="comment">// connect the central nodes together</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">2.</span>.numCentralNodes+<span class="number">1</span> &#123;</span><br><span class="line">            tic[i].gate++ &lt;--&gt; Channel &lt;--&gt; tic[i+<span class="number">1</span>].gate++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// connect the 2 nodes on the other side to the central nodes</span></span><br><span class="line">        tic[numCentralNodes+<span class="number">2</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[numCentralNodes+<span class="number">1</span>].gate++;</span><br><span class="line">        tic[numCentralNodes+<span class="number">3</span>].gate++ &lt;--&gt; Channel &lt;--&gt; tic[numCentralNodes+<span class="number">1</span>].gate++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>OMNeT++</category>
      </categories>
      <tags>
        <tag>OMNeT++</tag>
      </tags>
  </entry>
  <entry>
    <title>OMNeT++ 基础语法：消息</title>
    <url>/2022/07/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="cMessage-类"><a href="#cMessage-类" class="headerlink" title="cMessage 类"></a><code>cMessage</code> 类</h2><p><code>cMessage</code> 类是 <code>OMNeT++</code> 的核心类，它及其子类的对象可以模拟时间、包、帧、蜂窝、网络中的信号传输、系统中的实体传输等。Message在创建时可以指定名字、消息类型、长度、位错误标记、优先权：</p>
<span id="more"></span>
<ul>
<li><strong>名字</strong>：<code>string(const char *)</code> 类型，在模拟程序中可以自由使用。名字属性继承自 <code>cObject</code>。</li>
<li><strong>消息类型</strong>：定义为携带消息类型信息，值为 0 或正值。（负值部分被仿真库保留）。</li>
<li><strong>长度</strong>：用以计算当消息经过一个具有确定数据速率的信道时的传输时延。</li>
<li><strong>位错误标记</strong>：当消息通过具有位错误率 <code>ber</code> 的信道时，仿真内核以 $1-(1-ber)\times length$ 的概率将位错误标记设置为 1。</li>
<li><strong>优先权</strong>：仿真内核在对具有相同到达时间值的消息队列（FES）中使用优先权进行消息定制。</li>
</ul>
<h2 id="消息定义"><a href="#消息定义" class="headerlink" title="消息定义"></a>消息定义</h2><p>假设目前需要一些具有源地址、目的地址和跳数的消息对象，可以编写一个 <code>mypacket.msg</code> 文件如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">message MyPacket &#123;</span><br><span class="line">    fields:</span><br><span class="line">    	<span class="keyword">int</span> srcAddress;</span><br><span class="line">    	<span class="keyword">int</span> destAddress;</span><br><span class="line">    	<span class="keyword">int</span> hops = <span class="number">32</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>消息子集编译器的任务是生成一个 <code>C++</code> 类。若使用消息子集编译器来处理 <code>mypacket.msg</code> 文件，则会生成 <code>mypacket_m.h</code> 文件和 <code>mypacket_m.cc</code> 文件。其中，<code>mypacket_m.h</code> 文件包含类的声明。在 <code>field</code> 中支持以下数据类型：</p>
<ol>
<li>原始类型：<code>bool, char, short, int, long, unsigned short, unsigned int, unsigned long, double ,string</code></li>
<li>结构、类，由额外的 <code>C++</code> 代码进行声明</li>
</ol>
<h2 id="消息收发"><a href="#消息收发" class="headerlink" title="消息收发"></a>消息收发</h2><p>在 <code>OMNeT++</code> 中，<strong>对网络的仿真就是一系列简单模块间通过 <code>message</code> 进行通信的过程</strong>。在抽象层面上，<code>OMNeT++</code> 是一组通过消息传递相互通信的简单模块。简单模块的本质是它们创建、发送、接收、存储、修改、调度和销毁消息，而 <code>OMNeT++</code> 的其余部分都是为了促进这项任务，并收集有关正在发生的事情的统计数据。</p>
<p><code>OMNeT++</code> 中的消息是 <code>cMessage</code> 类或其子类之一的实例。网络数据包用 <code>cPacket</code> 表示，它是 <code>cMessage</code> 的子类。消息对象使用 C++ <code>new</code> 运算符创建，并在不再需要时使用 <code>delete</code> 运算符销毁。消息也被称为 <code>cMessage</code> 指针。</p>
<p>消息发送是这样实现的：消息的到达时间和误码标志在 <code>send()</code> 调用中计算得到，然后用计算出的到达时间将消息插入 FES 。仿真内核不会为每个链接单独安排消息，这样可以提高它的运行时效率。</p>
<h3 id="普通发送"><a href="#普通发送" class="headerlink" title="普通发送"></a>普通发送</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">send</span>(cMessage *msg, <span class="keyword">const</span> <span class="keyword">char</span> *gateName, <span class="keyword">int</span> index=<span class="number">0</span>);</span><br><span class="line"><span class="built_in">send</span>(cMessage *msg, <span class="keyword">int</span> gateId);</span><br><span class="line"><span class="built_in">send</span>(cMessage *msg, cGate *gate);</span><br></pre></td></tr></table></figure>
<p>其中，第一个函数 <code>gateName</code> 指消息必须通过的门的名称。如果该门是门向量，那么需要在 <code>index</code> 中指定执行的输出门；若不是，则不用考虑 <code>index</code> 参数。第二个函数和第三个函数分别使用门 ID 和门对象指针进行索引，执行速度比第一个函数要快。如果使用的是 IO 门，则需要制定输出门或输入门，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">send</span>(msg, <span class="string">&quot;out&quot;</span>);</span><br><span class="line"><span class="built_in">send</span>(msg, <span class="string">&quot;outv&quot;</span>, i);</span><br></pre></td></tr></table></figure>
<h3 id="广播和重传"><a href="#广播和重传" class="headerlink" title="广播和重传"></a>广播和重传</h3><p>需要注意的是，不能使用 <code>send()</code> 函数多次发送同一个 <code>message</code>，否则会产生 <code>not owner of message</code> 的错误。在 <code>OMNeT++</code> 中，消息就是一个具体的对象，在同一时刻不能出现在多个不同的地点。一旦 <code>message</code> 从源节点发出，它就不再属于源节点。当 <code>message</code> 到达目的端后，目的端就具有对该 <code>message</code> 的一切控制权，如接收、转发、删除等。</p>
<p>在 <code>OMNeT++</code> 中，广播可以通过在一个简单模块中发送相同消息的副本来实现，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Method 1 基础版本</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cMessage *copy = msg-&gt;<span class="built_in">dup</span>();</span><br><span class="line">    <span class="built_in">send</span>(copy, <span class="string">&quot;out&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> msg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Method 2 利用门 ID 实现优化</span></span><br><span class="line"><span class="keyword">int</span> outGateBaseId = <span class="built_in">gateBaseId</span>(<span class="string">&quot;out&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">send</span>(i==n<span class="number">-1</span> ? msg : msg-&gt;<span class="built_in">dup</span>(), outGateBaseId+i);</span><br></pre></td></tr></table></figure>
<p>在实现重传时，不能重复发送指向同一个消息对象的指针，因为这样在第一次重发时就会得到 <code>not owner of message</code> 错误。解决方案与广播相似，实现重传需要创建和发送消息的副本并保留原始信息。当确定不会再重新传输该消息时，再删除原始消息：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// retransmit packet:</span></span><br><span class="line">cMessage *copy = packet-&gt;<span class="built_in">dup</span>();</span><br><span class="line"><span class="built_in">send</span>(copy, <span class="string">&quot;out&quot;</span>);</span><br><span class="line"><span class="keyword">delete</span> packet; <span class="comment">// Finish</span></span><br></pre></td></tr></table></figure>
<h3 id="延迟发送"><a href="#延迟发送" class="headerlink" title="延迟发送"></a>延迟发送</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sendDelayed</span>(cMessage *msg, <span class="keyword">double</span> delay, <span class="keyword">const</span> <span class="keyword">char</span> *gateName, <span class="keyword">int</span> index);</span><br><span class="line"><span class="built_in">sendDelayed</span>(cMessage *msg, <span class="keyword">double</span> delay, <span class="keyword">int</span> gateId);</span><br><span class="line"><span class="built_in">sendDelayed</span>(cMessage *msg, <span class="keyword">double</span> delay, cGate *gate);</span><br></pre></td></tr></table></figure>
<p>延迟发送相较 <code>send()</code> 函数多了一个延迟参数 <code>delay</code>。<code>delay</code> 值必须是非负数。消息的送出时间是当前的模拟时间 + 延迟时间。该功能的效果类似于模块将消息保留了延迟间隔，然后再发送，在函数的内部并不会执行 <code>scheduleAt()</code> 加上 <code>send()</code> 函数，而是预先计算有关消息发送的所有内容，包括到达时间和目标模块。</p>
<h3 id="自传消息"><a href="#自传消息" class="headerlink" title="自传消息"></a>自传消息</h3><p>在 <code>OMNeT++</code> 中，让简单模块向自身发送消息可以解决仿真模型对未来事件的调度，以实现定时、超时、延迟等功能。以这种方式使用的消息称为 <em>self-messages</em>，模块类为它们提供了特殊的方法，允许在没有门和连接的情况下实现自传消息。</p>
<h4 id="调度事件"><a href="#调度事件" class="headerlink" title="调度事件"></a>调度事件</h4><p>模块可以使用 <code>scheduleAt()</code> 向自己发送信息，该函数可以使用一个绝对模拟时间：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scheduleAt</span>(absoluteTime, msg);</span><br></pre></td></tr></table></figure>
<p>由于目的时间通常与当前的模拟时间相关联，因此函数还有另一个变体 <code>scheduleAfter()</code>，该函数使用的是时间增量。以下两种用法是等效的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>()+delta, msg);</span><br><span class="line"><span class="built_in">scheduleAfter</span>(delta, msg);</span><br></pre></td></tr></table></figure>
<p>自信息还可以与其他消息以相同的方式传递（如 <code>handleMessage()</code>），模块也可以通过调用接收到的信息对象的 <code>isSelfMessage()</code> 成员函数来确定其是否是自信息，也可以通过 <code>isScheduled()</code> 成员函数确定消息是否在 FES 中。</p>
<h4 id="取消事件"><a href="#取消事件" class="headerlink" title="取消事件"></a>取消事件</h4><p>模块可以取消已经预定了的自信息，即从 FES 中删除对应事件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cancelEvent</span>(msg);</span><br></pre></td></tr></table></figure>
<p><code>cancelEvent()</code> 函数接受一个指向要取消的消息的指针，并返回相同的指针。执行取消命令后，可以删除对应消息或在 <code>scheduleAt()</code> 函数中重新启用事件。但如果没有对消息进行操作，则 <code>cancelEvent()</code> 无效。</p>
<p>还有一种便捷方式可以实现对消息的删除，且通常用于编写析构函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">delete</span> <span class="title">cancelEvent</span><span class="params">(msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是一个假想停止等待协议的实际应用实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Protocol::handleMessage</span><span class="params">( cMessage *msg)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (msg == timeoutEvent) &#123; </span><br><span class="line">        <span class="comment">// 超时，重新发送数据包并重启定时器</span></span><br><span class="line">        <span class="built_in">send</span>(currentPacket-&gt;<span class="built_in">dup</span>(), <span class="string">&quot;out&quot;</span>); </span><br><span class="line">        <span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>() + timeout, timeoutEvent); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123; <span class="comment">// 如果收到确认</span></span><br><span class="line">        <span class="comment">// 取消超时，准备发送下一个数据包等</span></span><br><span class="line">        <span class="built_in">cancelEvent</span>(timeoutEvent); </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">       ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="重新安排事件"><a href="#重新安排事件" class="headerlink" title="重新安排事件"></a>重新安排事件</h4><p>要重新安排事件到不同模拟时间时，先要使用 <code>cancelEvent()</code> 取消事件，再进行安排：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg-&gt;<span class="built_in">isScheduled</span>())</span><br><span class="line">    <span class="built_in">cancelEvent</span>(msg);</span><br><span class="line"><span class="built_in">scheduleAt</span>(<span class="built_in">simTime</span>() + delay, msg);</span><br></pre></td></tr></table></figure>
<p>或者也可以直接使用成员函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rescheduleAt</span>(absoluteTime, msg);</span><br><span class="line"><span class="built_in">rescheduleAfter</span>(delta, msg);</span><br></pre></td></tr></table></figure>
<h3 id="消息直传"><a href="#消息直传" class="headerlink" title="消息直传"></a>消息直传</h3><p><code>sendDirect()</code> 函数提供了直接将消息直接发送到另一个模块输入门的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sendDirect</span>(cMessage *msg, cModule *mod, <span class="keyword">int</span> gateId);</span><br><span class="line"><span class="built_in">sendDirect</span>(cMessage *msg, cModule *mod, <span class="keyword">const</span> <span class="keyword">char</span> *gateName, <span class="keyword">int</span> index=<span class="number">-1</span>); </span><br><span class="line"><span class="built_in">sendDirect</span>(cMessage *msg, cGate *gate);</span><br></pre></td></tr></table></figure>
<p>在目标模块，直接接收的消息和通过连接传输的消息没有区别。但是需要注意的是，模块必须有专用的门才能接收通过 <code>sendDirect()</code> 发送的消息。不能一个门既能通过连接也能通过 <code>sendDirect()</code> 接收消息。</p>
<p>官方文档中建议在模块的 <code>NED</code> 声明中使用 <code>@directIn</code> 标记专用于通过 <code>sendDirect()</code> 接收消息的门以避免 <code>OMNeT++</code> 提示在使用该模块的网络或复合模块中没有连接门，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">simple Radio &#123;</span><br><span class="line">    gates:</span><br><span class="line">        input radioIn @directIn; <span class="comment">// 接受直传帧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sendDirect()</code>方法也接受传播延迟和传输持续时间作为参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sendDirect</span>(cMessage *msg, <span class="keyword">simtime_t</span> propagationDelay, <span class="keyword">simtime_t</span> duration,</span><br><span class="line">           cModule *mod, <span class="keyword">int</span> gateId);</span><br><span class="line"><span class="built_in">sendDirect</span>(cMessage *msg, <span class="keyword">simtime_t</span> propagationDelay, <span class="keyword">simtime_t</span> duration,</span><br><span class="line">           cModule *mod, <span class="keyword">const</span> <span class="keyword">char</span> *gateName, <span class="keyword">int</span> index=<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">sendDirect</span>(cMessage *msg, <span class="keyword">simtime_t</span> propagationDelay, <span class="keyword">simtime_t</span> duration,</span><br><span class="line">           cGate *gate);</span><br></pre></td></tr></table></figure>
<p>消息是一个数据包（<code>cPacket</code> 的实例）时需要指定 <code>duration</code> 参数。对于不是数据包的消息可以忽略 <code>duration</code>。</p>
<p>如果消息是一个数据包，则持续时间将被写入数据包，并且可以由接收者通过数据包的<code>getDuration()</code>方法读取。</p>
<h2 id="数据包传输"><a href="#数据包传输" class="headerlink" title="数据包传输"></a>数据包传输</h2><p>当一条消息在门上发出后通常会经过一系列连接直到它到达目标模块，称这一系列的连接为<strong>连接路径</strong>（connection paths）。</p>
<p>路径中的多个连接可能具有关联的通道，但每条路径只能有一个通道来模拟非零传输持续时间。此限制由模拟内核强制执行。这个通道称为<strong>传输通道</strong>(transition channels)。</p>
<h3 id="发送数据包"><a href="#发送数据包" class="headerlink" title="发送数据包"></a>发送数据包</h3><p>只有在传输通道空闲时才能发送数据包。这意味着在每次传输之后，发送模块需要等到通道完成传输才能发送另一个数据包。</p>
<p>我们可以通过在输出门上调用 <code>getTransmissionChannel()</code> 方法获取指向传输通道的指针。通道的 <code>isBusy()</code> 和 <code>getTransmissionFinishTime()</code> 方法可以得到通道当前是否正在传输，以及传输何时结束。（当后者小等于当前模拟时间时，通道空闲）如果通道当前忙，发送需要推迟，则可以将数据包存储在队列中，并且可以使用定时器（自消息）安排在频道变空时进行发送。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cPacket *pkt = ...; <span class="comment">// 要传输的数据包</span></span><br><span class="line">cChannel *txChannel = <span class="built_in">gate</span>(<span class="string">&quot;out&quot;</span>)-&gt;<span class="built_in">getTransmissionChannel</span>(); </span><br><span class="line"><span class="keyword">simtime_t</span> txFinishTime = txChannel-&gt;<span class="built_in">getTransmissionFinishTime</span>(); </span><br><span class="line"><span class="keyword">if</span> (txFinishTime &lt;= <span class="built_in">simTime</span>()) &#123; </span><br><span class="line">    <span class="comment">// 通道空闲；立即发送数据包</span></span><br><span class="line">    <span class="built_in">send</span>(pkt, <span class="string">&quot;out&quot;</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">// 存储数据包和调度定时器；当计时器到期时，</span></span><br><span class="line">    <span class="comment">// 数据包应该从队列中移除并发送出去</span></span><br><span class="line">    txQueue.<span class="built_in">insert</span>(pkt); </span><br><span class="line">    <span class="built_in">scheduleAt</span>(txFinishTime, endTxMsg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>★官方建议不要在路径中的传输通道前面使用传播延迟。</p>
<h3 id="接收数据包"><a href="#接收数据包" class="headerlink" title="接收数据包"></a>接收数据包</h3><p>对信道的错误建模可能会导致数据包在到达时设置了位错误标志（<code>hasBitError()</code> 方法）。接收模块会检查此标志并丢弃数据包。通常，包对象在完成消息接收的模拟时间（即最后一个比特到达后）被传递到目标模块。但是，接收器模块可以通过使用 <code>setDeliverImmediately()</code> 方法修改接收器门来改变这一点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">gate</span>(<span class="string">&quot;in&quot;</span>)-&gt;<span class="built_in">setDeliverImmediately</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>此方法只能在简单模块的输入门上调用，它指示模拟内核在对应于接收过程开始的模拟时间传递通过该门到达的数据包。当一个数据包被投递到模块时，可以调用该数据包的 <code>isReceptionStart()</code> 方法来判断它是对应于接收过程的开始还是结束（它应该与输入门的 <code>getDeliverOnReceptionStart()</code> 得到的标志相同），<code>getDuration()</code> 返回传输持续时间。<code>getDeliverOnReceptionStart()</code> 函数只需要调用一次，所以通常在模块的<code>initialize()</code>方法中完成。</p>
<p>包传输模型如下图所示。</p>
<p><img src="/2022/07/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A%E6%B6%88%E6%81%AF/image-20220801220240507.png" alt="image-20220801220240507" style="zoom: 50%;"></p>
<p>需要终止传输时，可以使用 <code>forceTransmissionFinishTime()</code> 方法。此方法用给定值强制覆盖通道的<code>transmissionFinishTime</code> 成员变量，允许发送方发送另一个数据包而不会引发 <code>channel is currently busy</code> 错误。接收方需要通过某些外部方式（例如通过发送另一个数据包或带外消息）来通知传输中止。</p>
<h2 id="使用-activity-接收消息"><a href="#使用-activity-接收消息" class="headerlink" title="使用 activity() 接收消息"></a>使用 activity() 接收消息</h2><p>基于 <code>activity()</code> 的模块使用 <code>cSimpleModule</code> 的 <code>receive()</code> 方法接收消息。<code>receive()</code> 不能与基于<code>handleMessage()</code> 的模块一起使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cMessage *msg = <span class="built_in">receive</span>();</span><br></pre></td></tr></table></figure>
<p><code>wait()</code> 函数将模块的执行挂起一段给定的模拟时间（增量）。<code>wait()</code> 也不能与基于 <code>handleMessage()</code> 的模块一起使用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wait</span>(delay);</span><br></pre></td></tr></table></figure>
<p><code>wait()</code> 函数由 <code>scheduleAt()</code> 后跟一个 <code>receive()</code> 函数实现。<code>wait()</code> 函数在不需要为到达消息做准备的模块中非常方便，例如消息生成器。一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123; </span><br><span class="line">    <span class="comment">// 等待一些可能是随机的时间量，</span></span><br><span class="line">    <span class="comment">// 在 interarrivalTime volatile 模块参数中指定</span></span><br><span class="line">    <span class="built_in">wait</span>(<span class="built_in">par</span>(<span class="string">&quot;interarrivalTime&quot;</span>).<span class="built_in">doubleValue</span>()); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并发送消息</span></span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果消息在等待时间间隔内到达，则会报运行时错误。如果希望消息在等待期间到达，可以使用<code>waitAndEnqueue()</code> 函数。除了等待间隔之外，它还需要一个指向队列对象（属于<code>cQueue</code>类）。在等待时间间隔内到达的消息会累积在队列中，等待 <code>waitAndEnqueue()</code> 调用返回后才能被系统处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">cQueue <span class="title">queue</span><span class="params">(<span class="string">&quot;queue&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">waitAndEnqueue</span>(waitTime, &amp;queue);</span><br><span class="line"><span class="keyword">if</span> (!queue.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// process messages arrived during wait interval</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>OMNeT++</category>
      </categories>
      <tags>
        <tag>OMNeT++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记_else的用法</title>
    <url>/2020/03/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Python-Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_else/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在学习Python前，基于对于CPP的学习，对于else的印象就是，else与if要成对出现。但是在不久前，一个在编写100以内求素数的程序时偶然出现的缩进“错误”导致了我的疑惑。代码如下：</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#求100以内的素数之和.py</span></span><br><span class="line"><span class="built_in">sum</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">101</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,i):</span><br><span class="line">        <span class="keyword">if</span> i%j==<span class="number">0</span> <span class="keyword">and</span> i!=j:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">sum</span>+=i</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 奇怪的是，这个“错误”并没有导致程序报错，相反，这段程序恰恰能完成我们的目标。于是，我便对Python中else的用法产生了兴趣，故作此记。</p>
<h2 id="一-if-else"><a href="#一-if-else" class="headerlink" title="一.if - else"></a>一.if - else</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else和if一起使用时，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">	语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	语句块<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当条件为真时，执行语句块1的内容；否则，执行语句块2</p>
<h2 id="二-for-try-while-else"><a href="#二-for-try-while-else" class="headerlink" title="二.for/try/while - else"></a>二.for/try/while - else</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else语句也可以与for一起使用，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">	语句块<span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	语句块<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在for-else中，<strong>当for循环完整的执行过后，执行else里的语句块2</strong>；若for循环没能完整地执行，如语句块中的break语句被执行时，不执行else中的语句。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在try/while……else语句中同理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>在if-else中，<strong>如果if条件不满足，则执行else之后的语句</strong></li>
<li>在for/while/try-else中，<strong>若for/while/try没能正常执行完毕，则执行else之后的语句</strong></li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记_神经网络常见激活函数整理及其 Python 绘图</title>
    <url>/2021/08/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Python-Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%BB%98%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了三种常见的激活函数以及激活函数的选择方式。</p>
<span id="more"></span>
<h1 id="1-Sigmoid-Function"><a href="#1-Sigmoid-Function" class="headerlink" title="1 Sigmoid Function"></a>1 Sigmoid Function</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><p>Sigmoid 函数又名 Logistic 函数，值域为 (0, 1) ，可以将任意一个实数映射到一个介于 (0, 1) 区间之内的值，常用于隐层神经元输出，其函数表达式为：</p>
<script type="math/tex; mode=display">
Sigmoid(z) = \frac{1}{1+e^{-z}}</script><h2 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h2><ul>
<li><p><strong>优点</strong>：Sigmoid 函数求导简便，在在特征相差比较复杂或是相差不是特别大时效果比较</p>
</li>
<li><p><strong>缺点</strong>：激活函数计算量大，在反向传播时容易出现梯度消失问题；当 $z$ 很大或者很小时，函数变化的很慢，会拖慢梯度下降算法</p>
</li>
</ul>
<p><strong>★ 除非在二分类的输出层，否则尽量不要使用</strong></p>
<h2 id="1-3-函数图像"><a href="#1-3-函数图像" class="headerlink" title="1.3 函数图像"></a>1.3 函数图像</h2><p>使用 <code>matplotlib.pyplot</code> 进行绘图，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">0.01</span>) <span class="comment"># 生成一个 [-10, 10] 之间差值为 0.01 的等差数列，代表图像中的 x axis</span></span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> x:</span><br><span class="line">    y.append(<span class="number">1</span>/(<span class="number">1</span> + math.exp(-num)))</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Sigmoid Function&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;σ(z)&#x27;</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>图像绘制结果如下所示：</p>
<p><img src="/2021/08/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Python-Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%BB%98%E5%9B%BE/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png" alt=" "></p>
<h1 id="2-Tanh-Function"><a href="#2-Tanh-Function" class="headerlink" title="2 Tanh Function"></a>2 Tanh Function</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h2><p>Tanh 函数叫做 反正切 函数，值域为 (-1, 1) ，可以将任意一个实数映射到一个介于 (-1, 1) 区间之内的值，其函数表达式为：</p>
<script type="math/tex; mode=display">
tanh(z)=\frac{e^{z}-e^{-z}}{e^{z}+e^{-z}}</script><h2 id="2-2-优缺点"><a href="#2-2-优缺点" class="headerlink" title="2.2 优缺点"></a>2.2 优缺点</h2><ul>
<li><p><strong>优点</strong>：Tanh 函数几乎总比 Sigmoid 函数表现的好，因为函数输出介于 -1 和 1 之间，激活函数的平均值更接近 0，使用 Tanh 函数有类似数据中心化的效果，使得数据的平均值更接近 0，使得下一层的学习更加方便</p>
</li>
<li><p><strong>缺点</strong>：在输出层时，我们更希望输出值 $\hat{y}$ 是一个介于 0 和 1 之间的数而不是 -1 和 1 之间； 在二元分类的时候， Tanh 函数作为输出层的表现也不如 Sigmoid 函数； 当 $z$ 很大或者很小时，函数变化的很慢，会拖慢梯度下降算法</p>
</li>
</ul>
<h2 id="2-3-函数图像"><a href="#2-3-函数图像" class="headerlink" title="2.3 函数图像"></a>2.3 函数图像</h2><p>使用 <code>matplotlib.pyplot</code> 进行绘图，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">0.01</span>) <span class="comment"># 生成一个 [-10, 10] 之间差值为 0.01 的等差数列，代表图像中的 x axis</span></span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> x:</span><br><span class="line">    y.append((math.exp(num) - math.exp(-num))/(math.exp(num) + math.exp(-num)))</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Tanh Function&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;tanh(x)&#x27;</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>图像绘制结果如下所示：</p>
<p><img src="/2021/08/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Python-Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%BB%98%E5%9B%BE/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438696970172.png" alt></p>
<h1 id="3-ReLU-Rectified-Linear-Unit"><a href="#3-ReLU-Rectified-Linear-Unit" class="headerlink" title="3 ReLU (Rectified Linear Unit)"></a>3 ReLU (Rectified Linear Unit)</h1><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h2><p>通常意义下，线性修正单元 ReLU 指代数学中的斜坡函数，即</p>
<script type="math/tex; mode=display">
ReLU(z) = max\{0, z\}</script><p>而在神经网络中，ReLU 通常作为神经元的默认激活函数，定义了该神经元在线性变换$w^{T}x+b$ 之后的非线性输出结果。换言之，对于进入神经元的来自上一层神经网络的输入向量，使用线性整流激活函数的神经元会输出</p>
<script type="math/tex; mode=display">
ReLU(z) = max\{0, w^{T}x+b\}</script><p>至下一层神经元或作为整个神经网络的输出</p>
<h2 id="3-2-优缺点"><a href="#3-2-优缺点" class="headerlink" title="3.2 优缺点"></a>3.2 优缺点</h2><ul>
<li><strong>优点</strong>：更加有效率的梯度下降以及反向传播：避免了梯度爆炸和梯度消失问题；简化计算过程：没有了其他复杂激活函数中诸如指数函数的影响；同时相较于 Sigmoid Function &amp; Tanh Function， 神经网络整体计算成本下降，速度加快很多</li>
<li><strong>缺点</strong>：在 $z&lt;0$ 时导数为 0 ，在 $z=0$ 时不可导</li>
</ul>
<h2 id="3-3-函数图像"><a href="#3-3-函数图像" class="headerlink" title="3.3 函数图像"></a>3.3 函数图像</h2><p>使用 <code>matplotlib.pyplot</code> 进行绘图，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(-<span class="number">10</span>, <span class="number">10</span>, <span class="number">0.01</span>) <span class="comment"># 生成一个 [-10, 10] 之间差值为 0.01 的等差数列，代表图像中的 x axis</span></span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">0</span> :</span><br><span class="line">        y.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y.append(num)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;Rectified Linear Unit&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;ReLU(z)&#x27;</span>)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>图像绘制结果如下所示：</p>
<p><img src="/2021/08/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Python-Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E7%BB%98%E5%9B%BE/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438697156164.png" alt></p>
<h1 id="4-选择-Activation-Functions-的经验法则"><a href="#4-选择-Activation-Functions-的经验法则" class="headerlink" title="4 选择 Activation Functions 的经验法则"></a>4 选择 Activation Functions 的经验法则</h1><ul>
<li>如果输出值是 0 和 1 （二元分类），Sigmoid Function 很适合作为输出层的激活函数，其他单元都用 ReLU 作为激活函数（如果你不知道隐层应该用什么激活函数）</li>
<li>如果愿意的话，也可以用 $Leaky ReLU(z) = max\{0.01z,z\}$ ，与 ReLU 相比， Leaky ReLU 在 $z&lt;0$ 的部分导数不为 0。当然，Leaky ReLU 中的系数 $0.01$ 也可以把其看做一个需要学习的参数进行训练</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>【Pytorch】模型的保存和加载</title>
    <url>/2023/12/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Pytorch-pytorch%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在对神经网络模型进行训练时，定期地保存模型可以增加程序的抗风险能力。同时，通过对保存模型的加载可以很方便地复现和使用我们训练好的神经网络模型。基于此，本文记录了 Pytorch 中的模型保存和加载方法。</p>
<span id="more"></span>
<p>Pytorch的模型后缀一般为 <code>.pt</code> 或 <code>.pth</code>。在保存模型时，我们有两种选择：</p>
<ul>
<li>保存整个神经网络模型，包括神经网络的模型结构和模型参数</li>
<li>只保存神经网络的模型参数</li>
</ul>
<p>不同的保存方式对应不同的加载方式。</p>
<h4 id="1-只保存神经网络的模型参数"><a href="#1-只保存神经网络的模型参数" class="headerlink" title="1. 只保存神经网络的模型参数"></a>1. 只保存神经网络的模型参数</h4><p>只保留神经网络的模型参数时，调用的是 <code>torch.save()</code> 函数，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = ...</span><br><span class="line">torch.save(model.state_dict(), <span class="string">&quot;model.pt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>此时，在 <code>model.pt</code> 文件中将保存神经包含 <code>weight</code> 参数和 <code>bias</code> 参数的字典以反映神经网络模型的状态信息。也就是说，该方式只保存了神经网络中可以进行学习的参数。</p>
<p>在加载参数时，需要先建立好对应结构的神经网络模型，然后再进行调用，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = ...</span><br><span class="line">model.load_state_dict(torch.load(<span class="string">&quot;model.pt&quot;</span>))</span><br></pre></td></tr></table></figure>
<h4 id="2-保存整个神经网络模型"><a href="#2-保存整个神经网络模型" class="headerlink" title="2. 保存整个神经网络模型"></a>2. 保存整个神经网络模型</h4><p>在保存整个神经网络时，调用的也是 <code>torch.save()</code> 函数，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = ...</span><br><span class="line">torch.save(model, <span class="string">&quot;model.pt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>而在加载模型时，并不需要先建立好对应的神经网络模型结构，而是可以直接赋值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = torch.load(<span class="string">&quot;model.pt&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="3-保存训练过程的-Checkpoint-以期继续训练"><a href="#3-保存训练过程的-Checkpoint-以期继续训练" class="headerlink" title="3. 保存训练过程的 Checkpoint 以期继续训练"></a>3. 保存训练过程的 Checkpoint 以期继续训练</h4><p>若是在训练途中保存 Checkpoint，仍可以通过调用 <code>torch.save()</code> 函数实现需求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = ...</span><br><span class="line">torch.save(&#123;</span><br><span class="line">  <span class="string">&quot;episode&quot;</span>: episode,</span><br><span class="line">  <span class="string">&quot;current_step&quot;</span>: current_step,</span><br><span class="line">  <span class="string">&quot;model_state_dict&quot;</span>: model.state_dict(),</span><br><span class="line">  <span class="string">&quot;optimizer_state_dict&quot;</span>: optimizer.state_dict(),</span><br><span class="line">  <span class="string">&quot;loss&quot;</span>: loss,</span><br><span class="line">  <span class="string">&quot;reward&quot;</span>: reward,</span><br><span class="line">  ...</span><br><span class="line">&#125;, <span class="string">&quot;model.pt&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>此时，在加载时需要对对应内容进行索引：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = ...</span><br><span class="line">opt = ...</span><br><span class="line">check_point = torch.load(<span class="string">&quot;model.pt&quot;</span>)</span><br><span class="line">model.load_state_dict(check_point[<span class="string">&quot;model_state_dict&quot;</span>])</span><br><span class="line">opt.load_state_dict(check_point[<span class="string">&quot;optimizer_state_dict&quot;</span>])</span><br><span class="line">episode = check_point[<span class="string">&quot;episode&quot;</span>]</span><br><span class="line">current_step = check_point[<span class="string">&quot;current_step&quot;</span>]</span><br><span class="line">loss = check_point[<span class="string">&quot;loss&quot;</span>]</span><br><span class="line">reward = check_point[<span class="string">&quot;reward&quot;</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>此外，若是想在同一个文件里保存多个模型，也可以使用该方法保存，并通过索引读取不同的参数。</p>
<h4 id="4-读取模型后需要注意的事"><a href="#4-读取模型后需要注意的事" class="headerlink" title="4. 读取模型后需要注意的事"></a>4. 读取模型后需要注意的事</h4><p>在使用保存的模型进行预测时，调用后还需要加上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.<span class="built_in">eval</span>()</span><br></pre></td></tr></table></figure>
<p>同时，也需要关闭梯度的计算。此时的写法为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model = ...</span><br><span class="line">model.load_state_dict(torch.load(<span class="string">&quot;model.pt&quot;</span>))</span><br><span class="line"><span class="comment"># 或 model.load(&quot;model.pt&quot;)</span></span><br><span class="line"></span><br><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">  ...</span><br><span class="line">  predict_data = model(input_data)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>同样的，在使用保存的模型进行训练时，也需要加上：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.train()</span><br></pre></td></tr></table></figure>
<p>将模型转换为训练模式。</p>
<p>上述操作的必要性在于，在训练阶段和测试阶段中 Dropout 层和 Batch Normalization 层将产生不同影响。若是不加控制，则在训练阶段和测试阶段难以得到期望结果。</p>
<p>对于 Dropout 层而言，在前向传播时，dropout 函数会让神经元的激活值以给定的概率停止工作（神经网络神经元的值置 0）以避免神经网络对局部特征的过度依赖，进而增强模型的泛化性。而在测试的时候，我们使用的是已经训练好的模型。在使用过程中显然不需要 dropout 的功能。同时，如果 dropout 功能仍然存在，将不可避免地会影响到最终输出结果的准确性。</p>
<p>对于 Batch Normalization 层而言，Batch Normalization 是为了让神经网络每层的数据输入都保持在相近的范围：</p>
<script type="math/tex; mode=display">
h = f(g \cdot \frac{x-\mu}{\sigma} + b)</script><p>其中，模型是通过计算输入数据的均值和方差来实现 Batch Normalization。而在使用模型的时候，对输入的单个数据或需要预测的一批数据计算均值和方差是没有意义的，而应该直接使用训练阶段得到的对整体样本空间估算的均值和方差进行计算。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Pytorch】固定随机数种子</title>
    <url>/2023/12/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Pytorch-pytorch%E5%9B%BA%E5%AE%9A%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%A7%8D%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在对神经网络模型进行训练时，有时候会存在对训练过程进行复现的需求。然而，每次运行时 Pytorch、Numpy 中的随机性将使得该目的变得困难重重。在程序运行前固定所有随机数的种子有望解决这一问题。基于此，本文记录了 Pytorch 中的固定随机数种子的方法。</p>
<span id="more"></span>
<p>在使用 Pytorch 对模型进行训练时，通常涉及到随机数的模块包括：Python、Pytorch、Numpy、Cudnn。因此，在开始训练前，需要针对这些涉及随机数的模块进行随机数种子的固定。</p>
<h4 id="1-Python"><a href="#1-Python" class="headerlink" title="1. Python"></a>1. Python</h4><p>Python 本身涉及到的随机性主要是 Python 自带的 random 库随机化和 Hash 随机化问题，需要通过 <code>os</code> 库对其进行限制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os, random</span><br><span class="line">random.seed(seed)</span><br><span class="line">os.environ[<span class="string">&#x27;PYTHONHASHSEED&#x27;</span>] = <span class="built_in">str</span>(seed)</span><br></pre></td></tr></table></figure>
<h4 id="2-Numpy"><a href="#2-Numpy" class="headerlink" title="2. Numpy"></a>2. Numpy</h4><p>在使用 Numpy 库取随机数时，需要对其随机数种子进行限制：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.seed(seed)</span><br></pre></td></tr></table></figure>
<h4 id="3-Pytorch"><a href="#3-Pytorch" class="headerlink" title="3. Pytorch"></a>3. Pytorch</h4><p>当 Pytorch 使用 CPU 进行运算时，需要设定 CPU 支撑下的 Pytorch 随机数种子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.manual_seed(seed)</span><br></pre></td></tr></table></figure>
<p>当 Pytorch 使用 GPU 进行运算时，需要设定 GPU 支撑下的 Pytorch 随机数种子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.cuda.manual_seed(seed)</span><br><span class="line">torch.cuda.manual_seed_all(seed) <span class="comment"># 使用多 GPU 时使用</span></span><br></pre></td></tr></table></figure>
<p><strong>需要特别注意的是：目前很多博客和知乎回答提出 <code>torch.cuda.manual_seed(seed)</code> 和 <code>torch.cuda.manual_seed_all(seed)</code> 具有相同的作用。这个结论需要注意 Pytorch 版本。在笔者所用的 Pytorch 2.1 版本下，这两个函数的作用完全不同。参考官方文档：<a href="https://pytorch.org/docs/2.1/generated/torch.cuda.manual_seed.html#torch.cuda.manual_seed">torch.cuda.manual_seed</a> 和 <a href="https://pytorch.org/docs/2.1/generated/torch.cuda.manual_seed_all.html#torch.cuda.manual_seed_all">torch.cuda.manual_seed_all(seed)</a></strong> </p>
<p>当 Pytorch 使用 Cudnn 进行加速运算时，还需要限制 Cudnn 在加速过程中涉及到的随机策略：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>基于上述库的固定随机数方法总结为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_random_seed</span>(<span class="params">seed: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">	random.seed(seed)</span><br><span class="line">	os.environ[<span class="string">&#x27;PYTHONHASHSEED&#x27;</span>] = <span class="built_in">str</span>(seed)</span><br><span class="line">	np.random.seed(seed)</span><br><span class="line">	torch.manual_seed(seed)</span><br><span class="line">	torch.cuda.manual_seed_all(seed)</span><br><span class="line">	torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br><span class="line">	torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">seed = <span class="number">114514</span></span><br><span class="line">set_torch_seed(seed)</span><br></pre></td></tr></table></figure>
<p>如果在实践中还调用了其他涉及随机性的第三方库，则需要根据上述思路对该固定随机数方法进行动态补充。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Pytorch</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>从博弈论到 MARL.中科院自动化所张海峰讲座.20200606</title>
    <url>/2022/08/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E4%BB%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%B0%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="内容摘要"><a href="#内容摘要" class="headerlink" title="内容摘要"></a>内容摘要</h2><p>随着以图像识别为代表的“感知智能”日趋成熟，越来越多的人工智能研究者开始关注以 AlphaGo 为代表的“<strong>决策智能</strong>”。在即将来临的物联网时代，<strong>群体决策智能将成为一个研究重点</strong>。</p>
<span id="more"></span>
<p>传统上，博弈论研究的是多个智能体的理性决策问题。它定义了动作、收益等博弈基本概念，侧重分析理性智能体的博弈结果，即均衡。然而，在很多现实问题中，博弈的状态空间和动作空间都很大，<strong>智能体的绝对理性是很难实现的</strong>.智能体往往处在不断的策略学习过程中。因此，近年来兴起的<strong>多智能体强化学习</strong>主要研究智能体策略的同步学习和演化问题，它在无人机群控制、智能交通系统、智能工业机器人等场景中具有很大的应用前景。</p>
<h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>AI 发展趋势是由智能感知到智能决策，再到群体智能决策。群体智能决策的场景有王者荣耀、快递机器人配送、自动驾驶等。</p>
<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="博弈定义"><a href="#博弈定义" class="headerlink" title="博弈定义"></a>博弈定义</h3><p>定义玩家集合为 $N = \{1,2,…,n\}$，策略集合为 $A_1,A_2,…,A_n$，收益函数为 $r_1,r_2,…,r_n$</p>
<h3 id="矩阵博弈"><a href="#矩阵博弈" class="headerlink" title="矩阵博弈"></a>矩阵博弈</h3><p>以囚徒困境为例，玩家 1 和玩家 2 的策略空间及收益组合如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">坦白</th>
<th style="text-align:center">抵赖</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">坦白</td>
<td style="text-align:center">1， 1</td>
<td style="text-align:center">3， 0</td>
</tr>
<tr>
<td style="text-align:center">抵赖</td>
<td style="text-align:center">0， 3</td>
<td style="text-align:center">2， 2</td>
</tr>
</tbody>
</table>
</div>
<p>其中包含一些基本假设：</p>
<ul>
<li>两个玩家同时决策</li>
<li>玩家知道所有博弈元素</li>
<li>玩家是理性的，追求自身收益最大化</li>
</ul>
<h3 id="策略推理"><a href="#策略推理" class="headerlink" title="策略推理"></a>策略推理</h3><h4 id="占优策略-Dominant-Strategy"><a href="#占优策略-Dominant-Strategy" class="headerlink" title="占优策略 Dominant Strategy"></a>占优策略 Dominant Strategy</h4><p>无论对方采取什么策略，对己方都是最优的策略。即在上表中，无论玩家 2 选什么，玩家 1 选坦白都是更优的。因此，坦白是玩家 1 的占优策略。</p>
<p>在此基础上，玩家 2 的占优策略也是坦白，此时称坦白是玩家 2 的<strong>最优应对 Best-response</strong>。</p>
<h3 id="博弈的解"><a href="#博弈的解" class="headerlink" title="博弈的解"></a>博弈的解</h3><h4 id="纳什均衡-Nash-Equilibrium"><a href="#纳什均衡-Nash-Equilibrium" class="headerlink" title="纳什均衡 Nash Equilibrium"></a>纳什均衡 Nash Equilibrium</h4><p>任何玩家都不能通过独自改变策略而获益，即所有玩家都处在最佳应对的策略组合。</p>
<p>其数学定义为：给定一个策略组合 $a=(a_1,a_2,…,a_n)\in A_1\times A_2\times … \times A_n$，若 $r_1(a_1,a_2,…,a_n) \geq r_1(a_1’,a_2,…,a_n), \forall a_1’\in A_1$ 且  $r_2(a_1,a_2,…,a_n) \geq r_2(a_1,a_2’,…,a_n), \forall a_2’\in A_2$ 且 … 且  $r_n(a_1,a_2,…,a_n) \geq r_n(a_1,a_2,…,a_n’), \forall a_n’\in A_n$，那么策略组合 $a=(a_1,a_2,…,a_n)\in A_1\times A_2\times … \times A_n$ 是一个纳什均衡。</p>
<h4 id="混合策略纳什均衡-Mixed-Strategy-Nash-Equilibrium"><a href="#混合策略纳什均衡-Mixed-Strategy-Nash-Equilibrium" class="headerlink" title="混合策略纳什均衡 Mixed Strategy Nash Equilibrium"></a>混合策略纳什均衡 Mixed Strategy Nash Equilibrium</h4><p>混合策略是一个概率分布 $(p_1,p_2,…,p_n)$，其中 $p_i$ 表示选择动作 $i$ 的概率。</p>
<p>混合策略纳什均衡是一个混合策略组合，任何玩家都不能通过独自改变混合策略而使得自身期望收益变高，例如剪刀石头布博弈。</p>
<p><strong>任意博弈，必然存在一个混合策略纳什均衡。</strong></p>
<h4 id="协同问题"><a href="#协同问题" class="headerlink" title="协同问题"></a>协同问题</h4><p>在面临多个均衡时，如何选取均衡需要依靠玩家间的协同，例如创立通信机制，制定社会规则等等。</p>
<h3 id="合作博弈-Cooperative-Game"><a href="#合作博弈-Cooperative-Game" class="headerlink" title="合作博弈 Cooperative Game"></a>合作博弈 Cooperative Game</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">左</th>
<th style="text-align:center">右</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">左</td>
<td style="text-align:center">1， 1</td>
<td style="text-align:center">0， 0</td>
</tr>
<tr>
<td style="text-align:center">右</td>
<td style="text-align:center">0， 0</td>
<td style="text-align:center">1， 1</td>
</tr>
</tbody>
</table>
</div>
<h3 id="竞争博弈-Competitive-Game"><a href="#竞争博弈-Competitive-Game" class="headerlink" title="竞争博弈 Competitive  Game"></a>竞争博弈 Competitive  Game</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">石头</th>
<th style="text-align:center">剪子</th>
<th style="text-align:center">布</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">石头</td>
<td style="text-align:center">0， 0</td>
<td style="text-align:center">1， -1</td>
<td style="text-align:center">-1， 1</td>
</tr>
<tr>
<td style="text-align:center">剪子</td>
<td style="text-align:center">-1， 1</td>
<td style="text-align:center">0， 0</td>
<td style="text-align:center">1， -1</td>
</tr>
<tr>
<td style="text-align:center">布</td>
<td style="text-align:center">1， -1</td>
<td style="text-align:center">-1， 1</td>
<td style="text-align:center">0， 0</td>
</tr>
</tbody>
</table>
</div>
<h2 id="多智能体强化学习"><a href="#多智能体强化学习" class="headerlink" title="多智能体强化学习"></a>多智能体强化学习</h2><p>多智能体强化学习是现实中的博弈问题，具有状态、动作空间大，博弈元素不完全可知的问题。强化学习的学习目标包括了均衡、协同和合作三个部分。</p>
<p>参考论文：</p>
<p>Bi-level Actor-Critic for Multi-agent Coordination：<a href="https://arxiv.org/abs/1909.03510">https://arxiv.org/abs/1909.03510</a></p>
<p>Probabilistic Recursive Reasoning for Multi-Agent Reinforcement Learning：<a href="https://arxiv.org/abs/1901.09207">https://arxiv.org/abs/1901.09207</a></p>
<p>Multiagent Bidirectionally-Coordinated Nets: Emergence of Human-level Coordination in Learning to Play StarCraft Combat Games：<a href="https://arxiv.org/abs/1703.10069">https://arxiv.org/abs/1703.10069</a></p>
<p>Multi-Agent Actor-Critic for Mixed Cooperative-Competitive Environments：<a href="https://arxiv.org/abs/1706.02275">https://arxiv.org/abs/1706.02275</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title>模电学习笔记_双极型晶体管及其放大电路（1）</title>
    <url>/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本系列用于记录双极型晶体管及其放大电路相关的学习笔记</p>
<span id="more"></span>
<h1 id="1-基本知识点"><a href="#1-基本知识点" class="headerlink" title="1 基本知识点"></a>1 基本知识点</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h2 id="1-1-双极型晶体管"><a href="#1-1-双极型晶体管" class="headerlink" title="1.1 双极型晶体管"></a>1.1 双极型晶体管</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="一-晶体管的工作原理"><a href="#一-晶体管的工作原理" class="headerlink" title="一.晶体管的工作原理"></a>一.晶体管的工作原理</h3><ol>
<li><p><strong>晶体管具有放大作用所需的内部条件</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①基区很薄,且掺杂浓度很低;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②发射区的掺杂浓度远大于基区和集电区的掺杂浓度;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③集电结结面积大。</p>
</li>
<li><p><strong>晶体管具有放大作用所需的外部条件</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发射结正偏、集电结反偏。(NPN下，V~B~&gt;V~E~,V~B~&lt;V~E~)</p>
</li>
<li><p><strong>晶体管在放大状态下的载流子传输过程和3个电极电流表达式</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I~E~ = I~C~ + I~B~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; α = I~C~/I~E~ 取值0.95~0.99<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; β = I~C~/I~B~ 取值几十到几百</p>
</li>
<li><p><strong>根据电压判断三极管类型</strong>：</p>
<ol>
<li>B极的电压位于中间</li>
<li><p>E极与B极电压相差0.7V或0.2V  </p>
<p>2.1 若相差0.7V，为硅管<br>2.2 若相差0.2V，为锗管</p>
</li>
<li>PNP&amp;&amp;NPN<br>3.1 V~BE~为正，NPN<br>3.2 V~BE~为负，PNP</li>
</ol>
</li>
</ol>
<h3 id="二-晶体管的静态特性曲线"><a href="#二-晶体管的静态特性曲线" class="headerlink" title="二.晶体管的静态特性曲线"></a>二.晶体管的静态特性曲线</h3><ol>
<li><strong>共射输入特性曲线</strong><br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png)<br>类似于二极管的伏安特性,只是在V~ce~增加时,特性曲线会稍向右移动。</li>
<li><strong>共射输出特性曲线</strong><br>输出特性曲线分为四个工作区：<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438703321152.png)<br>（1）饱和区<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特点:i~C~受V~CE~影响,V~CE~略增,则i~C~增加很快。<br> &nbsp;<br> （2）放大区一曲线基本水平稍有上翘（原因：基区调宽效应）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特点:满足i~C~=βi~B~+I~CEO~,具有正向控制作用。由于基区宽度调制效应，曲线随v~CE~的增加而稍有上翘,其延长线交于厄尔利电压V~A~,用输出电阻r~ce~来表示其上翘程度为</li>
</ol>
<p><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/20200411161443456.png)<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438703350574.png)</p>
<p>&nbsp;<br> （3）截止区一近似为 i~B~=0以下的区域。<br>    &nbsp;<br>    （4)击穿区<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当v~CE~增大到一定值时，集电结发生雪崩击穿。</p>
<h3 id="三-温度对晶体管特性曲线的影响"><a href="#三-温度对晶体管特性曲线的影响" class="headerlink" title="三.温度对晶体管特性曲线的影响"></a>三.温度对晶体管特性曲线的影响</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>温度上升时</strong>，发射结正向电压降v~BE~ 减小，反向饱和电流I~CBO~和电流放大系数β增大，使得<strong>晶体管输入特性曲线左移，输出特性曲线上移且曲线间隔增大</strong>。<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438703739377.png)</p>
<h3 id="四-晶体管的参数"><a href="#四-晶体管的参数" class="headerlink" title="四.晶体管的参数"></a>四.晶体管的参数</h3><ol>
<li><strong>电流放大系数</strong><br>&nbsp;<br>1.1 共射直流电流放大系数<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/20200411162212705.png)<br>1.2 共射交流电流放大系数（又称短路电流放大系数）<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/20200411162313313.png)<br>1.3 共基直流电流放大系数<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/20200411162403104.png)<br>1.4 共基交流电流放大系数<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/20200411162423777.png)<br>★工程上，通常不再区分交流电流放大系数和直流电流放大系数，都用α和β表示。<br>&nbsp;<br>1.5 α与β的关系<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/20200411162714407.png)<img src="https://img-blog.csdnimg.cn/20200411162723892.png" alt=" "></li>
<li><strong>极间反向电流</strong><br>&nbsp;<br>2.1 反向饱和电流I~CBO~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I~CBO~表示发射极开路时集电结的反向饱和电流<br>2.2反向饱和电流I~EBO~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I~EBO~表示集电极开路时发射结的反向饱和电流<br>2.3穿透电流I~CEO~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I~CBO~表示基极开路时集电极和发射极之间的穿透电流<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/20200411163215402.png)</li>
<li><p><strong>极限参数</strong><br>&nbsp;<br>  3.1 集电极最大允许电流I~CM~（工作时应小于其值）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一般取β下降至最高值的2/3时所对应的集电极电流</strong><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>  3.2 反向击穿电压：（工作的最高值应小于其70％）<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V~(BR)CBO~:发射极开路，集电极与基极之间允许加的最高反向电压<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V~(BR)CEO~:基极开路，集电极与发射极之间允许加的最高电压<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V~(BR)EBO~:集电极开路，发射极与基极之间允许加的最高反向电压<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>3.3 集电极最大允许功率损耗P~CM~（工作时应小于其值，必要时加散热片、风冷、油冷等）<br>&nbsp;</p>
<ol>
<li><strong>高频参数</strong><br>&nbsp;</li>
</ol>
<p>4.1 共基截止频率f~α~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;α随工作频率的升高而下降，当<strong>降为α~0~的0.707倍时所对应的频率</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>4.2 共射截止频率f~β~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;β随工作频率的升高而下降，当<strong>降为β~0~的0.707倍时所对应的频率</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>4.3 特征频率f~T~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;β随工作频率的升高而下降，当<strong>降为1时所对应的频率</strong>。<br><img src="/2020/04/11/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(1" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387039331215.png)<br>准确：f~α~&gt;f~T~&gt;f~β~</p>
</li>
</ol>
<h1 id="2-易错点总结"><a href="#2-易错点总结" class="headerlink" title="2 易错点总结"></a>2 易错点总结</h1><p>1）有一PNP型三极管的发射结正偏、集电结正偏，则基极电位最低。</p>
<p>2）PNP型晶体管工作在饱和区时，发射结和集电结都正偏。</p>
<p>3）厄尔利（Early）电压反映的是晶体管的基区调宽效应。</p>
<p>4）两个三极管的β值的参数对称性看二者比值与1比较，越接近于1，参数对称性越好。</p>
<p>5）某放大电路在负载开路时的输出电压为12V，接入9k欧姆的负载电阻后输出  电压降为 9V，这说明放大电路的输出电阻为3k欧姆，若将负载电阻改为21k欧姆，则负载上的电流大小为0.5mA。</p>
<p>6）有两个放大倍数相同、输入和输出电阻不同的放大电路A和B，对同一个具有内阻的信号源电压进行放大，在负载开路的条件下测得A的输出电压大，这说明A的输入电阻大。</p>
<p>7）给放大电路设置合适直流工作点的目的是保证晶体管始终工作在放大区。</p>
<p>8）三极管的结构特点有基区很薄、发射区的掺杂浓度很大、集电结结面积大。</p>
<p>9）设有一NPN型三极管的发射结正偏、集电结反偏，则集电极电位最高，发射极电位最低。</p>
<p>10）放大电路的有效输入信号必须加在发射结上。</p>
<p>11）分析放大电路时，通常应该采用先直流后交流的方法。</p>
<p>12）双极型晶体管处于放大状态时，i~C~和i~b~是线性关系；i~C~和V~BE~是指数关系；Δi~C~和ΔV~BE~是线性关系。</p>
<p>13）通常的晶体三极管在集电极和发射极互换使用时，不再有较大的电流放大作用。</p>
<p>14）放大电路必须加上合适的直流电源才能正常工作。</p>
<p>15）在放大区内，共发射极输出特性曲线基本水平略有上翘，说明此时输出电压V~CE~变化时，输出电流i~C~基本不变。</p>
<p>&nbsp;<br>后置：<a href="https://lgc0208.github.io/2020/04/21/模电学习笔记_双极型晶体管(2">模电学习笔记_双极型晶体管及其放大电路（2）</a>/)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>模电</category>
      </categories>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>模电学习笔记_双极型晶体管及其放大电路（2）</title>
    <url>/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前置：<a href="https://lgc0208.github.io/2020/04/11/模电学习笔记_双极型晶体管(1">双极型晶体管及其放大电路（1）</a>/)</p>
<span id="more"></span>
<h1 id="一-基本知识点"><a href="#一-基本知识点" class="headerlink" title="一.基本知识点"></a>一.基本知识点</h1><h3 id="补充：集成电路中元器件的特点"><a href="#补充：集成电路中元器件的特点" class="headerlink" title="补充：集成电路中元器件的特点"></a>补充：集成电路中元器件的特点</h3><p>1.单个元件的参数精度不高，且受温度影响较大，但参数对称性及温度对称性较好。批量间差异较大</p>
<p>2.集成电路工艺制造出的电阻阻值受限，应尽量避免使用高阻值电阻。</p>
<p>3.无电感元件</p>
<p>4.不适于制造几十皮法以上的电容，电路中应尽量避免采用或少用电容</p>
<h2 id="2-2-放大电路的基本知识"><a href="#2-2-放大电路的基本知识" class="headerlink" title="2.2 放大电路的基本知识"></a>2.2 放大电路的基本知识</h2><h3 id="2-2-1-放大电路的组成"><a href="#2-2-1-放大电路的组成" class="headerlink" title="2.2.1 放大电路的组成"></a>2.2.1 放大电路的组成</h3><p>1.<strong>信号的放大</strong>：输出量与输入量始终保持线性关系，电路基本不会产生线性失真和非线性失真。</p>
<p>2.<strong>放大电路</strong>：晶体管<strong>工作在放大区</strong>，<strong>输入为（中频）小信号</strong>。</p>
<p>3.共射放大电路的原理图：<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v~s~：待放大交流小信号，常以正弦波作为测试信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V~BB~及R~B~：提供合适的输入回路静态工作点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R~C~：输出负载。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V~CC~：与R~C~一起提供输出回路合适的静态工作点。</p>
<p>4.<strong>直流（静态）工作点的设置</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用直流电压V~BB~和V~CC~以及电阻R~B~、R~C~，<strong>使晶体管始终工作在放大区</strong>，并各电极电流、极间电压均有合适的数值——称之为设置直流工作点或静态工作点，一般用“Q”表示，<strong>提供静态工作点的电路称为放大电路的偏置电路</strong>。<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438704164602.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直流分量：<strong>I~BQ~﹑I~CQ~﹑V~BEQ~和V~CEQ~表示晶体管静态工作的电流和电压</strong>（静态工作点）。</p>
<p>5.合适的直流（静态）工作点：（交流信号叠加在直流工作点上）<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）晶体管必须<strong>在交流信号的整个周期内都工作在放大区</strong>，使晶体管的<strong>发射结始终正偏，且始终有电流流入基极；</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;（2）集电极电源电压V~CC~足够高（使V~CE~足够大），并选择合适的R~C~，保证集电极电流最大时，<strong>晶体管的集电结依然反偏</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;（3）合适的静态工作点应保证不产生截止失真或饱和失真，且使电路的功耗较低。</p>
<p>6.交流信号的放大<br>&nbsp;&nbsp;&nbsp;&nbsp;交流信号叠加在直流（静态）工作点之上：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v~BE~（交直流分量和）  =V~BEQ~（直流分量）+v~be~（交流分量）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i~B~ （交直流分量和） =I~BQ~（直流分量） +i~b~ （交流分量）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i~C~ （交直流分量和） =I~CQ~ （直流分量） +i~c~（交流分量）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v~CE~ (交直流分量和） =V~CEQ~（直流分量） +v~ce~（交流分量）<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>合适的直流Q点</strong>是交流信号无失真放大的基本条件。</p>
<p>7.<strong>放大电路的组成的基本原则</strong><br>（1）直流偏置电路提供<strong>合适的静态工作点Q</strong>，使晶体管始终工作于放大区；<br>（2）<strong>交流输入信号能够</strong>较少损失且无失真地<strong>加至放大电路的输入端</strong>；<br>（3）<strong>被放大的交流输出信号能够较少损失且无失真送至负载</strong>，以实现信号（电压、电流或功率）的放大。</p>
<p>8.放大的本质<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放大电路的基本功能是将微弱的电信号进行无失真放大（失真尽量小）。输出信号中的能量来自电源（放大电路从电源中获得能量，按照输入信号成比例复制出输出信号）。<strong>晶体管是能够控制能量和转换能量的有源元件。</strong></p>
<h3 id="2-2-2-放大电路主要的性能指标"><a href="#2-2-2-放大电路主要的性能指标" class="headerlink" title="2.2.2 放大电路主要的性能指标"></a>2.2.2 放大电路主要的性能指标</h3><p>1.输入阻抗和输出阻抗<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放大电路可看成是一个双端口网络，我们主要关心它的输入、输出以及转移特性等。<br> <img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421152538753.png)</p>
<p> （1）输入阻抗：从输入端看入的等效阻抗(不含信号源内阻，但包含负载电阻的影响）<br> <img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421154231743.png)<br> <img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438704204815.png)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于信号源为电压源： Z~i~ （R~i~）越大，R~S~上的压降就越小，输入电压损失越小。</p>
<p> （2）输出阻抗：当R~L~开路，输入信号源短路（保留内阻R~S~)时从输出端看入的阻抗。<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ①当中频时Z~o~可用R~o~替代（一般不声明时，指中频）<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ②输出阻抗Zo （中频用Ro）越小，在Zo上的压降越小，输出的电压损失越小。</p>
<p>2.增益<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当不考虑信号源内阻时，对应输入电流、输入电压、输出电流、输出电压4个物理量有4种传输增益<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421153219807.png)<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421153131929.png)<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/2020042115315474.png)<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421153206682.png)<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt="功率增益：">/2020042115334622.png)<br>3.通频带<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 放大电路中存在耦合电容、电感、分布电容、晶体管结电容，在不同频率下输出和输入间的增益、相位不同。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①上截止频率fH ：幅频特性在高频段比中频下降3dB点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②下截止频率fL ：幅频特性在低频段比中频下降3dB点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③中频指的是在幅频特性和相频特性中，增益的大小和相位基本不随频率发生变化的部分。<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421153411596.png)<br>4.非线性失真<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于晶体管、场效应管的输入输出曲线是非线性的，当输入信号为单一正弦信号时，输出信号会含有其它频率成分，产生非线性失真。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在静态工作点附近，只有放大电路的输入信号足够小时，才能保证非线性失真也较小。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出波形中谐波成分总量与基波成分之比称为非线性失真系数N。设基波幅值为A~1~，各谐波幅值为A~2~、A~3~、……，则<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421154018808.png)</p>
<p>5.最大输出幅度<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指非线性失真系数不超过额定值的输出信号最大值。</p>
<p>6.最大输出功率与效率<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①最大输出功率：非线性失真系数达到某值时对应的最大输出有效电压和最大输出有效电流的乘积。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②效率：输出功率P~o~与电源提供的平均功率P~DC~之比<img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421154105276.png)</p>
<h2 id="2-3-基本共射放大电路的工作原理及分析方法"><a href="#2-3-基本共射放大电路的工作原理及分析方法" class="headerlink" title="2.3 基本共射放大电路的工作原理及分析方法"></a>2.3 基本共射放大电路的工作原理及分析方法</h2><h3 id="2-3-1-基本共射放大电路的组成及工作原理"><a href="#2-3-1-基本共射放大电路的组成及工作原理" class="headerlink" title="2.3.1 基本共射放大电路的组成及工作原理"></a>2.3.1 基本共射放大电路的组成及工作原理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输入电压通过RB加到BE结，输出电压取自集电极（与地之间）。<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421154437266.png)</p>
<h3 id="2-3-2-直流通路与交流通路"><a href="#2-3-2-直流通路与交流通路" class="headerlink" title="2.3.2 直流通路与交流通路"></a>2.3.2 直流通路与交流通路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在放大电路中，直流量和交流信号是共存的，在分析放大电路时，可分开考虑。应遵循“<strong>先静态，后动态</strong>”的原则。</p>
<p>一.直流通路是在直流电源作用下直流电流流经的通路，用于分析直流参数（Q点）。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>直流通路图构成原则：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①<strong>电容</strong>视为<strong>开路</strong>；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<strong>电感</strong>线圈视为<strong>短路</strong>（一般忽略线圈电阻）；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③<strong>交流电压信号源</strong>视为<strong>短路</strong>，保留其内阻；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④<strong>交流电流信号源</strong>视为<strong>开路</strong>，保留其内阻。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤工作在击穿区的稳压二极管，可等效为等值的直流电压源。（工作在正向工作区的普通二极管，可等效为0.7V（硅）的直流电压源）</p>
<p>二.交流通路是交流输入信号作用下交流信号流经的通路，用于分析动态（交流）参数。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>交流通路图构成原则</strong>（<strong>在中频区</strong>）：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①<strong>容量大的电容</strong>（如耦合电容、旁路电容）视为交流<strong>短路</strong>；<strong>容量小的电容</strong>（如晶体管结电容）视为交流<strong>开路</strong>；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<strong>感抗大的电感</strong>线圈视为交流<strong>开路</strong>；<strong>感抗小的电感</strong>线圈视为交流<strong>短路</strong>；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③<strong>直流电压源视为交流短路</strong>，如有内阻则保留其内阻。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④<strong>直流电流源视为交流开路</strong>，如有内阻则保留其内阻。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤工作在击穿区的稳压二极管，交流短路。（工作在正向工作区的普通二极管，若不考虑其动态电阻可视为交流短路）</p>
<h3 id="2-3-3-图解分析法"><a href="#2-3-3-图解分析法" class="headerlink" title="2.3.3 图解分析法"></a>2.3.3 图解分析法</h3><h4 id="1-静态工作点分析"><a href="#1-静态工作点分析" class="headerlink" title="1.静态工作点分析"></a>1.静态工作点分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;（1）近似估算法求静态工作点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" \">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387047494420.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先画出直流等效电路：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421155522448.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已知V~CC~、β、R~B~、R~C~，根据直流通路可知：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421155400800.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若晶体管工作在放大区，则有：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421155424513.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若无特殊说明，则硅管V~BEQ~=0.7V，锗管V~BEQ~=0.3V</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（2）用图解分析法确定静态工作点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意：图解法分析静态工作点，<strong>必须已知三极管的输入输出特性曲线</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①画出直流通路<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②在已知的输入特性曲线上作出输入回路的直流负载线。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③在已知的输出特性曲线上作出输出回路的直流负载线。<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387048855824.png)</p>
<h4 id="2-动态图解分析"><a href="#2-动态图解分析" class="headerlink" title="2.动态图解分析"></a>2.动态图解分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;交流负载线<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①画出交流通路<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421160036112.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②在已知的输出特性曲线上作出输出回路的交流负载线。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421160056152.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可令i~C~=0画出交流负载线<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421160148992.png)</p>
<h4 id="3-工作点的动态范围"><a href="#3-工作点的动态范围" class="headerlink" title="3.工作点的动态范围"></a>3.工作点的动态范围</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;动态范围：在不出现饱和和截止失真这两种非线性失真的情况下，<strong>放大电路能够输出的最大信号的幅度</strong>。<br>取值为：<br><img src="/2020/04/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(2" alt=" ">/20200421160425893.png)</p>
<h1 id="二-易错点总结"><a href="#二-易错点总结" class="headerlink" title="二.易错点总结"></a>二.易错点总结</h1><p>1）在集成电路中，应尽量避免使用过高阻值的电阻。</p>
<p>2）若信号源为电压源，则放大电路的输入电阻越大越好。</p>
<p>3）若放大电路采用电流源形式输出，则输出电阻越大越好。</p>
<p>4）处于放大状态的双极型晶体管的集电极输出电阻：交流电阻大于直流电阻。</p>
<p>5）若信号源为电流源，多级放大电路的输入级适宜采用共基组态电路。</p>
<p>6）饱和失真和截止失真都是非线性失真。</p>
<p>7）若某NPN单管共射放大电路的工作位于其交流负载线的中点，则可获得最大不失真输出。</p>
<p>8）可以通过减小输入信号的幅度来减小甚至消除饱和失真和截止失真。</p>
<p>9）交流负载线和直流负载线分别应用不同的场合，不可混用。</p>
<p>10）大部分情况下，交流负载线斜率的绝对值要大于直流负载线斜率的绝对值。</p>
<p>11）直流负载线和交流负载线都经过Q点。</p>
<p>12）晶体管特性的变化不会对直流负载线产生影响。</p>
<p>后置：<a href="https://lgc0208.github.io/2020/04/22/模电学习笔记_双极型晶体管(3">模电学习笔记_双极型晶体管及其放大电路（3）</a>/)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>模电</category>
      </categories>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>模电学习笔记_双极型晶体管及其放大电路（3）</title>
    <url>/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前置：<a href="https://lgc0208.github.io/2020/04/21/模电学习笔记_双极型晶体管(2">模电学习笔记_双极型晶体管及其放大电路（2）</a>/)</p>
<span id="more"></span>
<h1 id="一-基本知识点"><a href="#一-基本知识点" class="headerlink" title="一.基本知识点"></a>一.基本知识点</h1><h3 id="补充：图解法分析动态范围和失真类型"><a href="#补充：图解法分析动态范围和失真类型" class="headerlink" title="补充：图解法分析动态范围和失真类型"></a>补充：图解法分析动态范围和失真类型</h3><h4 id="1-动态范围"><a href="#1-动态范围" class="headerlink" title="1.动态范围"></a>1.动态范围</h4><p><img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png)<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438705158192.png)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，为了使得晶体管不进入饱和区和截止区，I~CQ~和V~CEQ~应该满足条件：<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/20200422213136955.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438705215855.png)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，可<strong>通过图中的交流负载线读出</strong>，输出电压最大不失真幅度为<strong>V~OM~</strong>；集电极电流的最大幅值<strong>i~cm~</strong>；<br><strong>基极正弦电流最大幅值＝I~BQ~；集电极正弦电流最大幅值=I~CQ~</strong></p>
<h4 id="2-失真类型"><a href="#2-失真类型" class="headerlink" title="2.失真类型"></a>2.失真类型</h4><p><img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438705233807.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;饱和失真：i顶部失真，v底部失真；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;截止失真：i底部失真，v顶部失真。</p>
<h3 id="2-3-4-等效电路分析法"><a href="#2-3-4-等效电路分析法" class="headerlink" title="2.3.4 等效电路分析法"></a>2.3.4 等效电路分析法</h3><p>1.混合π模型（考虑结电容后的晶体管模型）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;混合π模型是在某Q点下的交流小信号模型（微变等效模型），<strong>只能用于</strong>晶体管在<strong>放大状态</strong>下的<strong>交流小信号分析</strong>！<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）简化的混合π模型<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①简化的高频混合π模型（r~b’c~较大，忽略，结电容对于高频信号不能忽略）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/2020042222195089.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②简化的<strong>中低频混合π模型</strong>（集电结反偏，r~b’c~较大，忽略，结电容对于中低频信号容抗很大，开路）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/20200422222050947.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③中低频混合π模型参数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·r~bb’~由手册给出；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/20200422223619903.png)；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·跨导g~m~表征了v~b’e~对集电极电流的控制作用<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·r~ce~是输出电阻，描述了基区宽度调制效应的影响，数值在几十到几百千欧，多数情况可以忽略。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④中低频H参数模型<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·使用输入量i~b~作为控制变量</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/20200422224217552.png)    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/2020042222423477.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt="百千欧，多数情况可以忽略。">/2020042222405365.png)<br>2.模型的应用<br>&nbsp;&nbsp;&nbsp;&nbsp;★分析高频电路时（交流信号的频率f &gt; f~T~/3时)，必须考虑极间电容C~b’e~和C~b’c~的影响，晶体管使用高频混合π模型（ C~b’e~和C~b’c~电容值将在后续章节给出）；<br>&nbsp;&nbsp;&nbsp;&nbsp;★分析<strong>中频电路</strong>时（交流信号的频率f &lt; f~T~/3时) ，极间电容C~b’e~和C~b’c~的影响可以忽略，也可忽略电路中的耦合电容、旁路电容的影响，晶体管可使用<strong>中低频混合π模型（或H参数模型）</strong></p>
<p>3.用混合π模型（H参数模型）计算放大电路的动态性能指标<br>&nbsp;&nbsp;&nbsp;&nbsp;用混合π模型分析放大电路的步骤如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）<strong>确定</strong>放大电路的<strong>静态工作点Q</strong>；<br>&nbsp;&nbsp;&nbsp;&nbsp;（2）<strong>求</strong>出Q点处的<strong>混合π模型参数</strong>r~b’e~和g~m~（或H参数的r~be~）；<br>&nbsp;&nbsp;&nbsp;&nbsp;（3）<strong>画出</strong>放大电路的<strong>交流通路</strong>，将电路中的晶体管T<strong>用低频混合π模型（或H参数模型）代替</strong>，即得到小信号交流等效电路（微变等效电路）；<br>&nbsp;&nbsp;&nbsp;&nbsp;（4）<strong>求解</strong>放大电路的<strong>交流性能指标</strong>：A~v~，A~i~，R~i~，R~o~等。</p>
<p>4.等效电路法与图解法的比较<br>&nbsp;&nbsp;&nbsp;&nbsp;①<strong>图解法</strong>比较<strong>直观</strong>，图解法一般多适用于分析输入幅值比较大而工作频率不太高时的情况。实际应用中，<strong>多用于分析Q点位置、最大不失真输出电压和失真情况。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;②<strong>等效电路法</strong>比较方便，<strong>适合于小信号电路的分析</strong>，也适合于复杂放大电路的分析，但不够形象直观。</p>
<h2 id="2-4-静态工作点的稳定"><a href="#2-4-静态工作点的稳定" class="headerlink" title="2.4 静态工作点的稳定"></a>2.4 静态工作点的稳定</h2><h3 id="2-4-1静态工作点稳定的必要性"><a href="#2-4-1静态工作点稳定的必要性" class="headerlink" title="2.4.1静态工作点稳定的必要性"></a>2.4.1静态工作点稳定的必要性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了保证放大电路的稳定工作，必须有合适的、稳定的静态工作点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于固定偏置电路的静态工作点，除与电源电压偏置电阻有关外，还与<strong>V~BE~、β和I~CEO~</strong>有关，这<strong>三个参数随温度而变化</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/2020042222593087.png)</p>
<h3 id="2-4-2分压式负反馈偏置电路"><a href="#2-4-2分压式负反馈偏置电路" class="headerlink" title="2.4.2分压式负反馈偏置电路"></a>2.4.2分压式负反馈偏置电路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.电路组成及Q点稳定原理：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）电路组成：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387054108716.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）Q点稳定原理：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;温度升高，I~C~和I~E~增加，使得R~E~上的电压增加，V~BE~下降，导致I~B~下降，从而I~C~下降。（I~B~∝V~BE~）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/20200422231144280.png)     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/20200422231234404.png)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.静态工作点计算<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）静态工作点的近似估算<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/20200422233121895.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）静态工作点的精确计算<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将输入等效为电压源V~BB~和等效电阻R~B~，进行电路分析</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.交流指标A~v~、A~vs~、R~i~、R~o~的计算<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先画出交流通路图，进而画出微变等效电路。（先考虑未接C~E~，将晶体管用混合π模型或H参数模型代替，得到微变等效电路，并忽略晶体管的r~ce~）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.总结<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发射极电阻R~E~的存在会使电路产生直流和交流负反馈：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·对于直流，能够稳定电路的静态工作点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;·对于交流，会改变电路的参数，能够稳定增益、展宽通频带等（原理将会在后续章节详细介绍）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当电阻RE的交流负反馈作用较大时（且不加旁路电容）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/22/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(3" alt=" ">/20200422233748201.png)<br>后置：<a href="https://lgc0208.github.io/2020/04/24/模电学习笔记_双极型晶体管(4">模电学习笔记_双极型晶体管及其放大电路（4）</a>/)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>模电</category>
      </categories>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>模电学习笔记_双极型晶体管及其放大电路（4）</title>
    <url>/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前置：<a href="https://lgc0208.github.io/2020/04/22/模电学习笔记_双极型晶体管(3">模电学习笔记_双极型晶体管及其放大电路（3）</a>/)</p>
<span id="more"></span>
<h1 id="一-基本知识点"><a href="#一-基本知识点" class="headerlink" title="一.基本知识点"></a>一.基本知识点</h1><h2 id="2-5-晶体管单管放大电路的三种基本组态"><a href="#2-5-晶体管单管放大电路的三种基本组态" class="headerlink" title="2.5 晶体管单管放大电路的三种基本组态"></a>2.5 晶体管单管放大电路的三种基本组态</h2><h3 id="2-5-1-共集放大电路（射极输出器、射极跟随器）"><a href="#2-5-1-共集放大电路（射极输出器、射极跟随器）" class="headerlink" title="2.5.1 共集放大电路（射极输出器、射极跟随器）"></a>2.5.1 共集放大电路（射极输出器、射极跟随器）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;1.主要<strong>特点</strong>：高输入阻抗，低输出阻抗，同相放大，<strong>电压增益近似为1</strong>。（射极跟随器）<br>&nbsp;&nbsp;&nbsp;&nbsp;2.应用：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）<strong>作为多级放大的输入级</strong>，有较高的输入阻抗，减小输入电压的损失；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）作为多级放大的中间隔离（<strong>缓冲</strong>）级，减小后级较小的输入阻抗对前级增益的影响；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）<strong>作为多级放大的输出级</strong>，提供较小的输出阻抗，提高带负载能力。</p>
<h3 id="2-5-2-共基放大电路"><a href="#2-5-2-共基放大电路" class="headerlink" title="2.5.2 共基放大电路"></a>2.5.2 共基放大电路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;1.主要特点：同相放大，电压增益数值与共射相同，输入电阻比共射小，输出电阻和共射相同。频带宽。<br>&nbsp;&nbsp;&nbsp;&nbsp;2.应用：宽频带放大。</p>
<h3 id="2-5-3-晶体管单管放大电路三种基本组态的比较"><a href="#2-5-3-晶体管单管放大电路三种基本组态的比较" class="headerlink" title="2.5.3 晶体管单管放大电路三种基本组态的比较"></a>2.5.3 晶体管单管放大电路三种基本组态的比较</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>共射</th>
<th>共集</th>
<th>共基</th>
</tr>
</thead>
<tbody>
<tr>
<td>相位</td>
<td>反相</td>
<td>同相</td>
<td>同相</td>
</tr>
<tr>
<td>电压增益</td>
<td>大</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>电流增益</td>
<td>大</td>
<td>大</td>
<td>小</td>
</tr>
<tr>
<td>放大特性</td>
<td>电压、电流都放大</td>
<td>只放大电流</td>
<td>只放大电压</td>
</tr>
<tr>
<td>输入输出阻抗</td>
<td>R~i~中，R~o~中</td>
<td>R~i~大，R~o~小</td>
<td>R~i~小，R~o~大</td>
</tr>
<tr>
<td>高频特性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>主要用途</td>
<td>功率增益最大，用途最广泛</td>
<td>输入级、输出级和缓冲级</td>
<td>多用于高频电路</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-6-电流源电路及其应用"><a href="#2-6-电流源电路及其应用" class="headerlink" title="2.6 电流源电路及其应用"></a>2.6 电流源电路及其应用</h2><p>前言：<br>&nbsp;&nbsp;&nbsp;&nbsp;1.集成电路大量使用电流源电路的原因：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）用电流源代替电阻对电路进行直流偏置，既稳定可靠，又可以减小芯片面积；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）由于<strong>电流源输出电阻很大</strong>，用电流源<strong>代替晶体管的集电极电阻R~C~</strong>，<strong>可以获得极大的电压增益</strong>，而<strong>工作点电流不用增高</strong>；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2.对电流源的主要要求：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）能够输出符合要求的直流电流；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）输出电阻尽可能大；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）对温度的灵敏度低；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（4）受电源电压等因素影响小。</p>
<h3 id="2-6-1-常见的电流源电路"><a href="#2-6-1-常见的电流源电路" class="headerlink" title="2.6.1 常见的电流源电路"></a>2.6.1 常见的电流源电路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp; 1.基本镜像电流源<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）条件：<strong>两只晶体管完全对称</strong>；<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4" alt=" ">/20200424133115639.png)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当β &gt;&gt; 2时，有<strong>I~o~与I~R~近似镜像（相等）</strong>，恒流源输出电阻近似于R~CE2~：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4" alt=" ">/20200424133254460.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）优点：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①简单、元件小；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②镜像电流源T~1~对T~2~具有一定的温度补偿作用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）缺点：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①I~0~做不到很小，因为在集成电路中难以制作大电阻R；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②I~o~受V~CC~影响大；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③R~o~不够大；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④镜像精度不高，I~o~与I~R~的镜像精度决定于晶体管的β；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤I~o~的温度稳定性不是很好，晶体管的V~BE~和β军队温度敏感。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2.两种改进型基本恒流源电路<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;（a）：带有缓冲管的镜像电流源电路<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①利<strong>用T~3~提供了T~1~、T~2~的基极电流</strong>；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 在<strong>β不够大时，I~o~与I~R~间的差别也较小</strong>。输出电阻同基本恒流源：r~ce2~；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ <strong>R~E~的作用是增大I~EQ3~的值</strong>，避免I~EQ3~较小导致的β不够大及I~CEO3~的影响。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（b）：比例恒流源（带射极电阻的镜像电流源）（R~E1~≠R~E2~）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4" alt=" ">/20200424134519743.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过调节R~E1~或R~E2~可以改变电流源的值或I~o~和I~R~的比例。该电流源有较大的输出电阻。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;3.威尔逊电流源<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）电路图：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4" alt=" ">/2020042413503611.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）威尔逊电流源<strong>利用负反馈原理构成</strong>，具有良好的温度特性及很高的输出电阻。假定由于温度或负载变化使I~o~加大，则它的镜像电流I~R~跟着增加，使V~BE3~下降，从而牵制了I~o~的增加。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;4.微电流源<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）电路图：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4" alt=" ">/20200424141121872.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）说明：电阻<strong>R~E~具有负反馈作用</strong>，能够<strong>稳定输出电流</strong>；由于T~2~的BE结电压小于T~1~的BE结电压，所以I~o~较小（设T1、T2的特性相同）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;5.多电流源<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过一个基准电流源为多个三极管提供基准电流，可构成多路电流源，图中一个基准电流I~R~可获得多个恒定电流I~o2~、 I~o2~、I~o3~…。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4" alt=" ">/20200424141902286.png)</p>
<h3 id="2-6-2-电流源的主要作用"><a href="#2-6-2-电流源的主要作用" class="headerlink" title="2.6.2 电流源的主要作用"></a>2.6.2 电流源的主要作用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;1.作为直流偏置电路（<strong>获得稳定的偏置电流</strong>）：T~2~管既是恒流源T~1~的镜像，又作为共射放大电路的晶体管，I~CQ~＝I~O~，可令R~1~=R~2~，调节R可调节I~CQ~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4" alt=" ">/20200424142132986.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;2.作为<strong>有源负载</strong>（获得较高的交流负载阻抗）（也作为偏置电路的一部分）：调节T~1~基极直流电位可获得合适的工作点（主要获得V~CEQ~）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/24/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(4" alt=" ">/20200424142329658.png)</p>
<h1 id="二-易错点总结"><a href="#二-易错点总结" class="headerlink" title="二.易错点总结"></a>二.易错点总结</h1><p>1）对于共集电极电路：<br>&nbsp;&nbsp;&nbsp;&nbsp;①电压增益小于1但接近于1<br>&nbsp;&nbsp;&nbsp;&nbsp;②当从基极看过去时，能够将发射极的交流负载电阻变为原来的(β+1)倍<br>&nbsp;&nbsp;&nbsp;&nbsp;③具有很强的电流驱动能力<br>&nbsp;&nbsp;&nbsp;&nbsp;④可作为缓冲级使用</p>
<p>2）对于共基极电路：<br>&nbsp;&nbsp;&nbsp;&nbsp;①共基电路输入电阻较小<br>&nbsp;&nbsp;&nbsp;&nbsp;②共基电路的高频特性优于共发射极电路<br>&nbsp;&nbsp;&nbsp;&nbsp;③共基极电路的电压增益是同相的</p>
<p>3）用恒流源作为放大电路有源负载的好处是可以在电源电压不变的情况下，获得较高的电路增益、合适的静态工作点、较宽的动态范围</p>
<p>4）在晶体三极管的三种组态中，既可放大电压也可放大电流的是共射组态，只能放大电压的是共基组态，只能放大电流的是共集组态。</p>
<p>5）由晶体三极管放大电路的直流通路不可以判断晶体三极管的工作组态。</p>
<p>后置：<a href="https://lgc0208.github.io/2020/04/27/模电学习笔记_双极型晶体管(5">模电学习笔记_双极型晶体管及其放大电路（5）</a>/)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>模电</category>
      </categories>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>模电学习笔记_双极型晶体管及其放大电路（5）</title>
    <url>/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前置：<a href="https://lgc0208.github.io/2020/04/24/模电学习笔记_双极型晶体管(4">模电学习笔记_双极型晶体管及其放大电路（4）</a>/)</p>
<span id="more"></span>
<h1 id="一-基本知识点"><a href="#一-基本知识点" class="headerlink" title="一.基本知识点"></a>一.基本知识点</h1><h2 id="2-7-差分放大电路"><a href="#2-7-差分放大电路" class="headerlink" title="2.7 差分放大电路"></a>2.7 差分放大电路</h2><p>1.基本介绍：差分（差动）放大电路，简称差放，基本特点是放大差模信号、抑制共模信号（抑制零点漂移或温度漂移）。 </p>
<p>2.零点漂移现象（也称温度漂移现象）：△V~i~=0，△V~o~≠0</p>
<p>3.零点漂移现象产生原因：<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）温度变化<br>&nbsp;&nbsp;&nbsp;&nbsp;（2）直流电源波动<br>&nbsp;&nbsp;&nbsp;&nbsp;（3）元器件老化。<br>&nbsp;&nbsp;&nbsp;&nbsp;其中晶体管的特性对温度敏感是主要原因。</p>
<p>4.克服温漂的方法<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）引入直流负反馈（例：分压式负反馈偏置）；<br>&nbsp;&nbsp;&nbsp;&nbsp;（2）使用温度补偿电路（如：热敏电阻等，或恒温槽）；<br>&nbsp;&nbsp;&nbsp;&nbsp;（3）差分放大电路</p>
<h3 id="2-7-1-差动放大器的组成"><a href="#2-7-1-差动放大器的组成" class="headerlink" title="2.7.1 差动放大器的组成"></a>2.7.1 差动放大器的组成</h3><p>1.电路基本组成:<br>&nbsp;&nbsp;&nbsp;&nbsp;以成倍的原件数量构成对称结构—获得抑制温漂、抑制共模信号、放大差模信号的目的<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png)</p>
<p>2.抑制温漂原理：<br>&nbsp;&nbsp;&nbsp;&nbsp;电路两侧完全对称，当v~i1~=v~i2~时，v~o1~＝v~o2~，v~o~＝v~o1~-v~o2~＝0.当温度变化时，△v~o1~＝△v~o2~</p>
<p>3.抑制共模信号原理：<br>&nbsp;&nbsp;&nbsp;&nbsp;共模信号：输入大小、方向相同的信号<br>&nbsp;&nbsp;&nbsp;&nbsp;v~i1~＝v~i2~时，A~vc~＝v~o~/v~i~＝0<br>&nbsp;&nbsp;&nbsp;&nbsp;（温度变化导致的每个单端输出的变化，可等效为给输入加了一个共模信号）</p>
<p>4.放大差模信号原理：<br>&nbsp;&nbsp;&nbsp;&nbsp;差模信号：输入大小相同，方向相反的信号<br>&nbsp;&nbsp;&nbsp;&nbsp;当v~i1~＝-v~i2~，则差模输出分量v~o1~＝-v~o2~，v~o~＝2v~o1~,<br>&nbsp;&nbsp;&nbsp;&nbsp;差模电压放大倍数A~vd~＝v~o~/（v~i1~-v~i2~）＝v~o1~/v~i1~（为单级共射电路的增益，根据电压方向标注，实际为负值）</p>
<p>5.共模抑制比K~CMR~（CMRR）的定义<br>&nbsp;&nbsp;&nbsp;&nbsp;CMRR - Commom Mode Rejection Ratio<br>&nbsp;&nbsp;&nbsp;&nbsp;计算公式：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://img-blog.csdnimg.cn/20200425160453319.png" alt=" "></p>
<p>6.双电源长尾式差放<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）负电源-V~EE~可加大输出信号的动态范围；<br>&nbsp;&nbsp;&nbsp;&nbsp;（2）R~E~可稳定工作点、大大降低共模增益，不影响差模增益；<br>&nbsp;&nbsp;&nbsp;&nbsp;（3）省去电阻R~1~和R~B~。<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5" alt=" ">/20200425160925207.png)</p>
<p>7.恒流源射极偏置式差放<br>&nbsp;&nbsp;&nbsp;&nbsp;使用电流源作为发射极的偏置，可进一步提高射极的动态电阻，提高共模抑制比。<br><img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438706010153.png)</p>
<p>8.差模信号和共模信号<br>&nbsp;&nbsp;&nbsp;&nbsp;任意输入大小、极性任意的两个信号，可以分解为：<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5" alt=" ">/20200425162013975.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5" alt=" ">/20200425162125785.png)<br>9.差分放大电路的直流传输特性<br><img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5" alt=" ">/20200427215724742.png)<img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438706102818.png)<br>10.小结<br>&nbsp;&nbsp;&nbsp;&nbsp;差放特点：<br>&nbsp;&nbsp;&nbsp;&nbsp;①差模输入电压为零时，I~C1~≈I~C2~≈I~EE~/2<br>&nbsp;&nbsp;&nbsp;&nbsp;②加入差模电压后，集电极电流（电压）一增一减，由于差摸放大作用，增减的数量相同</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;差放有较大的差模放大能力，具有较好共模抑制能力，由于温度的影响造成的工作点漂移，可认为是共模输入信号，所以有较好的零点漂移抑制能力。<br>&nbsp;&nbsp;&nbsp;&nbsp;接入负反馈电阻RE，可有效扩大输入的线性范围，但增益将下降。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(5" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387061341510.png)</p>
<h3 id="2-7-2-差放的小信号分析"><a href="#2-7-2-差放的小信号分析" class="headerlink" title="2.7.2 差放的小信号分析"></a>2.7.2 差放的小信号分析</h3><p>1.差模交流指标计算<br>|  | 增益 |输入电阻|输出电阻|<br>|—|—|—|—|<br>| 半电路的基准参数 | A~v~ |R~i~|R~o~|<br>|输入方式（单端/双端）|无关|2R~i~|无关|<br>|输出方式（单端）|±A~v~/2|2R~i~|R~o~|<br>|输出方式（双端）|A~v~|2R~i~|2R~o~|</p>
<p>2.共模交流指标计算<br>&nbsp;&nbsp;&nbsp;&nbsp;①电压增益：理想对称时，双端输出的A~vc~=0<br>&nbsp;&nbsp;&nbsp;&nbsp;②输出电阻：双端 R~oc~≈2R~C~；单端 R~oc~≈R~C~<br>&nbsp;&nbsp;&nbsp;&nbsp;③共模抑制比：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双端输出时，K~CMR~=∞<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单端输出时，K~CMR~=|A~vD1~/A~vC1~|≈βR~EE~/r~be~</p>
<h3 id="2-7-3-有源负载差分放大电路"><a href="#2-7-3-有源负载差分放大电路" class="headerlink" title="2.7.3 有源负载差分放大电路"></a>2.7.3 有源负载差分放大电路</h3><p>有源负载的作用：<br>（1）增大交流负载阻抗，提高差模增益<br>（2）实现双端输出到单端输出无增益损失的变换</p>
<h1 id="二-易错点总结"><a href="#二-易错点总结" class="headerlink" title="二.易错点总结"></a>二.易错点总结</h1><p>1）一般来说，源电压增益将小于电压增益。</p>
<p>2）纯阻负载的差分放大电路的<strong>差模电压放大倍数与输出信号是单端还是双端输出有关</strong>。</p>
<p>3）差分放大电路的基本特性是<strong>放大差模信号，抑制共模信号</strong>。</p>
<p>4）在差分放大电路中，差模输入信号是两个输入端信号的差，共模信号是两个输入端信号的均值。</p>
<p>后置：<a href="https://lgc0208.github.io/2020/05/02/模电学习笔记_双极型晶体管(6">模电学习笔记_双极型晶体管及其放大电路（6）</a>/)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>模电</category>
      </categories>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>模电学习笔记_双极型晶体管及其放大电路（6）</title>
    <url>/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前置：<a href="https://lgc0208.github.io/2020/04/27/模电学习笔记_双极型晶体管(5">模电学习笔记_双极型晶体管及其放大电路（5）</a>/)</p>
<span id="more"></span>
<h1 id="一-基本知识点"><a href="#一-基本知识点" class="headerlink" title="一.基本知识点"></a>一.基本知识点</h1><h2 id="2-8-功率放大电路"><a href="#2-8-功率放大电路" class="headerlink" title="2.8 功率放大电路"></a>2.8 功率放大电路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;功率放大器的作用：<strong>用作放大电路的输出级</strong>，驱动扬声器、继电器等执行机构。</p>
<h3 id="2-8-1-功率放大电路的特点及分类"><a href="#2-8-1-功率放大电路的特点及分类" class="headerlink" title="2.8.1 功率放大电路的特点及分类"></a>2.8.1 功率放大电路的特点及分类</h3><p>1.功率放大电路的特点<br>（1）输出功率大<br>&nbsp;&nbsp;&nbsp;&nbsp;功放管的电压电流需要有足够的输出幅度，因此晶体管往往在<strong>接近极限状态</strong>下工作<br>&nbsp;&nbsp;&nbsp;&nbsp;注意：电路参数不能超过晶体管的极限值I~CM~,V~CEM~,P~CM~<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6" alt=" ">/20200502175024462.png)<br>（2）效率高<br>&nbsp;&nbsp;&nbsp;&nbsp;功率放大器的输出功率<strong>由直流电源供给的能量转换得到</strong>的。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>效率</strong>是负载得到的<strong>有用信号功率和电源供给的直流功率的比值</strong>。比值越大，效率越高<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6" alt=" ">/20200502175228179.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;P~O~：负载上得到的交流信号功率<br>&nbsp;&nbsp;&nbsp;&nbsp;P~DC~：电源提供的直流功率</p>
<p>（3）非线性失真小</p>
<p>（4）功放管需要散热和保护<br>&nbsp;&nbsp;&nbsp;&nbsp;在功率放大电路中，绝大部分功率消耗在集电结上，使得管子温度升高。</p>
<p>（5）一般采用图解法分析</p>
<p>2.功率放大电路的分类<br>&nbsp;&nbsp;&nbsp;&nbsp;按照晶体管工作状态不同，一般模拟功放可以分为甲类（A类）、乙类（B类）、甲乙类（AB类）和丙类（C类）四种。<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）甲类放大（导通角θ=180°）：晶体管的静态Q点在放大区，在输入信号的整个周期内都有电流流过晶体管；<br>&nbsp;&nbsp;&nbsp;&nbsp;（2）甲乙类放大（90°＜θ＜180°）：Q点靠近零点，晶体管有半个周期以上导通；<br>&nbsp;&nbsp;&nbsp;&nbsp;（3）乙类放大（θ=90°）：Q点在零点（V~BE~＜0），晶体管只有半个周期导通；<br>&nbsp;&nbsp;&nbsp;&nbsp;（4）丙类放大（θ＜90°）：Q点在零点以下（NPN:V~BE~＜0），晶体管导通时间小于半个周期</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png)</p>
<h3 id="2-8-2-互补对称功率放大电路"><a href="#2-8-2-互补对称功率放大电路" class="headerlink" title="2.8.2 互补对称功率放大电路"></a>2.8.2 互补对称功率放大电路</h3><p>1.互补对称（互补推挽）功放的类型：<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）变压器输出方式<br>&nbsp;&nbsp;&nbsp;&nbsp;（2）无变压器输出方式（OTL电路：Output TransformerLess）<br>&nbsp;&nbsp;&nbsp;&nbsp;（3）无电容输出方式（OCL电路：Output CapacitorLess）</p>
<p>2.变压器耦合输出<br>&nbsp;&nbsp;&nbsp;&nbsp;选择恰当的变比，即可在负载上得到尽可能大的输出功率</p>
<p>3.乙类互补功率放大电路原理及参数（OCL电路）<br>（1）电路组成及工作原理<br>&nbsp;&nbsp;&nbsp;&nbsp;互补对称：电路中采用两个晶体管：NPN、PNP各一支。两管特性一致，组成互补对称式射极输出器。<br>&nbsp;&nbsp;&nbsp;&nbsp;★两个晶体管都只在半个周期内工作<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6" alt=" ">/20200502210824516.png)<br>（2）实际乙类互补输出的波形图及其特点<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6" alt=" ">/20200502211058307.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;①静态电流I~CQ~，I~BQ~等于0；<br>&nbsp;&nbsp;&nbsp;&nbsp;②每个三极管导通时间为半个周期；<br>&nbsp;&nbsp;&nbsp;&nbsp;③由于死区电压的存在，电路存在交越失真<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6" alt=" ">/20200502212408283.png)<br>（3）主要参数的计算<br>&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6" alt=" ">/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438706393697.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;①输出功率<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设负载上输出正弦电压幅度为V~OM~，则输出电流的幅度为I~OM~=V~OM~/R~L~，则：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;负载上得到的信号功率为P~o~=0.5V~om~I~om~=0.5V~om~^2^/R~L~。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不考虑V~CES~时的最大输出功率：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V~omax~=V~CC~，I~omax~=V~CC~/R~L~，P~omax~=0.5V~CC~^2^/R~L~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑晶体管饱和压降V~CES~时的最大输出功率：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V~omax~=V~CC~-V~CE（sat）~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I~omax~=(V~CC~-V~CE（sat）~)/R~L~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P~omax~=V~omax~^2^/(2R~L~)</p>
<p>②电源提供的直流平均功率计算<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个电源中电流为半个正弦波（峰值为~V~om~），其平均值为<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I~av1~=I~av2~=V~om~/（πR~L~）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>两个电源提供的总功率为</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><strong>P~DC~=2V~CC~I~av1~=2V~CC~*V~om~/（πR~L~）</strong></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当V~om~=V~omax~且忽略饱和压降V~CES~时，P~DCmax~=2V~CC~*V~CC~/（πR~L~）</p>
<p>③效率和最高效率<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出幅值为某一电压时的效率<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P~o~/P~DC~=π/4 *V~om~/V~CC~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V~omax~=V~CC~，P~omax~/P~DCmax~=π/4≈78.5%</p>
<p>（4）晶体管的选择（未考虑饱和压降）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①I~CM~＞V~CC~/R~L~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②V~(BR)CEO~＞2V~CC~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③P~CM~大于任意时刻电源功率与输出功率之差<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④晶体管的最大功耗<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P~T1max~=P~T2max~=0.5(P~DC~-P~o~)=1/π^2^ *V~CC~^2^/R~L~≈0.2P~omax~<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故选择时，P~CM~＞0.2P~omax~</p>
<p>4.单电源供电的互补功率放大电路（无输出变压器的互补对称功放电路OTL）<br>（1）特点：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①单电源供电；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<strong>输出加有大电容</strong><br>（2）静态分析<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6" alt=" ">/20200502231708689.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调整R使得T~1~,T~2~有合适的静态电流<br>（3）动态分析<br><img src="/2020/05/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6)/%E6%A8%A1%E7%94%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E5%8F%8C%E6%9E%81%E5%9E%8B%E6%99%B6%E4%BD%93%E7%AE%A1(6" alt=" ">/20200502234435345.png)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T~3~集电极电压信号为正半周时，T~1~导通（见红色虚线）、T~2~截止；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T~3~集电极电压信号为负半周时，T~2~导通（见蓝色虚线）、T1截止；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若输出电容足够大，电容上电压基本保持不变，则负载上得到的交流信号正负半周对称。<br>（4）最大输出功率及效率（分析方法同OCL，参数计算中只需将OCL中的VCC用0.5VCC替代即可。）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>模电</category>
      </categories>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>OSPF 协议介绍</title>
    <url>/2022/09/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1-OSPF%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文记录了 OSPF 的基本信息。</p>
<span id="more"></span>
<h2 id="开放式最短路径优先协议-OSPF"><a href="#开放式最短路径优先协议-OSPF" class="headerlink" title="开放式最短路径优先协议 OSPF"></a>开放式最短路径优先协议 OSPF</h2><h3 id="一、OSPF-简介"><a href="#一、OSPF-简介" class="headerlink" title="一、OSPF 简介"></a>一、OSPF 简介</h3><p>OSPF（Open Shortest Path First）开放最短路径优先协议是一个基于链路状态的自制系统内部网关协议，使用链路状态路由（LSR）算法，直接工作在 IP 层上。在网络中使用 OSPF 协议后，大部分路由将根据 OSPF 协议自行计算和生成，无需人工配置。当网络拓扑发生变化时，OSPF 协议可以自动计算、更正路由，方便了实际的网络管理。</p>
<p>OSPF 从可用路由器收集链路状态信息并构建网络拓扑图，该拓扑以路由表的形式呈现给 Internet 层，通过该路由表根据数据包的 IP 地址路由数据包。OSPF 基于 Dijkstra 算法计算每条路线的最短路径树。构建路由表的 OSPF 路由策略由每个路由接口关联的链路度量来管理，可考虑的成本因素包括了路由器的距离（往返时间）、链路的吞吐量、链路可用性等。</p>
<p>OSPF 的基础术语包括了：</p>
<ul>
<li><em>Router-ID</em>：路由器标识符，用于在 OSPF 域中唯一地标识一台路由器 </li>
<li><em>度量值</em>：OSPF 使用 Cost（开销）作为路由的度量值，每一个激活了 OSPF 的接口都会维护一个接口 Cost值，接口 Cost 值 = OSPF 指定的缺省参考值/接口带宽。其中，Cost 也可以手动配置</li>
</ul>
<h3 id="二、OSPF-的-5-种报文"><a href="#二、OSPF-的-5-种报文" class="headerlink" title="二、OSPF 的 5 种报文"></a>二、OSPF 的 5 种报文</h3><p>与 UDP、TCP 等其他的路由协议不同，OSPF 不通过传输协议传输数据。OSPF 直接生成 IP 数据报，定义了 5 种不同的消息类型用于各种类型的通信：</p>
<h4 id="2-1-Hello-包"><a href="#2-1-Hello-包" class="headerlink" title="2.1 Hello 包"></a>2.1 Hello 包</h4><p>OSPF 的 Hello 消息作为一种问候形式让路由器得以发现其本地链路和网络上的其他相邻路由器，这些消息在相邻设备之间建立邻接关系并传达如何在自治系统中使用 OSPF 的关键参数。在正常运行期间，路由器会定期向其邻居节点发送 Hello 消息。如果相邻路由器停止接收来自邻居节点的 Hello 消息，则在设定的时间段后，判断邻居路由器已关闭。</p>
<h4 id="2-2-数据库描述消息-Database-Description"><a href="#2-2-数据库描述消息-Database-Description" class="headerlink" title="2.2 数据库描述消息 Database Description"></a>2.2 数据库描述消息 Database Description</h4><p>数据库描述消息包含自治系统的拓扑描述，描述消息将该区域的链路状态数据库（LSDB）的内容从一台服务器传送到另一台服务器。</p>
<h4 id="2-3-链路状态数据消息"><a href="#2-3-链路状态数据消息" class="headerlink" title="2.3 链路状态数据消息"></a>2.3 链路状态数据消息</h4><h5 id="2-3-1-链路状态请求（LSR-Link-State-Request）"><a href="#2-3-1-链路状态请求（LSR-Link-State-Request）" class="headerlink" title="2.3.1 链路状态请求（LSR, Link State Request）"></a>2.3.1 链路状态请求（LSR, Link State Request）</h5><p>一个路由器使用链路状态请求消息向另一台路由器请求有关 LSDB 的一部分更新信息（链路状态信息 LSA）。该消息指定了请求设备希望获得更多最新信息的链接。</p>
<h5 id="2-3-2-链路状态更新（LSU-Link-State-Update）"><a href="#2-3-2-链路状态更新（LSU-Link-State-Update）" class="headerlink" title="2.3.2 链路状态更新（LSU, Link State Update）"></a>2.3.2 链路状态更新（LSU, Link State Update）</h5><p>链路状态更新消息包含有关 LSDB 上某些链路状态的更新信息，用以响应链路状态请求信息。链路状态更新信息由路由器定期广播和多播。LSU 的内容将被用于更新接收他们的路由器的 LSDB 信息。</p>
<h5 id="2-3-3-链路状态确认（LSAck-Link-State-ACK）"><a href="#2-3-3-链路状态确认（LSAck-Link-State-ACK）" class="headerlink" title="2.3.3 链路状态确认（LSAck, Link State ACK）"></a>2.3.3 链路状态确认（LSAck, Link State ACK）</h5><p>链路状态确认信息通过明确确认已经收到 LSU 信息来保障链路状态交换过程的可靠性。</p>
<h3 id="三、OSPF-的-3-步工作过程"><a href="#三、OSPF-的-3-步工作过程" class="headerlink" title="三、OSPF 的 3 步工作过程"></a>三、OSPF 的 3 步工作过程</h3><h4 id="3-1-发现邻居"><a href="#3-1-发现邻居" class="headerlink" title="3.1 发现邻居"></a>3.1 发现邻居</h4><p>OSPF 路由器通过组播 hello 包， 通过同一个广播域内的接口建立一组邻居关系，如下图所示。所有的邻居都可能与自己交换链路信息。</p>
<p><img src="/2022/09/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1-OSPF%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/image-16801642125786.png" alt="发现邻居"></p>
<p>在这一过程中，<strong>OSPF 存在 4 种不同的状态</strong>：</p>
<ol>
<li><em>Down 状态</em>：邻居的初始状态，表示没有从邻居收到任何消息。在 NBMA（非广播-多路访问网络）网络上，此状态下仍然可以向静态配置的邻居发送 Hello 报文，发送间隔为 PollInterval，通常与 Router DeadInterval 间隔相同。</li>
<li><em>Attempt 状态</em>：该状态只在 NBMA（非广播-多路访问网络）中存在，表示没有收到邻居的任何信息，但是已经周期性地向邻居发送报文，发送间隔为 HelloInterval。如果在 Router DeadInterval 间隔内未收到邻居的 Hello 报文，则转换为 Down 状态。</li>
<li><em>Init 状态</em>：路由器已经从邻居收到了 Hello 报文，但是自己的 Router ID 不再所收到的 Hello 报文的邻居列表中，表示尚未与邻居建立双向通信关系。</li>
<li><em>2-Way 状态</em>：路由器发现自己的 Router ID 存在于收到的 Hello 报文的邻居列表中，已确认可以双向通信。</li>
</ol>
<h4 id="3-2-建立邻接关系"><a href="#3-2-建立邻接关系" class="headerlink" title="3.2 建立邻接关系"></a>3.2 建立邻接关系</h4><p>只有建立了邻接关系的邻居路由器才会交换链路状态信息。为了提高链路状态信息的交换效率，OSPF 采用的是 DR/BDR 方式建立连接关系。这种方式在同一个广播域的接口中选举一个组长 DR（Designated Router，指定路由器） 和一个副组长 DBR（Backup Designated Router，备份指定路由器）。<strong>网络中的所有路由器只与 DR 和 BDR 建立邻接关系</strong>，即所有的信息只会与 DR 和 DBR 交换。这种做法大大减少了网络中的邻接关系数，如下图所示。</p>
<p><img src="/2022/09/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1-OSPF%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/image-16801642233688.png" alt="邻接关系数"></p>
<p>需要注意的是，在广播型网络中 OSPF 才会选择 DR 和 BDR，而在 P2P 网络中不会选举 DR 和 BDR。</p>
<p>建立邻接关系的过程如下所示：</p>
<p><img src="/2022/09/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1-OSPF%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/image-168016423067610.png" alt="建立邻接关系"></p>
<p>在上述过程中，Router 1 首先发送一个 DD 报文，宣称自己是 Master（MS = 1），并规定序列号 Seq = X。I = 1 表示这是第 1 个 DD 报文，M = 1 说明这不是最后一个报文。之后每发送一个新的 DD 报文，Seq 都要加 1。另一方 Slave 方每次发送 DD 报文时使用接受到的上一个 Master 的 DD 报文中的 Seq。</p>
<p>Router 2 在收到 Router 1 的 DD 报文后，将 Router 1 的邻居状态机改为 Exstart，并回应了一个 DD 报文。该 DD 报文中同样把不含有LSA 的摘要信息。由于 Router 2 的 Router ID 较大，所以在报文中 Router 2 认为自己是 Master，并且重新规定序列号 Seq = Y。</p>
<p>Router 1 收到报文后，同意 Router 2 作为 Master 并将 Router 2 的邻居状态机修改为 Exchange。Router 1 使用 Router 2 的序列号 Seq = Y 来发送新的 DD 报文，该报文开始正式传送 LSA 的摘要。在该报文中，Router 1 将 MS 赋值为 0，表示自己是 Slave。</p>
<p>Router 2 收到报文后，发送新的 DD 报文来描述自己的 LSA 摘要，此时 Router 2 发送的报文序列号为 Seq = Y + 1。</p>
<p>上述过程持续进行，Router 1 通过重复 Router 2 的序列号来确认已经收到 Router 2 的报文，Router 2 通过将序列号 Seq 加 1 来确认已收到 Router 1 的报文。当 Router 2 发送最后一个 DD 报文时，在报文中写上 M = 0。</p>
<p>在这一过程中，<strong>OSPF 也存在 4 种不同的状态</strong>：</p>
<ol>
<li><em>ExStart 状态</em>：路由器开始向邻居发送 DD 报文（数据库摘要报文）。Master/Slave 主从关系也是在这个状态下形成的，初始 DD 序列号也是在此状态下确定的。在该状态下发送的 DD 报文不包括 LSA 摘要信息。</li>
<li><em>Exchange 状态</em>：路由器与邻居之间互相发送包含 LSA 摘要的 DD 报文。</li>
<li><em>Loading 状态</em>：在此状态下，路由器与邻居之间互相发送 LSR、LSU、LSAck 报文。假设 Router 1 向 Router 2 请求更新 LSA，则由 Router 1 先向 Router 2 发送 LSR 请求，Router 2 用 LSU 报文回应 Router 1 的请求。Router 1 收到后，发送 LSAck 报文进行确认。</li>
<li><em>Full 状态</em>：LSDB 同步过程完成，路由器与邻居之间形成了完全的邻接关系。</li>
</ol>
<h4 id="3-3-交换链路状态信息"><a href="#3-3-交换链路状态信息" class="headerlink" title="3.3 交换链路状态信息"></a>3.3 交换链路状态信息</h4><p>每台 OSPF 路由器都存在一个 LSDB（Link State Database，链路状态数据库），LSDB 中的每一条数据都是一个 LSA（Link State Advertisement，链路状态公告），用来描述链路状态信息，例如网络中某台路由器的 ID、OSPF 接口、直连的网段、路径开销等。</p>
<p>OSPF 路由器的链路状态信息更新方式为触发更新或每隔 30 分钟更新一次。其中，触发更新指当网络发生变化的时候，不需要等到 30 分钟的更新周期就立即向邻居节点发送信息。OSPF 的状态更新采用增量更新机制，只发邻居需要的 LSA。当状态收敛以后，区域内的所有路由器都具有相同的 LSDB。这时候的 LSDB 能体现全区域的网络拓扑结构，包括了网络中路由器个数、路由器 ID、每台路由器的直连网段、开销等。</p>
<p>交换链路状态信息的过程如下图所示。</p>
<p><img src="/2022/09/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1-OSPF%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/image-168016424242512.png" alt="交换链路状态信息"></p>
<h4 id="3-4-计算路由"><a href="#3-4-计算路由" class="headerlink" title="3.4 计算路由"></a>3.4 计算路由</h4><p>每台路由器都会根据自己的 LSDB 独立计算路由。路由器将 LSDB 中的 LSA 信息转换为网络的带权有向图后，以自己为根结点通过 Dijkstra 算法计算最短路径树，如下图所示。</p>
<p><img src="/2022/09/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1-OSPF%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/image-168016425112614.png" alt="计算路由"></p>
<h4 id="3-5-OSPF-的区域管理制度"><a href="#3-5-OSPF-的区域管理制度" class="headerlink" title="3.5 OSPF 的区域管理制度"></a>3.5 OSPF 的区域管理制度</h4><p>在 OSPF 工作过程中采用了分区域的管理制度，如下图所示。不同的两个区域之间通过区域边界路由器 ABR 所连接。在同一个区域内的路由器才会建立邻居关系，交换 LSA。收敛后，同一个区域内的所有设备具有相同的 LSDB，这个 LSDB 反映了区域内的链路状态，再计算区域内的路由。不同区域之间，由区域边界路由器 ABR 直接转发路由。</p>
<p><img src="/2022/09/09/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%BD%91%E7%BB%9C%E8%B7%AF%E7%94%B1-OSPF%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/image-168016425745216.png" alt="OSPF 的区域管理制度"></p>
<p>此外，每个区域有一个 32 位二进制的 ID，可以表示为一个十进制数，也可以表示为点分十进制形式。例如，区域 0 等价于区域 0.0.0.0，区域 1 等价于区域 0.0.0.1。需要注意的是，区域 0 是 OSPF 网络的骨干区域，除区域 0 以外的区域都是非骨干区域。非骨干区域之间不能直接通信，需要通过骨干区域 0 进行转发，以防止产生环路路由。如果一个网络中有不同的 OSPF 区域，那么一定有一个区域是区域 0。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>网络路由</category>
      </categories>
      <tags>
        <tag>网络路由协议</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛 F 奖经验贴</title>
    <url>/2021/07/31/%E7%AB%9E%E8%B5%9B-%E7%BE%8E%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B-%E7%BE%8E%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2021美赛过去半年了，一直也在忙各种各样的事情，刚好上学期有一门项目管理的课程，课程论文写的就是美赛经验，偷个懒直接改下排版复制上来，以作留念</p>
<span id="more"></span>
<p>贴个奖状~~<br><img src="/2021/07/31/%E7%AB%9E%E8%B5%9B-%E7%BE%8E%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B-%E7%BE%8E%E8%B5%9B/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png" alt=" "></p>
<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><p>项目是一个组织为实现自己既定的目标，在一定的时间、人员和资源约束条件下， 所开展的一种具有一定独特性的一次性工作。<a href="#refer-anchor-1"><sup>[1]</sup></a>在 2020-­2021 学年寒假前夕，笔者邀请了两位同学一起参加美国大学生数学建模竞赛（下文简称为美赛）。这是一个三人小团体为实现在比赛结束前上交一个具体问题的解决方案，在 4 天 4 夜的时间内、仅能由团队三人完成且仅能借助于非生命的现有资源（即网络资源，不能求助于其他同学和指导老师）所开展的一种具有独特性的一次性工作，符合授课教师所要求的项目经历条件， 且与本课程高度相关。</p>
<p>基于此，笔者结合本学期所学的《项目管理与经济决策》相关知识，以参加 2021 年美国大学生数学建模竞赛为例，从人员组织阶段、比赛准备阶段、比赛前夕阶段、比赛阶段和赛后总结五个部分分析了项目管理与经济决策在实践中的应用。</p>
<h1 id="二、人员组织阶段"><a href="#二、人员组织阶段" class="headerlink" title="二、人员组织阶段"></a>二、人员组织阶段</h1><p>2021 年美赛举办的时间为北京时间 2 月 5 日 6:00 至 2 月 9 日 9:00，而 2 月 11 日就是大年三十。这并不是一个能够充分调动参赛积极性的比赛时间。同时，在未接受过系统培训且学校也不提供任何支持的条件下，想要在这样的一场比赛中取得不错的成绩必然需要赛前的长期准备。因此，寻找可靠的队友和指定详细的训练计划成为了重中之重。其中，笔者认为寻找可靠的队友更是整个项目成功与否的最重要的因素。</p>
<p>因此，笔者首先根据自己有过的其他项目合作经历和学生活动组织经历初步确认了目标人选。确认目标人选后首先做的事情就是对对方参赛意向的打探。如果贸然提出邀请，对方可能会因为缺乏对于自身和项目的理性思考而草率答应，而这样组建起来的团队当遇到困难的时候极有可能会萌生强烈的退意，更有很大几率会导致团队的瓦解、崩溃。若对方没有展现出想要参加的欲望或者明确说明不想参加，就应该及时放弃，另寻他人；而当对方明确展示出有些心动的迹象，笔者也不会立刻提出邀请，而是选择过几日再与对方取得联系并视情况提出正式邀请。这中间的空余时间便是留给自己规划和对方思考的时间。当然，如果对方明确表示了自己想要“入伙”的话，那自然就是现场向对方提出正式的邀请，展示出自己的诚意。</p>
<p>同时，在人员组织阶段还需要充分考虑到团队需要擅长什么的人、需要什么性格的人。因此，在进行人员组织之前笔者先对整个比赛的规则、流程和历年参赛团队的基本情况进行了调研。历年参赛团队的普遍分工为论文 1 人、编程 1 人、建模 1 人。但是笔者认为这并不是笔者当时情况的最优解。由于北邮学校研究方向的优势，擅长编程的团队成员非常容易找到(实际上笔者自己就作为这样的一个成员在团队内存在)；建模的工作需要扎实的数学功底且经过了相关的训练，但不少的同学在大一和大二上学期期间已经选修过数学建模相关的课程，因此也有大量的人选，相比之下，虽然论文写作需要使用英文，但身边的同学或多或少都有过许多外文文献阅读经验，且借助于现代化的中英翻译服务和LaTex 模板，几乎没有必要单独分出一名同学撰写论文。正相反，每一个成员亲笔写下自己的工作内容反而更能把握住写作的重心、保证文章的质量。因此，笔者最后构想的人员组成为建模 1 人、编程 2 人，且 3 人之间的准备工作要有适当的重叠以增强团队的容错性，同时比起团队成员的能力因素，笔者更多地将重心放在团队成员的性格因素和心理素质之上。<br>如果从有参加美赛的想法开始就预先考虑目标团队成员，并将双方的意向和整个团队的需求纳入考虑因素的范围内，这一阶段就会简单得多。因此，笔者并没有花费太多的时间和精力就组织起了一支参加美赛的团队。</p>
<h1 id="三、比赛准备阶段"><a href="#三、比赛准备阶段" class="headerlink" title="三、比赛准备阶段"></a>三、比赛准备阶段</h1><p>建立起一个参赛团队之后，就需要着手进行比赛的准备工作。得益于北邮 2020 年 12 月底就开始了寒假，我们有着更加充足的时间和空间去准备这场比赛，也有更多的机会去磨合和试错。基于此，笔者先预留了一周的时间让团队成员和自己从学校的快节奏紧张状态修养、转变为相对轻松的假期状态，并在这一段时间内对于整个项目团队的准备方向和方式进行总体设计。随后在第二周的周末组织了一次线上会议，向项目成员征求了意见，最终确立了团队针对本次比赛的宏观设计，即</p>
<ul>
<li>每周三和周日晚上九点进行一次线上会议，团队成员交流各自的收获和困惑</li>
<li>确认了以 C 题（大数据题）为团队主攻方向，其他题目为辅以减少备战压力</li>
<li>以研究学习往年 Outstanding Winner 获得者的论文为主，其他研究内容根据具体情况适度调整</li>
<li>确认了 1 名团队成员主攻模型的建构、1 名团队成员主攻大数据的处理和分析、1 名<br>团队成员主攻数据和模型的可视化编程的团队分工</li>
<li>鉴于北邮被列入实体名单，MATLAB 的使用具有了不确定性，确定了本次比赛使用的主语言为 Python 语言</li>
<li>在 2021.01.27­2021.01.30 期间进行一次比赛模拟，休息两天后进行复盘，然后充分休息，以充足的精力参加正式比赛</li>
</ul>
<p>同时团队也确定了下一次会议前各自研究和探索的内容。至此，团队的比赛准备慢慢步入了相对规范化。虽然每周两次的交流听起来会有些死板和僵硬，但不得不说这是推动团队项目进展和团队成员交流的一个极为有效的手段，尤其在克服团队成员的惰怠上成效显著（包括笔者自己的惰怠）。从《项目管理与经济决策》的课程所学知识来说， 在这个过程中应用了项目活动分解法，根据项目工作分解结构，通过进一步分解和细化每个项目工作包中的各项活动，从而得到项目活动定义的一种结构化和层次化，进而安排团队成员的工作。<a href="#refer-anchor-2"><sup>[2]</sup></a></p>
<p>当然，只看别人写的文章、复现别人做出的成果必然不可能有突破性的进步，更不可能掌握整个数学建模的流程和方法。因此在一次次会议中，团队成员群策群力，针对每一次学习大家的收获和遇到的问题提出了改进策略：例如在看不懂别人的论文时，团队成员先就各自主攻的方向系统性地整理资料或算法，并将其介绍给其他团队成员，让所有成员都对这一成员负责的部分至少获得一个感性的认知；复现论文感觉收效甚微时将工作内容转换为自己出题、自己建模、自己撰写论文、自己展示成果，这时候再看别人的论文便受益无穷了……第一步人员组织阶段的重要性在这个时候已经初步展现出来了。</p>
<p>在这个阶段，当笔者发现团队已经步入正轨之后，才开始组织比赛的报名。由于美赛的报名不能使用国内的支付方式，团队只能选择第三方网站进行代报名。值得一提的是，美赛的报名费高于其他绝大部分竞赛，在笔者所选择的第三方网站代报名需要 810 元/队。因此以防万一，笔者在团队建立初期暂缓了比赛的报名，而选择在团队步入正轨之后才进行报名。进行报名后，笔者没有急着分账，而是在比赛结束后再进行分账。在笔者看来这或许能是一个让团队成员能够保持一个较长期积极性的行为（至少看在钱的份上）。团队最终的表现很棒，但这个行为是否真如笔者预想的那样发挥出它应有的作用，却是缺乏实证支撑了。</p>
<p>值得一提的是，类似于笔者所选择报名网站的第三方网站种类非常多，价格也从730­850 元不等。但是很多第三方网站由于缺乏足够的网站规模和用户规模而让人望而却步。这样的第三方网站属于流动性风险和运营风险都较高的一类网站，能因为缺乏市场成交量或对市场适应性不足而无法完成预期目标。<a href="#refer-anchor-3"><sup>[3]</sup></a>这样的网站存在收钱不办事的风险，而涉及的资金对于学生群体来说又相对庞大，因此选择第三方代报名平台时需要更倾向于选择信誉、声誉风险低，长期提供相关业务且交易量较大的平台。</p>
<h1 id="四、比赛前夕阶段"><a href="#四、比赛前夕阶段" class="headerlink" title="四、比赛前夕阶段"></a>四、比赛前夕阶段</h1><p>美赛时间十分有限，因此笔者在比赛前便结合团队模拟比赛的结果和往年资料制定了一份比赛期间的大致时间安排表，如表 1 所示。这份安排表类似于项目管理中所制定的项目章程，提供了这个比赛中每一个具体项目的要求、目标、规定和方向。<a href="#refer-anchor-4"><sup>[4]</sup></a></p>
<center>
表 1 比赛时间安排表
</center>

<div class="table-container">
<table>
<thead>
<tr>
<th>比赛时间</th>
<th>主体工作内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个比赛日</td>
<td></td>
</tr>
<tr>
<td>上午</td>
<td>弄清题意，理解出题背景，预测适用的算法，决定选择的题目</td>
</tr>
<tr>
<td>下午</td>
<td>查阅、遴选、阅读资料确定第一问的解题方法，开始摘要等模块的撰写工作</td>
</tr>
<tr>
<td>晚上</td>
<td>着手开始写第一问的相关基础，开始第一问完整建模和撰写</td>
</tr>
<tr>
<td>第二个比赛日</td>
<td></td>
</tr>
<tr>
<td>上午</td>
<td>总结前一日结果，完成第一问的建模、图形和文章撰写</td>
</tr>
<tr>
<td>下午</td>
<td>查阅、遴选、阅读资料确定第二问的解题方法，确认题目要求</td>
</tr>
<tr>
<td>晚上</td>
<td>开始第二问的编程实现和文章撰写</td>
</tr>
<tr>
<td>第三个比赛日</td>
<td></td>
</tr>
<tr>
<td>上午</td>
<td>总结前一日成果，完成第二问的建模、图形和文章撰写</td>
</tr>
<tr>
<td>下午</td>
<td>确定最后几个小问题的解决方案并编程实现，撰写文章</td>
</tr>
<tr>
<td>晚上</td>
<td>初步得到赛题的基本结论，深度完成绘图和协作工作</td>
</tr>
<tr>
<td>第四个比赛日</td>
<td></td>
</tr>
<tr>
<td>上午</td>
<td>总结前一日成果，进行灵敏度分析及撰写</td>
</tr>
<tr>
<td>下午</td>
<td>进行全局代码优化，完成撰写信件/备忘录等额外工作</td>
</tr>
<tr>
<td>晚上</td>
<td>润色文章，修改语法，美化图标，查缺补漏，准备提交</td>
</tr>
</tbody>
</table>
</div>
<p>赛场如战场，比赛时间安排表并没有写得太过详细的原因是，笔者认为具体的工作内容更应该由团队队长根据具体情况做出相应的判断，而不是更不能完全依靠一份预先精心策划的时间安排表。过于详细的时间安排表更有可能使团队成员遇到不可抗力因素</p>
<p>使得流程无法按照既定方向出发时产生心慌意乱、自乱阵脚的现象，反而得不偿失。也得益于最后准备阶段制定的时间安排表作为参考和团队预先的心理建设，团队最后才得以顺利地完成了这个比赛。</p>
<h1 id="五、比赛阶段"><a href="#五、比赛阶段" class="headerlink" title="五、比赛阶段"></a>五、比赛阶段</h1><p>由于比赛前已经有过充分的准备和预演，团队成员已经对诸如审题错误等致命错误有了强烈的危机意识，在正式比赛的过程中步步为营、稳扎稳打。在比赛过程中，笔者也在每个比赛阶段开始前使用了节点图法为团队的项目活动进行了排序。<a href="#refer-anchor-5"><sup>[5]</sup></a>但不可避免的是，团队也遇到了几乎所有的参赛队伍都会遇到的问题：卡在某一个问题无从下手。我们团队遭遇的问题是解决图像识别所需要用到的pytorch 和TensorFlow 环境和搜索到的代码资料不匹配。想必接触过编程的人或多或少都能体会到安装环境的复杂和耗时。在相当长的一段时间内（大概一个下午加上一个晚上）我们都因为环境不匹配而无法开展下一步工作。所幸如果解决这个问题，剩下的问题都属于一眼就能破题的难度，因此我们并没有因为花在这上面的时间过多而心疼。然而笔者也必须为团队做两手准备，即可考虑越过这一部分先解决后面部分，并为团队接下来的工作安排做一个备用方案。这个时候从《项目管理与经济决策》课程知识的角度来看，用到的其实就是追加计划法对项目进度计划控制。最终虽然备用方案没有用上，但是从中也获得到了从项目学习到的经验教训。<a href="#refer-anchor-6"><sup>[6]</sup></a></p>
<p>幸运的是，团队成员在这一方面的高素质使得我们在那一天的晚上睡觉前成功攻克了这一难题，并将图像识别的代码跑了起来。人员组织阶段的重要性在这一时刻又体现了出来。但归根结底这其实是笔者的失职。美赛官方在比赛前的一段时间内就已经公布了我们团队预选的 C 题的数据，数据压缩包超过了 700MB。当时笔者和团队虽然有预测这次比赛会需要图像识别、语音识别等技术进行解题，但并没有组织起来进行相应的准备，甚至连基本的运行环境都没有预先搭建。从另一角度来说，也是笔者数据敏感性的缺乏、专业素养的去缺乏和在团队中的失职导致了团队在这“一寸光阴一寸金”的比赛中浪费了许多时间。<br>跨越这一障碍之后，团队前进的道路就如预期设想的那样顺利，最终在 2 月 9 日的凌晨两点半提交了终版的论文，也算是顺利完成了比赛。这场比赛至此告一段落。</p>
<h1 id="六、赛后总结"><a href="#六、赛后总结" class="headerlink" title="六、赛后总结"></a>六、赛后总结</h1><p>这次比赛的完成过程在笔者看来其实是非常危险的。最初备赛的时候笔者看着 700 多 MB 的数据包却依然心存侥幸，一方面认为图像识别的代码在 Github 等各大网站唾手可得，不用过多准备；另一方面认为如果数据是语音或者视频的话，提前准备图像识别可能毫无用处。也就是这个心存侥幸，使得团队在比赛过程中浪费了很多很多时间，</p>
<p>直接导致了最后一天晚上整个团队修改文稿到凌晨两点半才休息。这本是可以避免的事情，却因为笔者一时懈怠而连累整个团队。</p>
<p>但幸运的是，我们团队在一开始就约定在整个比赛过程中全程连麦。这充分保证了我们沟通的准确性、完整性和及时性，保证了信息沟通的效果，才不至于分寸大乱，最终群策群力迈过了这道坎。<a href="#refer-anchor-7"><sup>[7]</sup></a>遵循了开展沟通的基本原则正是我们团队最后得以成功完赛的重要因素。</p>
<p>在笔者学习完《项目管理与经济决策》之后发现，这次的错误可以归因于笔者从头到尾没有为整个团队做过项目风险管理工作。因为这次比赛的一次性、独特性和创新性，决定了这整个项目过程中存在着严重的信息不完备性，使项目中存在着许多风险比较高的项目，其中的典型代表就是我们团队止步不前的图像识别环境搭建。<a href="#refer-anchor-8"><sup>[8]</sup></a> 如果当初具备项目管理的知识，提早指定项目风险管理计划，或许整个团队就可以避免这种情况的出现。所幸最后凭借团队成员过硬的专业素养和心理素质，团队最终仍拿到了 Finalist 的奖项，仅次于最高奖项 Outstanding Winner，也算是让笔者对整个团队有了一个交代， 但这样的错误在学习过《项目管理与经济决策》课程之后务必不能更不应该再犯了。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h1><p><div id="refer-anchor-1"></div><br> [1] 项目管理部分: 第一章绪论, 第一节项目的基本概念, 项目的定义与概念 [课程知识点].</p>
<p><div id="refer-anchor-2"></div><br>[2]    项目管理部分: 第四章项目时间管理, 第二节项目活动定义, 项目活动定义的方法 [课程知识点].</p>
<p><div id="refer-anchor-3"></div><br>[3]    财务分析与决策部分: 第十章财务分析与决策的实际应用, 第八节本周课程辅助材料<br>[课程知识点].</p>
<p><div id="refer-anchor-4"></div><br>[4]    项目管理部分: 第七章项目集成管理, 第三节项目起始阶段的集成管理, 制定项目的章程 [课程知识点].</p>
<p><div id="refer-anchor-5"></div><br>[5]    项目管理部分: 第四章项目时间管理, 第三节项目活动排序, 项目活动排序的方法和结果 [课程知识点].</p>
<p><div id="refer-anchor-6"></div><br>[6]    项目管理部分: 第四章项目时间管理, 第七节项目进度计划的控制, 项目进度计划控制的方法和结果 [课程知识点].</p>
<p><div id="refer-anchor-7"></div><br>[7]    项目管理部分: 第九章项目沟通管理, 第一节沟通及其管理的概念和特性, 开展沟通的基本原则和影响要素 [课程知识点].</p>
<p><div id="refer-anchor-8"></div><br>[8]    项目管理部分: 第八章项目风险管理, 第一节项目风险和项目风险管理, 项目风险的定义与概念 [课程知识点].</p>
]]></content>
      <categories>
        <category>竞赛</category>
        <category>美国大学生数学建模竞赛</category>
      </categories>
      <tags>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>参考文献格式生成器（GB/T 7714-2015）</title>
    <url>/2022/07/02/%E9%A1%B9%E7%9B%AE-HTML-%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%BC%E5%BC%8F%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是一个因为懒诞生的小项目，发出来是感觉也花了一些精力就自己用太亏了。</p>
<p>因为懒得对着引用文献标准一个个敲字，文献管理软件的引用格式又好像经常出错，就参考其他格式生成器自己写了个，针对的是 GB/T 7714-2015 标准</p>
<span id="more"></span>
<h2 id="网页预览"><a href="#网页预览" class="headerlink" title="网页预览"></a>网页预览</h2><p><img src="/2022/07/02/%E9%A1%B9%E7%9B%AE-HTML-%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%A0%BC%E5%BC%8F%E7%94%9F%E6%88%90%E5%99%A8/image-20220702214355905.png" alt="image-20220702214355905"></p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol>
<li>Github Page 网址：<a href="https://lgc0208.github.io/reference_format_generation/">https://lgc0208.github.io/reference_format_generation/</a></li>
<li>进入 Github 仓库，下载 <code>index.html</code>, <code>generation.js</code>, <code>style.css</code> 后，使用浏览器打开 <code>index.html</code> 文件</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Java 的单机坦克大战游戏</title>
    <url>/2020/08/20/%E9%A1%B9%E7%9B%AE-Java-Java%E5%9D%A6%E5%85%8B%E5%A4%A7%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于 Java 开发的坦克大战单机版小游戏</p>
<p><strong>项目地址</strong>：<a href="https://github.com/lgc0208/TankGame">https://github.com/lgc0208/TankGame</a></p>
<span id="more"></span>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>Java 14.0.1</li>
<li>IntelliJ IDEA 2020.1</li>
<li>Windows 10 家庭中文版</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul>
<li>1.完成画出坦克</li>
<li>2.完成我的坦克可以上下左右移动</li>
<li>3.完成按下J键发射子弹，子弹连发，最多同时存在5颗</li>
<li>4.完成当我的坦克击中敌人坦克时，敌人坦克爆炸并消失</li>
<li>5.完成敌人坦克可以随意移动</li>
<li>6.完成我方和敌方坦克在规定区域移动</li>
<li>7.完成当敌人的坦克击中我方坦克时，我方坦克爆炸</li>
<li>8.添加开始和结束提示界面</li>
<li>9.添加暂停游戏和继续游戏功能</li>
<li>10.添加开始游戏音效和坦克爆炸音效</li>
</ul>
<h3 id="运行说明"><a href="#运行说明" class="headerlink" title="运行说明"></a>运行说明</h3><p>编译 <code>MyTankGame6.java</code> 即可启动游戏</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Tomcat 的  Java 本地服务器读取 SQL Server 中的数据及账号密码核对</title>
    <url>/2021/07/10/%E9%A1%B9%E7%9B%AE-Java-Java%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前言：该小项目使用 Java Tomcat 本地服务器，实现了读取 SQL Server 数据以及将输入的账号密码与数据库中已有的账号密码进行比对的功能，Java 源代码下载链接：<a href="https://download.csdn.net/download/weixin_45817309/20150415">Java本地服务器读取SQL Server中的数据及账号密码核对</a></p>
<span id="more"></span>
<h1 id="1-系统概述"><a href="#1-系统概述" class="headerlink" title="1 系统概述"></a>1 系统概述</h1><p><strong>1.1 系统简介</strong></p>
<p>基于微信小程序实现学校信息门户中校内通知、公示公告、校内新闻和学术讲座的便捷查看。</p>
<p><strong>1.2 术语表</strong>  </p>
<p>该文档涉及到的术语如表1所示。</p>
<center>表 1 详细设计术语表</center>

<div class="table-container">
<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>术语或缩略语</strong></th>
<th><strong>说明性定义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>微信小程序</td>
<td>微信小程序是一种不需要下载安装即可使用的应用，用户使用微信扫一扫或搜一下即可打开应用。</td>
</tr>
<tr>
<td>2</td>
<td>数据库</td>
<td>数据库是“按照数据结构来组织、存储和管理数据的仓库”。是一个长期存储在计算机内的、有组织的、可共享的、统一管理的大量数据的集合。</td>
</tr>
<tr>
<td>3</td>
<td>信息门户</td>
<td>信息门户是指利用网络浏览器访问组织内部和外部关键信息的单一入口，解决信息超载问题，利用先进的搜索及索引技术构建起一个内联网环境，用来从不同的信息系统和互联网中搜索和获取信息。</td>
</tr>
<tr>
<td>4</td>
<td>爬虫</td>
<td>爬虫是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。</td>
</tr>
<tr>
<td>5</td>
<td>PM</td>
<td>Project Manager,项目经理</td>
</tr>
<tr>
<td>6</td>
<td>逻辑层</td>
<td>小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。</td>
</tr>
<tr>
<td>7</td>
<td>视图层</td>
<td>框架的视图层由 WXML 与 WXSS 编写，由组件来进行展示。将逻辑层的数据反映成视图，同时将视图层的事件发送给逻辑层。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>1.3 系统运行环境</strong> </p>
<ol>
<li><strong>软件环境：</strong></li>
</ol>
<p>系统所需要的软件环境如表2所示。</p>
<center>表 2 系统运行的软件环境</center>

<div class="table-container">
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>名称</strong></th>
<th><strong>版本</strong></th>
<th><strong>语种</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>PC操作系统</td>
<td>Windows 10</td>
<td>家庭中文版</td>
<td>简体中文</td>
</tr>
<tr>
<td>数据库平台</td>
<td>Microsoft SQL Server</td>
<td>2019</td>
<td>Sql</td>
</tr>
<tr>
<td>服务器端</td>
<td>IntelliJ IDEA</td>
<td>2020.1</td>
<td>Java</td>
</tr>
<tr>
<td></td>
<td>Tomcat</td>
<td>9.0.44</td>
<td></td>
</tr>
<tr>
<td>开发环境</td>
<td>Java</td>
<td>14.0.1</td>
<td>Java</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><strong>硬件平台</strong></li>
</ol>
<p>系统运行的硬件平台如表3所示。</p>
<center>表 3 系统运行的硬件平台</center>

<div class="table-container">
<table>
<thead>
<tr>
<th><strong>设备名称</strong></th>
<th><strong>设备要求</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>PC</td>
<td>装有 Java 14.0.1 及以上版本、 Apache Tomcat 对应版本 、Microsoft SQL Server 数据库 2019及以上版本</td>
</tr>
</tbody>
</table>
</div>
<p><strong>1.4 开发环境</strong> </p>
<p>该程序开发环境如表4所示。</p>
<center>表 4 程序开发环境</center>

<div class="table-container">
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>名称</strong></th>
<th><strong>版本</strong></th>
<th><strong>语种</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>PC操作系统</td>
<td>Windows 10</td>
<td>家庭中文版</td>
<td>简体中文</td>
</tr>
<tr>
<td>开发平台</td>
<td>IntelliJ IDEA</td>
<td>2020.1</td>
<td>Java</td>
</tr>
<tr>
<td>开发平台</td>
<td>Tomcat</td>
<td>9.0.44</td>
<td>Java</td>
</tr>
<tr>
<td>数据库平台</td>
<td>Microsoft SQL Server</td>
<td>2019</td>
<td>Sql</td>
</tr>
</tbody>
</table>
</div>
<h1 id="2-模块设计"><a href="#2-模块设计" class="headerlink" title="2 模块设计"></a>2 模块设计</h1><h2 id="2-1-模块2-Java-Tomcat-服务器模块"><a href="#2-1-模块2-Java-Tomcat-服务器模块" class="headerlink" title="2.1 模块2 Java Tomcat 服务器模块"></a><strong>2.1 模块2 Java Tomcat 服务器模块</strong></h2><h3 id="2-1-1-设计图"><a href="#2-1-1-设计图" class="headerlink" title="2.1.1 设计图"></a><strong>2.1.1 设计图</strong></h3><p>该模块的设计图如图1所示。</p>
<p><img src="/2021/07/10/%E9%A1%B9%E7%9B%AE-Java-Java%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png" alt=" "></p>
<center>图1 Java Tomcat 服务器模块设计图</center>


<h3 id="2-1-2-功能描述"><a href="#2-1-2-功能描述" class="headerlink" title="2.1.2 功能描述"></a><strong>2.1.2 功能描述</strong></h3><p>该部分包含九个类，该部分为数据库和微信小程序之间的桥梁模块，搭建服务器作为数据库和微信小程序通信的中枢。</p>
<h3 id="2-1-3-输入数据"><a href="#2-1-3-输入数据" class="headerlink" title="2.1.3 输入数据"></a><strong>2.1.3 输入数据</strong></h3><p>若需要检验用户的登录名和密码，需要在GET指定URL时同时传递username和password数据。</p>
<h3 id="2-1-4-输出数据"><a href="#2-1-4-输出数据" class="headerlink" title="2.1.4 输出数据"></a><strong>2.1.4 输出数据</strong></h3><p>若访问的为用户登录鉴权接口，则根据用户传递的数据返回success（登陆成功）或error（登录失败）。</p>
<p>若访问的为各类通知对应的接口，则返回JSON格式的通知数据，包含信息标题title，发布日期date，文章主体article和文章中包含的图片的URL地址image。</p>
<h3 id="2-1-5-数据设计"><a href="#2-1-5-数据设计" class="headerlink" title="2.1.5 数据设计"></a><strong>2.1.5 数据设计</strong></h3><pre><code>该部分的数据设计如表5所示。
</code></pre><center>表 5 Java Tomcat 服务器模块数据设计</center>

<div class="table-container">
<table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th><strong>数据结构</strong></th>
<th><strong>元素类型</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>information</td>
<td>ArrayList</td>
<td>String</td>
<td>存储从数据库中获取的信息</td>
</tr>
<tr>
<td>ct</td>
<td>Database</td>
<td>Table</td>
<td>读取数据库的数据</td>
</tr>
<tr>
<td>jsonOutput</td>
<td>String</td>
<td>char</td>
<td>作为JSON格式的数据供微信小程序读取</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-1-6-算法和流程"><a href="#2-1-6-算法和流程" class="headerlink" title="2.1.6 算法和流程"></a><strong>2.1.6 算法和流程</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>  **<span class="keyword">if</span>** 访问通知获取接口:  &#123;</span><br><span class="line"><span class="number">2.</span>    	获取数据库连接  </span><br><span class="line"><span class="number">3.</span>   	从数据库的指定表中读取信息  </span><br><span class="line"><span class="number">4.</span>   	根据不同列名将数据按照对应格式存储到List  </span><br><span class="line"><span class="number">5.</span>   	将List中的数据转换为JSON格式  </span><br><span class="line"><span class="number">6.</span>   **<span class="keyword">if</span>** 接口被以GET或POST格式访问：  </span><br><span class="line"><span class="number">7.</span>       在网页上输出JSON格式的信息  &#125;</span><br><span class="line"><span class="number">8.</span>   **<span class="keyword">if</span>** 访问登录鉴权接口:  &#123;</span><br><span class="line"><span class="number">9.</span>   	获取数据库连接  </span><br><span class="line"><span class="number">10.</span>  	获取前端传递的信息  </span><br><span class="line"><span class="number">11.</span>  	将传递的信息与数据库中的信息进行比对  </span><br><span class="line"><span class="number">12.</span>  	**<span class="keyword">if</span>** 比对成功:  </span><br><span class="line"><span class="number">13.</span>      	在网页上输出 success 的信息  </span><br><span class="line"><span class="number">14.</span>  	**<span class="keyword">else</span>**:  </span><br><span class="line"><span class="number">15.</span>      	在网页上输出 error 的信息 &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-7-函数实现"><a href="#2-1-7-函数实现" class="headerlink" title="2.1.7 函数实现"></a><strong>2.1.7 函数实现</strong></h3><p>该部分的函数说明如表6所示。</p>
<center>表 6 Java Tomcat 服务器模块函数说明</center>

<div class="table-container">
<table>
<thead>
<tr>
<th><strong>函数名称</strong></th>
<th><strong>功能</strong></th>
<th><strong>参数</strong></th>
<th><strong>返回值</strong></th>
<th><strong>算法说明</strong></th>
<th><strong>全局变量</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>informationDatabase</td>
<td>构造函数</td>
<td>String lableName</td>
<td>None</td>
<td>完成对数据库的链接工作</td>
<td>None</td>
</tr>
<tr>
<td>getInformation</td>
<td>获取通知信息并存储到Notification数组中</td>
<td>None</td>
<td>JSON格式的通知字符串</td>
<td>从数据库的指定表中获取信息，根据不同列将信息分类存储，并转换为JSON格式</td>
<td>None</td>
</tr>
<tr>
<td>Information</td>
<td>构造函数</td>
<td>信息标题title，发布日期date，文章主体article和文章中图片的URL地址image</td>
<td>None</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>doGet</td>
<td>网页传递来的信息和回应的信息</td>
<td>HttpServletRequest request, HttpServletResponse response</td>
<td>None</td>
<td>当用户使用GET方式访问时给出相应的反应</td>
<td>None</td>
</tr>
<tr>
<td>doGet</td>
<td>网页传递来的信息和回应的信息</td>
<td>HttpServletRequest request, HttpServletResponse response</td>
<td>None</td>
<td>当用户使用POST方式访问时给出相应的反应</td>
<td>None</td>
</tr>
<tr>
<td>userDatabase</td>
<td>构造函数</td>
<td>None</td>
<td>None</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>checkUser</td>
<td>确认登录信息</td>
<td>用户登录username, 用户登录密码password</td>
<td>若查到，返回对象User，否则返回null</td>
<td>将传递进来的信息与数据库信息进行查询比对，若找到，返回信息，否则返回null</td>
<td>None</td>
</tr>
<tr>
<td>getTitle</td>
<td>赋值</td>
<td>None</td>
<td>title</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>setTitle</td>
<td>取值</td>
<td>title</td>
<td>None</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>getDate</td>
<td>赋值</td>
<td>None</td>
<td>date</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>setDate</td>
<td>取值</td>
<td>date</td>
<td>None</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>getArticle</td>
<td>赋值</td>
<td>None</td>
<td>article</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>setArticle</td>
<td>取值</td>
<td>article</td>
<td>None</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>getImage</td>
<td>取值</td>
<td>None</td>
<td>image</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>setImage</td>
<td>赋值</td>
<td>image</td>
<td>None</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>getUsername</td>
<td>赋值</td>
<td>None</td>
<td>username</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>setUsername</td>
<td>取值</td>
<td>username</td>
<td>None</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>getPassword</td>
<td>赋值</td>
<td>None</td>
<td>password</td>
<td>赋值语句</td>
<td>None</td>
</tr>
<tr>
<td>setPassword</td>
<td>取值</td>
<td>password</td>
<td>None</td>
<td>赋值语句</td>
<td>None</td>
</tr>
</tbody>
</table>
</div>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Name:       Information.java</span></span><br><span class="line"><span class="comment"> *  Author:     LIN Guocheng</span></span><br><span class="line"><span class="comment"> *  Date:       2021-3-28</span></span><br><span class="line"><span class="comment"> *  Function:   用于存取校内通知的标题、发布时间和文章主体。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Information</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line">    <span class="keyword">private</span> String article;</span><br><span class="line">    <span class="keyword">private</span> String[] image;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Information</span><span class="params">(String title, String date, String article, String[] image)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">        <span class="keyword">this</span>.article = article;</span><br><span class="line">        <span class="keyword">this</span>.image = image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getArticle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> article;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setArticle</span><span class="params">(String article)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.article = article;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImage</span><span class="params">(String[] image)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.image = image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getImage() &#123;</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> database.informationDatabase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">announcementServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//设置响应头允许ajax跨域访问</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET,POST&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Writer out = response.getWriter();</span><br><span class="line">        String jsonOutput = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        informationDatabase nd = <span class="keyword">new</span> informationDatabase(<span class="string">&quot;schoolAnnouncements&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jsonOutput = nd.getInformation();</span><br><span class="line">            out.write(jsonOutput);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> database;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> model.Information;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">informationDatabase</span> </span>&#123;</span><br><span class="line">    String lableName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Connection ct = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pestmt = <span class="keyword">null</span>;</span><br><span class="line">    String jsonOutput = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Information&gt; information = <span class="keyword">new</span> ArrayList&lt;Information&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">informationDatabase</span><span class="params">(String lableName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lableName = lableName;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>);</span><br><span class="line">            ct = DriverManager.getConnection(<span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=schoolNews&quot;</span>, <span class="string">&quot;这里输入数据库用户名&quot;</span>, <span class="string">&quot;这里输入数据库密码&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (ct != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库连接成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库连接失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取通知信息并存储到Notification数组中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInformation</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在打包发送 校内通知&quot;</span>);</span><br><span class="line"></span><br><span class="line">            pestmt = ct.prepareStatement(<span class="string">&quot;select * from &quot;</span> + <span class="keyword">this</span>.lableName + <span class="string">&quot; order by date desc&quot;</span>);</span><br><span class="line">            ResultSet rs = pestmt.executeQuery(); <span class="comment">// 将数据库响应的查询结果放在rs中</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line"></span><br><span class="line">            	<span class="comment">//System.out.println(rs.getString(1)+&quot;,&quot;);	//标题</span></span><br><span class="line">            	<span class="comment">//System.out.println(rs.getString(2)+&quot;,&quot;);</span></span><br><span class="line">            	<span class="comment">//System.out.println(rs.getString(3)+&quot;,&quot;);</span></span><br><span class="line">                String[] imgUrls = rs.getString(<span class="number">4</span>).split(<span class="string">&quot;,&quot;</span>); <span class="comment">// 将image字符串按逗号分割，成为数组</span></span><br><span class="line">                Information information = <span class="keyword">new</span> Information(rs.getString(<span class="number">1</span>),rs.getString(<span class="number">2</span>),rs.getString(<span class="number">3</span>),imgUrls);</span><br><span class="line">                <span class="keyword">this</span>.information.add(information);</span><br><span class="line">            &#125;</span><br><span class="line">            jsonOutput = JSON.toJSONString(information);</span><br><span class="line">            System.out.println(jsonOutput);</span><br><span class="line">            <span class="keyword">return</span> jsonOutput;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;转换JSON出错&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ct.close();</span><br><span class="line">            pestmt.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> database;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> model.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userDatabase</span> </span>&#123;</span><br><span class="line">    Connection ct = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pestmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">userDatabase</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>);</span><br><span class="line">            ct=DriverManager.getConnection(<span class="string">&quot;jdbc:sqlserver://localhost:1433;databaseName=schoolNews&quot;</span>, <span class="string">&quot;数据库用户名&quot;</span>, <span class="string">&quot;数据库密码&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(ct != <span class="keyword">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库连接成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数据库连接失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确认登录信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">checkUser</span><span class="params">(String username,String password)</span> <span class="keyword">throws</span> SQLException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;正在确认登录信息&quot;</span>);</span><br><span class="line">            pestmt=ct.prepareStatement(<span class="string">&quot;select * from [User] where convert(nvarchar(255),username)=? and convert(nvarchar(255),password)=?&quot;</span>);</span><br><span class="line">            pestmt.setString(<span class="number">1</span>, username);</span><br><span class="line">            pestmt.setString(<span class="number">2</span>, password);</span><br><span class="line">            ResultSet rs=pestmt.executeQuery(); <span class="comment">// 将数据库响应的查询结果放在rs中</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据库响应结果为：&quot;</span> + rs.toString());</span><br><span class="line"></span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                user.setUsername(rs.getString(<span class="number">1</span>));<span class="comment">//第一个属性</span></span><br><span class="line">                user.setPassword(rs.getString(<span class="number">2</span>));<span class="comment">//第二个属性</span></span><br><span class="line">                System.out.println(<span class="string">&quot;用户信息为：&quot;</span> + user.getUsername() + <span class="string">&quot; &quot;</span> + user.getPassword());</span><br><span class="line">                <span class="keyword">return</span> user;	<span class="comment">///查到就返回对象</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            ct.close();</span><br><span class="line">            pestmt.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.Writer;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> model.User;</span><br><span class="line"><span class="keyword">import</span> database.userDatabase;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//设置响应头允许ajax跨域访问</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        response.setHeader(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;GET,POST&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取微信小程序get的参数值并打印</span></span><br><span class="line">        String username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        String password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;微信小程序中获得的内容为：username:&quot;</span> + username + <span class="string">&quot; password:&quot;</span> + password);</span><br><span class="line"></span><br><span class="line">        userDatabase userDatabase =<span class="keyword">new</span> userDatabase(); <span class="comment">// 建立输入信息比对对象</span></span><br><span class="line">        HttpSession session=request.getSession(); <span class="comment">// 创建保存信息对象</span></span><br><span class="line">        User user=(User) session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;<span class="comment">//第一次进入</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                user= userDatabase.checkUser(username, password);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="comment">///如果账户密码正确，把返回的对象抛给user，不正确对象则为空</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        session.setAttribute(<span class="string">&quot;user&quot;</span>, user);<span class="comment">///保存对象</span></span><br><span class="line">        Writer out = response.getWriter();</span><br><span class="line">        <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;<span class="comment">///有对象，用户名密码正确</span></span><br><span class="line">            out.write(<span class="string">&quot;success&quot;</span>);<span class="comment">//向小程序返回结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//对象为空</span></span><br><span class="line">            out.write(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request,response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-1-8-全局数据结构与该模块的关系"><a href="#2-1-8-全局数据结构与该模块的关系" class="headerlink" title="2.1.8 全局数据结构与该模块的关系"></a><strong>2.1.8 全局数据结构与该模块的关系</strong></h3><p>该模块为数据库和微信小程序相互通信的中枢模块，与数据库之间的通信通过JDBC进行，与微信小程序之间的通信依赖于微信小程序的主动访问。</p>
<h2 id="2-2-数据库设计"><a href="#2-2-数据库设计" class="headerlink" title="2.2 数据库设计"></a>2.2 数据库设计</h2><h3 id="2-2-1-数据库及数据表"><a href="#2-2-1-数据库及数据表" class="headerlink" title="2.2.1 数据库及数据表"></a><strong>2.2.1 数据库及数据表</strong></h3><p>本系统内使用的数据库系统为 Microsoft SQL Server 2019 数据库，数据库中包含表<br>User, schoolAnnouncements, schoolArticles, schoolLectures 和 schoolNews<br>五张表，分别用于用户登录鉴权、公告公示、校内通知、学术讲座和校内新闻的存储。</p>
<h3 id="2-2-2-数据结构设计"><a href="#2-2-2-数据结构设计" class="headerlink" title="2.2.2 数据结构设计"></a><strong>2.2.2 数据结构设计</strong></h3><p>五张表中，User 表的数据结构设计如表7所示，schoolAnnouncements, schoolArticles,<br>schoolLectures 和 schoolNews 表的数据结构设计如表8所示。</p>
<center>表 7 User 表的数据结构设计</center>

<div class="table-container">
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>允许Null值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>username</td>
<td>nchar(10)</td>
<td>√</td>
</tr>
<tr>
<td>password</td>
<td>ntext</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
<center>表 8 schoolAnnouncements, schoolArticles, schoolLectures 和 schoolNews
表的数据结构设计</center>

<div class="table-container">
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>数据类型</strong></th>
<th><strong>允许Null值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td>nvarchar(50)</td>
<td>√</td>
</tr>
<tr>
<td>date</td>
<td>nvarchar(50)</td>
<td>√</td>
</tr>
<tr>
<td>article</td>
<td>ntext</td>
<td>√</td>
</tr>
<tr>
<td>image</td>
<td>ntext</td>
<td>√</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>项目</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SQL Server</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 pygame 的五子棋小游戏</title>
    <url>/2021/02/02/%E9%A1%B9%E7%9B%AE-Python-Python%E4%BA%94%E5%AD%90%E6%A3%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1、摘要"><a href="#1、摘要" class="headerlink" title="1、摘要"></a>1、摘要</h1><p>&emsp;&emsp;通过python的pygame库，实现一款支持人机对战和人人对战的五子棋小游戏。在游戏初始界面会有5秒的规则介绍，五秒后自动进入人机对战模式。玩家可根据游戏中的提示按下Q键切换为初始人人对战对接，按下E键切换为初始人机对战界面。在游戏进行过程中，程序会记录并显示黑白两子的累计获胜局数，提高玩家体验。</p>
<p><strong>完整代码</strong>：<a href="https://github.com/lgc0208/Gobang">https://github.com/lgc0208/Gobang</a></p>
<span id="more"></span>
<h1 id="2、程序框架"><a href="#2、程序框架" class="headerlink" title="2、程序框架"></a><strong>2、程序框架</strong></h1><h2 id="2-1-board-py-负责棋盘类的实现"><a href="#2-1-board-py-负责棋盘类的实现" class="headerlink" title="2.1 board.py 负责棋盘类的实现"></a><strong>2.1 board.py 负责棋盘类的实现</strong></h2><blockquote>
<p>  2.1.1 __int__：构造函数，定义棋盘成员</p>
<p>  2.1.2 _getBoard(self)：返回_board成员</p>
<p>  2.1.3 ifDropChess(self, point)：判断是否可以落子</p>
<p>  2.1.4 countDirection(self, point, value, offsetX, offsetY)：判断横竖撇捺四个方向是否达成五子连珠</p>
<p>  2.1.5win(self, point)：判断是否胜利</p>
<p>  2.1.6dropChess(self, chessMan, point)：落子</p>
</blockquote>
<h2 id="2-2-machine-py-负责人机对战中机器类的实现"><a href="#2-2-machine-py-负责人机对战中机器类的实现" class="headerlink" title="2.2 machine.py 负责人机对战中机器类的实现"></a><strong>2.2 machine.py 负责人机对战中机器类的实现</strong></h2><blockquote>
<p>  2.2.1 __int__：构造函数，定义机器类成员</p>
<p>  2.2.2 getRivalDrop(self, point)：得到对手落子位置</p>
<p>  2.2.3 getPiece(self, point, offsetX, offsetY,  TorF)：判断所给位置方向上两格内的落子情况</p>
<p>  2.2.4 getDirectionScore(self, point, offsetX, offsetY)：统计所给方向上的棋子权重值</p>
<p>  2.2.5 getPointScore(self, point)：统计机器落子优先级</p>
<p>  2.2.6 machineDrop(self)：机器落子</p>
</blockquote>
<h2 id="2-3-五子棋-py-负责串联起整个程序的实现"><a href="#2-3-五子棋-py-负责串联起整个程序的实现" class="headerlink" title="2.3 五子棋.py 负责串联起整个程序的实现"></a><strong>2.3 五子棋.py 负责串联起整个程序的实现</strong></h2><blockquote>
<p>  2.3.1 printText(screen, font, x, y, text, textColor = (255, 255,  255))：文字打印函数：在屏幕的(x,y)处打印文字，文字颜色默认为白色</p>
<p>  2.3.2 drawBoard(screen)：刻画棋盘</p>
<p>  2.3.3 drawChess(screen, Point, pieceColor)：绘制棋子</p>
<p>  2.3.4 drawChessInformation(screen, pos, color)：绘制填充的圆形</p>
<p>  2.3.5 getNextRunner(currentRunner)：返回下一个执子方</p>
<p>  2.3.6 drawInfomation(screen, font, currentRunner, SumOfBlackWin,  SumOfWhiteWin)：绘制信息栏</p>
<p>  2.3.7 getClick(clickPlace)：获取鼠标点击位置</p>
<p>  2.3.8 main()：主函数</p>
</blockquote>
<h1 id="3、关键代码实现"><a href="#3、关键代码实现" class="headerlink" title="3、关键代码实现"></a><strong>3、关键代码实现</strong></h1><h2 id="3-1-getDirectionScore-self-point-offsetX-offsetY"><a href="#3-1-getDirectionScore-self-point-offsetX-offsetY" class="headerlink" title="3.1 getDirectionScore(self, point, offsetX, offsetY)"></a><strong>3.1 getDirectionScore(self, point, offsetX, offsetY)</strong></h2><h3 id="3-1-1基本思想"><a href="#3-1-1基本思想" class="headerlink" title="3.1.1基本思想"></a><strong>3.1.1基本思想</strong></h3><p>&emsp;&emsp;先设定偏移量offset分别为(1, 0), (0, 1), (1, 1), (1, -1)，便于统计横竖撇捺四个方向上的棋子权重值。再根据每个方向上是否有棋子、棋子的种类和个数、棋子之间的空格数分别设定不同的权重值。根据权重值可以实现机器与人对战的效果。</p>
<p><strong>3.1.2具体实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计某方向棋子权重值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDirectionScore</span>(<span class="params">self, point, offsetX, offsetY</span>):</span></span><br><span class="line">    countSelf = <span class="number">0</span>   <span class="comment"># 落子处我方连续子数</span></span><br><span class="line">    countOpposite = <span class="number">0</span>  <span class="comment"># 落子处对方连续子数</span></span><br><span class="line">    spaceSelf = <span class="literal">None</span>   <span class="comment"># 我方连续子中有无空格</span></span><br><span class="line">    spaceOpposite = <span class="literal">None</span>  <span class="comment"># 对方连续子中有无空格</span></span><br><span class="line">    blockSelf = <span class="number">0</span>    <span class="comment"># 我方连续子两端有无阻挡</span></span><br><span class="line">    blockOpposite = <span class="number">0</span>   <span class="comment"># 对方连续子两端有无阻挡</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果是 1 表示是边上是我方子，2 表示敌方子， 0表示无子</span></span><br><span class="line">    flagPositive = self.getPiece(point, offsetX, offsetY, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> flagPositive != <span class="number">0</span>: <span class="comment"># 传入的偏移方向上若存在棋子</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>): <span class="comment"># 循环判断该方向连着几个棋子</span></span><br><span class="line">            x = point.X + i * offsetX </span><br><span class="line">            y = point.Y + i * offsetY </span><br><span class="line">            <span class="comment"># 若加上偏移量后仍在棋盘内</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; self._pointNumber <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; self._pointNumber:</span><br><span class="line">                <span class="keyword">if</span> flagPositive == <span class="number">1</span>: <span class="comment"># 若该偏移方向两格内有我方棋子</span></span><br><span class="line">                    <span class="keyword">if</span> self._board[y][x] == self._my.Value: <span class="comment">#若该位置有我方棋子</span></span><br><span class="line">                        countSelf += <span class="number">1</span> <span class="comment"># 我方连续棋子数+1</span></span><br><span class="line">                        <span class="keyword">if</span> spaceSelf <span class="keyword">is</span> <span class="literal">False</span>: <span class="comment"># 若已经出现过空格，且探测到我方棋子</span></span><br><span class="line">                            spaceSelf = <span class="literal">True</span>  <span class="comment"># 空格出现在我方连续棋子之间</span></span><br><span class="line">                    <span class="keyword">elif</span> self._board[y][x] == self._rival.Value: <span class="comment"># 若该位置是敌方棋子</span></span><br><span class="line">                        blockOpposite += <span class="number">1</span> <span class="comment"># 敌方棋子受阻挡+1</span></span><br><span class="line">                        <span class="keyword">break</span> <span class="comment"># 落子后我方安全，跳出循环</span></span><br><span class="line">                    <span class="keyword">else</span>: <span class="comment"># 若该位置不存在棋子</span></span><br><span class="line">                        <span class="keyword">if</span> spaceSelf <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 第一次检测到空格时生效</span></span><br><span class="line">                            spaceSelf = <span class="literal">False</span> <span class="comment"># 表示存在空格但不在白子之间</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span>   <span class="comment"># 遇到第二个空格退出循环</span></span><br><span class="line">                <span class="keyword">elif</span> flagPositive == <span class="number">2</span>: <span class="comment"># 若该偏移方向上有敌方棋子</span></span><br><span class="line">                    <span class="keyword">if</span> self._board[y][x] == self._my.Value:</span><br><span class="line">                        blockOpposite += <span class="number">1</span> <span class="comment"># 敌方受阻挡+1</span></span><br><span class="line">                        <span class="keyword">break</span> <span class="comment"># 我方安全，跳出循环</span></span><br><span class="line">                    <span class="keyword">elif</span> self._board[y][x] == self._rival.Value: <span class="comment"># 该位置存在敌方棋子</span></span><br><span class="line">                        countOpposite += <span class="number">1</span> <span class="comment"># 敌方连续棋子数+1</span></span><br><span class="line">                        <span class="keyword">if</span> spaceOpposite <span class="keyword">is</span> <span class="literal">False</span>: <span class="comment"># 若第二次出现空格</span></span><br><span class="line">                            spaceOpposite = <span class="literal">True</span> <span class="comment"># 对方连续棋子内出现空格事件为</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> spaceOpposite <span class="keyword">is</span> <span class="literal">None</span>: <span class="comment"># 若第一次出现空格</span></span><br><span class="line">                            spaceOpposite = <span class="literal">False</span> <span class="comment"># 敌方连续棋子内还未出现空格</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span> <span class="comment"># 若在出现敌方棋子前又出现空格，我方安全，跳出循环</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 偏移后触碰到棋盘边界</span></span><br><span class="line">                <span class="keyword">if</span> flagPositive == <span class="number">1</span>: <span class="comment"># 若为己方棋子</span></span><br><span class="line">                    blockSelf += <span class="number">1</span> <span class="comment"># 己方棋子被堵塞量+1</span></span><br><span class="line">                <span class="keyword">elif</span> flagPositive == <span class="number">2</span>: <span class="comment"># 若为敌方棋子</span></span><br><span class="line">                    blockOpposite += <span class="number">1</span> <span class="comment"># 敌方棋子被堵塞量+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> spaceSelf <span class="keyword">is</span> <span class="literal">False</span>: <span class="comment"># 若己方连续棋子内不存在空格</span></span><br><span class="line">        spaceSelf = <span class="literal">None</span> <span class="comment"># 重置</span></span><br><span class="line">    <span class="keyword">if</span> spaceOpposite <span class="keyword">is</span> <span class="literal">False</span>: <span class="comment"># 若对方连续棋子内不存在空格</span></span><br><span class="line">        spaceOpposite = <span class="literal">None</span> <span class="comment"># 重置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将设定的偏移量里的X,Y增量取反，重复上述操作</span></span><br><span class="line">    flagNegative = self.getPiece(point, -offsetX, -offsetY, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> flagNegative != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">            x = point.X - i * offsetX</span><br><span class="line">            y = point.Y - i * offsetY</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; self._pointNumber <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; self._pointNumber:</span><br><span class="line">                <span class="keyword">if</span> flagNegative == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">if</span> self._board[y][x] == self._my.Value:</span><br><span class="line">                        countSelf += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> spaceSelf <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                            spaceSelf = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">elif</span> self._board[y][x] == self._rival.Value:</span><br><span class="line">                        blockOpposite += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> spaceSelf <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                            spaceSelf = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span>   <span class="comment"># 遇到第二个空格退出</span></span><br><span class="line">                <span class="keyword">elif</span> flagNegative == <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">if</span> self._board[y][x] == self._my.Value:</span><br><span class="line">                        blockOpposite += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">elif</span> self._board[y][x] == self._rival.Value:</span><br><span class="line">                        countOpposite += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> spaceOpposite <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">                            spaceOpposite = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">if</span> spaceOpposite <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                            spaceOpposite = <span class="literal">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> flagNegative == <span class="number">1</span>:</span><br><span class="line">                    blockSelf += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> flagNegative == <span class="number">2</span>:</span><br><span class="line">                    blockOpposite += <span class="number">1</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    权重值划分：</span></span><br><span class="line"><span class="string">    （己方连续四子&gt;敌方连续四子）&gt;（己方连续三子无阻挡&gt;敌方连续三子无阻挡）&gt;（己方连续三子有一个阻挡&amp;&amp;己方连续两子无阻挡</span></span><br><span class="line"><span class="string">    &gt;敌方连续三子有阻挡&amp;&amp;敌方连续两子无阻挡）&gt;（己方连续两子有阻挡&gt;敌方连续两子有阻挡）</span></span><br><span class="line"><span class="string">    无空格&gt;有空格，两种情况应在同一数量级（紧跟在括号后）</span></span><br><span class="line"><span class="string">    优先级量化 8 10 80 100 800 1000 8000 10000 五组（当数值相近的时候会变成人工智障，不知为啥）</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    score = <span class="number">0</span> <span class="comment"># 初始化权重值，判断落子选择的优先级</span></span><br><span class="line">    <span class="keyword">if</span> countSelf == <span class="number">4</span>: <span class="comment"># 若己方连续四子</span></span><br><span class="line">        score = <span class="number">10000</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">    <span class="keyword">elif</span> countOpposite == <span class="number">4</span>: <span class="comment"># 若敌方连续四子</span></span><br><span class="line">        score = <span class="number">8000</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">    <span class="keyword">elif</span> countSelf == <span class="number">3</span>: <span class="comment"># 若我方连续三子</span></span><br><span class="line">        <span class="keyword">if</span> blockSelf == <span class="number">0</span>: <span class="comment"># 若我方连续三子无阻挡</span></span><br><span class="line">            score = <span class="number">1000</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">        <span class="keyword">elif</span> blockSelf == <span class="number">1</span>: <span class="comment"># 若我方连续三子中有一个阻挡</span></span><br><span class="line">            score = <span class="number">100</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            score = <span class="number">0</span> <span class="comment"># 优先级最低</span></span><br><span class="line">    <span class="keyword">elif</span> countOpposite == <span class="number">3</span>: <span class="comment"># 若敌方连续三子</span></span><br><span class="line">        <span class="keyword">if</span> blockOpposite == <span class="number">0</span>: <span class="comment"># 若敌方连续三子无阻挡</span></span><br><span class="line">            score = <span class="number">800</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">        <span class="keyword">elif</span> blockOpposite == <span class="number">1</span>: <span class="comment"># 若敌方连续三子中有一个阻挡</span></span><br><span class="line">            score = <span class="number">80</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            score = <span class="number">0</span> <span class="comment"># 优先级最低</span></span><br><span class="line">    <span class="keyword">elif</span> countSelf == <span class="number">2</span>: <span class="comment"># 若己方连续两子</span></span><br><span class="line">        <span class="keyword">if</span> blockSelf == <span class="number">0</span>: <span class="comment"># 若己方两子间没有阻挡</span></span><br><span class="line">            score = <span class="number">100</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">        <span class="keyword">elif</span> blockSelf == <span class="number">1</span>: <span class="comment"># 若两子间有一个阻挡</span></span><br><span class="line">            score = <span class="number">80</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            score = <span class="number">0</span> <span class="comment"># 优先级最低</span></span><br><span class="line">    <span class="keyword">elif</span> countOpposite == <span class="number">2</span>: <span class="comment"># 若敌方连续两子</span></span><br><span class="line">        <span class="keyword">if</span> blockOpposite == <span class="number">0</span>: <span class="comment"># 若敌方两子间没有阻挡</span></span><br><span class="line">            score = <span class="number">10</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">        <span class="keyword">elif</span> blockOpposite == <span class="number">1</span>: <span class="comment"># 若敌方两子间有一个阻挡</span></span><br><span class="line">            score = <span class="number">8</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            score = <span class="number">0</span> <span class="comment"># 优先级为0</span></span><br><span class="line">    <span class="keyword">elif</span> countSelf == <span class="number">1</span>: <span class="comment"># 若己方只有单个落子</span></span><br><span class="line">        score = <span class="number">10</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">    <span class="keyword">elif</span> countOpposite == <span class="number">1</span>: <span class="comment"># 若对方只有单个落子</span></span><br><span class="line">        score = <span class="number">8</span> <span class="comment"># 优先级参考备注</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        score = <span class="number">0</span> <span class="comment"># 优先级最低</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> spaceSelf <span class="keyword">or</span> spaceOpposite: <span class="comment"># 若己方或对方连续棋子内存在空格</span></span><br><span class="line">        score /= <span class="number">2</span> <span class="comment"># 优先级降低</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> score <span class="comment"># 返回优先级</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-countDirection-self-point-value-offsetX-offsetY"><a href="#3-2-countDirection-self-point-value-offsetX-offsetY" class="headerlink" title="3.2 countDirection(self, point, value, offsetX, offsetY)"></a><strong>3.2 countDirection(self, point, value, offsetX, offsetY)</strong></h2><h3 id="3-2-1基本思想"><a href="#3-2-1基本思想" class="headerlink" title="3.2.1基本思想"></a><strong>3.2.1基本思想</strong></h3><p>&emsp;&emsp;设定循环，判断棋子的横竖撇捺八个方向是否存在五个相同的棋子，若存在，则获胜。</p>
<h3 id="3-2-2具体实现"><a href="#3-2-2具体实现" class="headerlink" title="3.2.2具体实现"></a><strong>3.2.2具体实现</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过横竖撇捺四个方向计算是否五子连珠</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">countDirection</span>(<span class="params">self, point, value, offsetX, offsetY</span>):</span></span><br><span class="line">       count = <span class="number">1</span> <span class="comment"># 计算连珠个数</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment"># 判断所下棋子右侧是否五子连珠</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">           x = point.X + i*offsetX</span><br><span class="line">           y = point.Y + i*offsetY</span><br><span class="line">           <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; self._linePoints \</span><br><span class="line">           <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; self._linePoints \</span><br><span class="line">           <span class="keyword">and</span> value == self._board[y][x]:</span><br><span class="line">               count += <span class="number">1</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           </span><br><span class="line">       <span class="comment"># 判断所下棋子左侧是否五子连珠</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">           x = point.X - i*offsetX</span><br><span class="line">           y = point.Y - i*offsetY</span><br><span class="line">           <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; self._linePoints \</span><br><span class="line">               <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; self._linePoints \</span><br><span class="line">               <span class="keyword">and</span> value == self._board[y][x]:</span><br><span class="line">               count += <span class="number">1</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">break</span></span><br><span class="line">           </span><br><span class="line">       judgeWin = (count &gt;= <span class="number">5</span>) <span class="comment"># 判断是否达成五子连珠，达成为True</span></span><br><span class="line">       <span class="keyword">return</span> judgeWin <span class="comment"># 返回判断结果</span></span><br></pre></td></tr></table></figure>
<h2 id="3-3-getClick-clickPlace"><a href="#3-3-getClick-clickPlace" class="headerlink" title="3.3 getClick(clickPlace)"></a><strong>3.3 getClick(clickPlace)</strong></h2><h3 id="3-2-1基本思想-1"><a href="#3-2-1基本思想-1" class="headerlink" title="3.2.1基本思想"></a><strong>3.2.1基本思想</strong></h3><p>&emsp;&emsp;通过pygame库获取鼠标的点击位置，并根据棋盘建立时设置的长、宽、高将其转换为棋盘上的坐标，从而方便进行棋子的绘制。</p>
<h3 id="3-2-2具体实现-1"><a href="#3-2-2具体实现-1" class="headerlink" title="3.2.2具体实现"></a><strong>3.2.2具体实现</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取鼠标点击位置，传入参数为pygame库获取的鼠标点击位置</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getClick</span>(<span class="params">clickPlace</span>):</span> </span><br><span class="line">    placeX = clickPlace[<span class="number">0</span>] - BOARD_START_PLACE <span class="comment"># 点击的位置在棋盘中的横坐标</span></span><br><span class="line">    placeY = clickPlace[<span class="number">1</span>] - BOARD_START_PLACE <span class="comment"># 点击的位置在棋盘中的纵坐标</span></span><br><span class="line">    <span class="keyword">if</span> placeX &lt; -INSIDE_WIDTH <span class="keyword">or</span> placeY &lt; -INSIDE_WIDTH: <span class="comment"># 若越界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    x = placeX // POINT_SIZE <span class="comment"># 以棋子的大小为单位计算</span></span><br><span class="line">    y = placeY // POINT_SIZE</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 修正点击位置，当用户点击位置与交点有偏差时自动修正</span></span><br><span class="line">    <span class="keyword">if</span> placeX % POINT_SIZE &gt; PIECE_RADIUS_LEFT: </span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> placeY % POINT_SIZE &gt; PIECE_RADIUS_LEFT:</span><br><span class="line">        y += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= POINT_NUMBER <span class="keyword">or</span> y &gt;= POINT_NUMBER: <span class="comment"># 恰好在中间位置时不修正</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> Point(x, y) <span class="comment"># 返回游戏区的坐标</span></span><br></pre></td></tr></table></figure>
<h1 id="4、不足"><a href="#4、不足" class="headerlink" title="4、不足"></a>4、不足</h1><p>&emsp;&emsp;在代码的编写过程中，由于许多基础知识的不熟练，导致了很多基础语法都需要上网去查相关的用法。此外，虽然对人机对战中的机器人进行了很多版的迭代，也参考了网络上前人使用的设置权值的方式进行判断，但是还是能够比较轻松地胜过电脑。对于电脑落子的算法还有很大提升空间。</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>基于微信小程序的垃圾分类移动应用</title>
    <url>/2020/08/20/%E9%A1%B9%E7%9B%AE-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%9E%83%E5%9C%BE%E5%88%86%E7%B1%BB%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>基于天行API和微信小程序的垃圾分类小程序，支持文字和图像识别</p>
<p><strong>项目地址</strong>：<a href="https://github.com/lgc0208/GarbageClassification">https://github.com/lgc0208/GarbageClassification</a></p>
<span id="more"></span>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>微信开发者工具 1.3.0.0</li>
</ul>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h3><ul>
<li>可通过文字输入获得垃圾分类结果</li>
<li>可通过图像识别获得垃圾分类结果</li>
<li>含有垃圾分类知识问答</li>
</ul>
<h3 id="运行说明"><a href="#运行说明" class="headerlink" title="运行说明"></a>运行说明</h3><ol>
<li>打开 <code>垃圾分类小程序/utils/utils.js</code>，添加接口域名 <code>TXAPI_BASE_URL</code> 和 api_key <code>TXAPI_KEY</code></li>
<li>使用微信开发者工具打开项目文件即可使用</li>
</ol>
]]></content>
      <categories>
        <category>项目</category>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Verilog 和 EPM1270T144C5 的简易电子琴</title>
    <url>/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次实验使用硬件描述语言 Verilog HDL，针对以 Altera 公司的 MAX II 系列可编程器件 EPM1270T144C5 为核心芯片的可编程器件实验板设计实验简易电子演奏琴。</p>
<span id="more"></span>
<p>其基本功能如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）通过用 8×8 点阵显示“1 2 3 4 5 6 7”七个音符构成的电子琴键盘。其中点阵的第 一列用一个 LED 点亮表示音符“1”，第二列用二个 LED 点亮表示音符“2”，依此类推，如图 1 所示。当音符为低音 1~7 时，点阵显示为绿色；当音符为中音 1~7 时，点阵显示为红色； 当音符为高音 1~7 时，点阵显示为黄色。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）用 BTN7～BTN1 七个按键模拟电子琴手动演奏时的“1 2 3 4 5 6 7”七个音符。当 某个按键按下时，数码管 DISP7 显示相应的音符，点阵上与之对应的音符显示列全灭，同 时蜂鸣器演奏相应的声音；当按键放开时数码管显示的音符灭掉，点阵显示恢复，蜂鸣器停 止声音的输出。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）由拨码开关切换选择高、中、低音，点阵颜色进行相应变化。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（4）可通过拨码开关 SW0 进行手动/自动演奏的切换，自动演奏时，点阵根据乐曲进 行颜 色和亮灭的变化。 该实验设计过程中，将整个门铃分为 8 个模块：分频模块，演奏模块，点阵显示模块， 数码管显示模块。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后通过对程序的调试、相应部分功能的仿真以及在电路板的烧写，验证了整个系统的原理和本设计方案的正确性。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><strong>完整工程文件：</strong> <a href="https://github.com/lgc0208/electronic_organ">https://github.com/lgc0208/electronic_organ</a><br>&nbsp;</p>
<h1 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="1 背景介绍"></a>1 背景介绍</h1><h2 id="1-1-相关知识"><a href="#1-1-相关知识" class="headerlink" title="1.1 相关知识"></a>1.1 相关知识</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据声乐知识，产生音乐的两个因素是音乐频率的持续时间，音乐的十二平均率规定， 每两个八音度之间的频率相差一倍，在两个八音度之间，又可分为 12 个半音。每两个半音 的频率比为 4。另外，音名 A（乐谱中的低音 6）的频率为 440HZ，音名 B 到 C 之间，E 到 F 之间为半音，其余为全音。由此可以计算出乐谱中从低音 1 到高音 1 之间每个音名的频率如表1所示</p>
<center><b>表1 简谱中音名与频率的关系<b></b></b></center>


<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387085671228.png" alt=" "></p>
<h2 id="1-2-基本要求"><a href="#1-2-基本要求" class="headerlink" title="1.2 基本要求"></a>1.2 基本要求</h2><h3 id="1-2-1-点阵显示"><a href="#1-2-1-点阵显示" class="headerlink" title="1.2.1 点阵显示"></a>1.2.1 点阵显示</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用 8×8 点阵显示“1 2 3 4 5 6 7”七个音符构成的电子琴键盘。其中点阵的第一列用一个 LED 点亮表示音符“1”，第二列用二个 LED 点亮表示音符“2”，依此类推，如图 1 所示。当音符为低音 1~7 时，点阵显示为绿色；当音符为中音 1~7 时，点阵显示为红色；当音符为高音 1~7 时，点阵显示为黄色；如图1所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/20210130212904672.png" alt=" "></p>
<center><b>图 1 点阵显示<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="1-2-2-按键按下后的点阵显示"><a href="#1-2-2-按键按下后的点阵显示" class="headerlink" title="1.2.2 按键按下后的点阵显示"></a>1.2.2 按键按下后的点阵显示</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用 BTN7～BTN1 七个按键模拟电子琴手动演奏时的“1 2 3 4 5 6 7”七个音符。当 某个按键按下时，数码管 DISP7 显示相应的音符，点阵上与之对应的音符显示列全灭，同时蜂鸣器演奏相应的声音；当按键放开时数码管显示的音符灭掉，点阵显示恢复，蜂鸣器停止声音的输出。图 2 为演奏中音 3（BTN5 按下）时点阵的显示情况。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/20210130213308621.png" alt=" "></p>
<center><b>图 2 按键按下后的点阵显示<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="1-2-3-高中低音切换"><a href="#1-2-3-高中低音切换" class="headerlink" title="1.2.3 高中低音切换"></a>1.2.3 高中低音切换</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由拨码开关切换选择高、中、低音，点阵颜色进行相应变化。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="1-2-4-自动、手动演奏切换"><a href="#1-2-4-自动、手动演奏切换" class="headerlink" title="1.2.4 自动、手动演奏切换"></a>1.2.4 自动、手动演奏切换</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可通过一个拨码开关进行手动/自动演奏的切换，自动演奏时，点阵根据乐曲进行颜色和亮灭的变化。<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h1 id="2-Verilog-HDL语言介绍"><a href="#2-Verilog-HDL语言介绍" class="headerlink" title="2 Verilog HDL语言介绍"></a>2 Verilog HDL语言介绍</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verilog HDL是硬件描述语言的一种，用于数字电子系统设计。它允许设计者用它来进行各种级别的逻辑设计，可以用它进行数字逻辑系统的仿真验证、时序分析、逻辑综合。它是目前应用最广泛的一种硬件描述语言之一。<br>&nbsp;</p>
<h1 id="3-系统设计"><a href="#3-系统设计" class="headerlink" title="3 系统设计"></a>3 系统设计</h1><h2 id="3-1-设计思路"><a href="#3-1-设计思路" class="headerlink" title="3.1 设计思路"></a>3.1 设计思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对本实验所需要实现的基本要求，笔者将设计任务拆分为点阵扫描模块、数码管显示模块、音乐播放模块三大模块进行设计。其中，该设计的顶层模块与音乐播放模块直接相连，即将输入和输出与音乐播放模块直接关联。在音乐播放模块中，根据得到的输入信号的不同决定所播放的音调和传递给点阵扫描模块、数码管显示模块的参数，从而完成实验题目所需要满足的基本要求。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="3-1-1-点阵的显示"><a href="#3-1-1-点阵的显示" class="headerlink" title="3.1.1 点阵的显示"></a>3.1.1 点阵的显示</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;点阵模块在可编程实验板上使用的是 8×8 红绿双色点阵，由8行8列共 64 个红色发光二极管和 8 行 8 列 64 个绿色发光二极管封装在一元器件上面构成的。元器件对外引出 24 条控制线，分别为行信号（发光二极管公共端）ROW7－ROW0、红色发光二极管列信号 R_COL7－R_COL0 和绿色发光二极管列信号 G_COL7－G_COL0。点阵模块的构造示意图如图 3 所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387084723924.png" alt=" "></p>
<center><b>图 3 点阵模块的构造示意图<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>由图3可以得出：<br>（1）点阵上某个点显示红色的条件：控制该点行的引脚输出低电平，控制该点红色发光二极管列信号引脚输出高电平，控制该点绿色发光二极管列信号引脚输出低电平。<br>（2）点阵上某个点显示绿色的条件：控制该点行的引脚输出低电平，控制该点红色发光二极管列信号引脚输出低电平，控制该点绿色发光二极管列信号引脚输出 高电平。<br>（3）点阵上某个点显示黄色的条件：控制该点行的引脚输出低电平，控制该点红色发光二极管列信号引脚输出高电平，控制该点绿色发光二极管列信号引脚输出高电平。<br>由于该可编程实验班的点阵中，绿色发出的光强明显低于红色发出的光强，因此在产生黄色的时候，需要对红光和绿光进行分频。经过试验发现，当红光和绿光的占空比为1:3时，产生的效果较为明显。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于上述知识，再利用人眼的视觉暂留现象，使用1MHZ的系统时钟，对点阵进行行扫描，即可轻松地显示所需要的图像。具体的实现方法笔者将在3.2节中详细介绍。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="3-1-2-数码管的显示"><a href="#3-1-2-数码管的显示" class="headerlink" title="3.1.2 数码管的显示"></a>3.1.2 数码管的显示</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7 段数码管模块由8个7段数码管组成，数码管编号分别为DISP7－DISP0。在数码管右边电路板上有各段的编号图示。本开发板上8个7段数码管的段码输入端是并联在一起的，8个位码相互独立。当 AA－AP 控制引脚输出高电平，同时需要显示的数码管的共阴极端 CAT为低电平时，该数码管相应的端就点亮。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据该可编程实验板的特点，当使用数码管DS6和DS7时应将拨码开关SW10的第3位和第4位拨到上边。当拨码开关SW10的第3位和第4位拨到下边时数码管DS6和DS7的位码控制端CAT6和CAT7不受EPM1270T144C5 芯片的引脚PIN_30和PIN_31控制，此时EPM1270T144C5芯片的引脚PIN_30和PIN_31作为外部扩展接口使用。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数码管显示的原理图如图4所示。根据原理图和可编程实验板的说明书，点亮相应位置的段码即可在数码管上呈现出所需要的数字。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387084358022.png" alt=" "></p>
<center><b>图 4 数码管显示的原理图<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="3-1-3-音调的控制"><a href="#3-1-3-音调的控制" class="headerlink" title="3.1.3 音调的控制"></a>3.1.3 音调的控制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;频率的高低决定了音调的高低。音乐的十二平均率规定：每两个 8 度音（如简谱中的中音 1 与高音 1）之间的频率相差一倍。在两个 8度音之间，又可分为 12个半音，每两个半音的频率比为 $12\sqrt{2}$。 另外，音名 A(简谱中的低音 6)的频率为 440Hz，音名 B到 C之间、E到 F之间为半音，其余为全音。简谱中音名与频率的关系如1.1节中表1所示。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有不同频率的信号都是从同一个基准频率分频得到的。由于音阶频率多为非整数，而分频系数又不能为小数，故必须将计算得到的分频数四舍五入取整。若基准频率过低，则由于分频比太小，四舍五入取整后的误差较大；若基准频率过高，虽然误差变小，但分频数将变大。实际的设计综合考虑这两方面的因素，在尽量减小频率误差的前提下取合适的基准频率。基于点阵显示模块对于系统时钟的要求，本实验中笔者对1MHZ的时钟进行分频，进而输出到发声器件。实际上，只要各个音名间的相对频率关系不变，演奏出的乐曲听起来都不会 “走调”。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本实验需要演奏从低音1到高音7跨越三个八度的音符，因此通过简单的计算可以得出，在基准频率为1MHZ时，简谱中各音阶相应的分频系数如表2所示。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<center><b>表 2 简谱中各音阶相应的分频系数<b></b></b></center>


<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387084005020.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，对于乐曲中的休止符，只需要将输出到发声器件的变量赋值为0，发声器件便不会发出声音。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="3-1-4-音长的控制"><a href="#3-1-4-音长的控制" class="headerlink" title="3.1.4 音长的控制"></a>3.1.4 音长的控制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;音符的持续时间必须根据乐曲的速度及每个音符的节拍数来确定。该实验中音长的控制主要应用于自动演奏模块中。本实验演奏的《天空之城》片段，最短的音符为4分音符，假设一个全音符持续的时间为1秒，则4分音符所需要持续的时间为0.25秒，即需要通过分频提供一个4HZ的时钟信号，从而控制音长。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;控制音长是通过控制计数器预置数的停留时间来实现的，预置数停留的时间越长，则该音符演奏的时间越长。每个音符的演奏时间都是0.25秒的整数倍，对于节拍较长的音符，如 2 分音符，在自动播放的时候连续输出两次该音符即可。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h2 id="3-2-总体框图"><a href="#3-2-总体框图" class="headerlink" title="3.2 总体框图"></a>3.2 总体框图</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该实验设计时的总体技术框图如图5所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387083617918.png" alt=" " style="zoom: 25%;"></p>
<center><b>图 5 总体技术框图<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h2 id="3-3-分块设计"><a href="#3-3-分块设计" class="headerlink" title="3.3 分块设计"></a>3.3 分块设计</h2><h3 id="3-3-1-顶层模块"><a href="#3-3-1-顶层模块" class="headerlink" title="3.3.1 顶层模块"></a>3.3.1 顶层模块</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clk 表示输入时钟信号，本实验中选用的是 1MHZ 的系统时钟。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto_sw 表示自动播放开关，当 auto_sw 为 1 时，开始自动播放乐曲《天空之城》；当 auto_sw 为 0 时，为手动演奏状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SW 表示手动演奏的音域切换。当 SW=3’b100 时，演奏低音音域；当 SW=3’b010 时， 演奏中音音域；当 SW=3’b001 时，演奏高音音域。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BTN 表示手动演奏的音符。BTN[0]至 BTN[6]分别表示音符 1、2、3、4、5、6、7，按 下按键时蜂鸣器即产生响应的音符。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;beep 表示输出给蜂鸣器的信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;row, col_r, col_g 分别表示输出给点阵列的行、列信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg 表示控制八段数码管的输出信号，CAT 为控制八段数码管的共阴极端信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于该模块为程序的顶层模块，因此主要功能为定义输入输出信号和调用功能模块。具体的Verilog HDL语言实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="comment">//电子琴顶层模块  </span></span><br><span class="line"><span class="number">2.</span>	<span class="function"><span class="keyword">module</span> <span class="title">electronic_organ</span><span class="params">(clk, auto_sw, SW, BTN,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">3.</span>	                            beep, row, col_r, col_g, seg, CAT)</span></span>;                   </span><br><span class="line"><span class="number">4.</span>	input [<span class="number">2</span>:<span class="number">0</span>]SW;  </span><br><span class="line"><span class="number">5.</span>	input [<span class="number">6</span>:<span class="number">0</span>]BTN;  </span><br><span class="line"><span class="number">6.</span>	input clk, auto_sw;  </span><br><span class="line"><span class="number">7.</span>	output beep; <span class="comment">//蜂鸣器初始化  </span></span><br><span class="line"><span class="number">8.</span>	output [<span class="number">7</span>:<span class="number">0</span>]row, col_r, col_g, seg;  </span><br><span class="line"><span class="number">9.</span>	output reg [<span class="number">7</span>:<span class="number">0</span>]CAT = <span class="number">7&#x27;b</span>0111_1111; <span class="comment">//仅7号数码管亮                 </span></span><br><span class="line"><span class="number">10.</span>	  </span><br><span class="line"><span class="number">11.</span>	<span class="comment">//输出音调  </span></span><br><span class="line"><span class="number">12.</span>	<span class="function">play <span class="title">p1</span><span class="params">(.clk(clk),   </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">13.</span>	          .auto_sw(auto_sw),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">14.</span>	          .key(BTN),   </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">15.</span>	          .SW(SW),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">16.</span>	          .beep(beep),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">17.</span>	          .row(row),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">18.</span>	         .col_r(col_r),   </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">19.</span>	          .col_g(col_g),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">20.</span>	          .seg(seg))</span></span>;  </span><br><span class="line"><span class="number">21.</span>	            </span><br><span class="line"><span class="number">22.</span>	  </span><br><span class="line"><span class="number">23.</span>	endmodule  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="3-3-2-分频模块"><a href="#3-3-2-分频模块" class="headerlink" title="3.3.2 分频模块"></a>3.3.2 分频模块</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 由于本实验中需要发出不同音调的声音，分频模块是必不可少的一个模块。笔者使用的是计数器对时钟信号进行分频。其中，clk表示输入的系统时钟信号，clk_out表示分频后输出的时钟信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在该模块设计中，笔者首先定义一个用于分频输出的时钟信号clk_out，计数器随着系统时钟工作，计数器计数达到预置位前，clk_out始终保持原值。当计数达到预置位时，将clk_out翻转一次，从而可以通过改变预置位得到需要频率的时钟信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该模块具体的Verilog HDL语言实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="comment">/* </span></span><br><span class="line"><span class="comment">2.	*   Name: division.v </span></span><br><span class="line"><span class="comment">3.	*   Author: lgc0208</span></span><br><span class="line"><span class="comment">4.	*   Date: 2020-11-22 </span></span><br><span class="line"><span class="comment">5.	*   Function: 时钟分频,对时钟信号进行分频，输出信号为输入信号频率的1/2DIV_NUM倍 </span></span><br><span class="line"><span class="comment">6.	*   Input: 时钟信号clk </span></span><br><span class="line"><span class="comment">7.	*   Output: 分频后的信号clk_out </span></span><br><span class="line"><span class="comment">8.	*/</span>  </span><br><span class="line"><span class="number">9.</span>	<span class="function"><span class="keyword">module</span> <span class="title">division</span><span class="params">(clk, clk_out)</span></span>;  </span><br><span class="line"><span class="number">10.</span>	      </span><br><span class="line"><span class="number">11.</span>	    parameter DIV_NUM = <span class="number">1</span>; <span class="comment">//对时钟进行分频  </span></span><br><span class="line"><span class="number">12.</span>	      </span><br><span class="line"><span class="number">13.</span>	    input clk;  </span><br><span class="line"><span class="number">14.</span>	    output reg clk_out;  </span><br><span class="line"><span class="number">15.</span>	    reg [<span class="number">19</span>:<span class="number">0</span>]count;  </span><br><span class="line"><span class="number">16.</span>	      </span><br><span class="line"><span class="number">17.</span>	    always@(posedge clk)  </span><br><span class="line"><span class="number">18.</span>	    begin  </span><br><span class="line"><span class="number">19.</span>	        <span class="keyword">if</span>(count == DIV_NUM)  </span><br><span class="line"><span class="number">20.</span>	        begin  </span><br><span class="line"><span class="number">21.</span>	            clk_out &lt;= !clk_out;  </span><br><span class="line"><span class="number">22.</span>	            count &lt;= <span class="number">0</span>;  </span><br><span class="line"><span class="number">23.</span>	        end  </span><br><span class="line"><span class="number">24.</span>	        <span class="keyword">else</span>  </span><br><span class="line"><span class="number">25.</span>	            count &lt;= count + <span class="number">1</span>;  </span><br><span class="line"><span class="number">26.</span>	    end  </span><br><span class="line"><span class="number">27.</span>	      </span><br><span class="line"><span class="number">28.</span>	endmodule  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="3-3-3-点阵列扫描模块"><a href="#3-3-3-点阵列扫描模块" class="headerlink" title="3.3.3 点阵列扫描模块"></a>3.3.3 点阵列扫描模块</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在本实验中，点阵列的显示需要随着音调的变化而产生相应的变化，因此需要点阵列扫描模块来实现相应的功能。在点阵列的显示中，常用的扫描方式有行扫描和列扫描。使用列扫描时，容易出现同一列的灯光颜色亮度有较大差异，因此笔者此处选择了行扫描的方式扫描点阵。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 同时，由于该实验所使用的可编程实验板点阵列中绿光的强度要明显低于红光，因此在产生黄光时需要对绿光和红光进行占空比的调整。在实验中发现，红光和绿光占空比为1:3时产生的效果较好。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该模块中，clk表示输入的时钟信号，SW表示颜色显示的切换信号，key表示所获得的按键信号，row，col_r，col_g分别表示控制点阵的行信号、控制红色发光二极管的列信号和控制绿色发光二极管的列信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该模块具体的Verilog HDL语言实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="comment">/* </span></span><br><span class="line"><span class="comment">2.	*   Name: show_LED.v </span></span><br><span class="line"><span class="comment">3.	*   Author: lgc0208</span></span><br><span class="line"><span class="comment">4.	*   Date: 2020-11-21 </span></span><br><span class="line"><span class="comment">5.	*   Function:在点阵列上显示不同颜色 </span></span><br><span class="line"><span class="comment">6.	*   Input: 时钟信号clk，颜色显示切换[2:0]SW,按键信号key </span></span><br><span class="line"><span class="comment">7.	*   Output: 控制点阵的行信号row，红色列信号col_r，绿色列信号col_g </span></span><br><span class="line"><span class="comment">8.	* </span></span><br><span class="line"><span class="comment">9.	*   Update: 2020-11-22 </span></span><br><span class="line"><span class="comment">10.	*   Author: LIN Guocheng </span></span><br><span class="line"><span class="comment">11.	*   Function: 按下按键后，对应列灭。 </span></span><br><span class="line"><span class="comment">12.	*/</span>  </span><br><span class="line"><span class="number">13.</span>	  </span><br><span class="line"><span class="number">14.</span>	<span class="function"><span class="keyword">module</span> <span class="title">show_LED</span><span class="params">(clk, SW, key, row,col_r, col_g)</span></span>;  </span><br><span class="line"><span class="number">15.</span>	    input clk;  </span><br><span class="line"><span class="number">16.</span>	    input [<span class="number">2</span>:<span class="number">0</span>]SW;  </span><br><span class="line"><span class="number">17.</span>	    input [<span class="number">6</span>:<span class="number">0</span>]key;  </span><br><span class="line"><span class="number">18.</span>	    output reg [<span class="number">7</span>:<span class="number">0</span>]row,col_r, col_g;  </span><br><span class="line"><span class="number">19.</span>	    reg [<span class="number">2</span>:<span class="number">0</span>] count;  </span><br><span class="line"><span class="number">20.</span>	  </span><br><span class="line"><span class="number">21.</span>	    wire clk_3r, clk_1g;  </span><br><span class="line"><span class="number">22.</span>	    reg [<span class="number">2</span>:<span class="number">0</span>] count_r, count_g;  </span><br><span class="line"><span class="number">23.</span>	      </span><br><span class="line"><span class="number">24.</span>	    <span class="comment">//分频，红绿光占空比1:3，显示黄色  </span></span><br><span class="line"><span class="number">25.</span>	    division #(<span class="number">1</span>/<span class="number">8</span>) <span class="built_in">d1r</span>(.<span class="built_in">clk</span>(clk), .<span class="built_in">clk_out</span>(clk_3r));  </span><br><span class="line"><span class="number">26.</span>	    division #(<span class="number">3</span>/<span class="number">8</span>) <span class="built_in">d2g</span>(.<span class="built_in">clk</span>(clk), .<span class="built_in">clk_out</span>(clk_1g));  </span><br><span class="line"><span class="number">27.</span>	      </span><br><span class="line"><span class="number">28.</span>	    <span class="comment">//模8计数器  </span></span><br><span class="line"><span class="number">29.</span>	    always @(posedge clk)  </span><br><span class="line"><span class="number">30.</span>	    begin  </span><br><span class="line"><span class="number">31.</span>	        <span class="keyword">if</span>(count == <span class="number">3&#x27;b</span>111)  </span><br><span class="line"><span class="number">32.</span>	            count &lt;= <span class="number">3&#x27;b</span>000;  </span><br><span class="line"><span class="number">33.</span>	        <span class="keyword">else</span>  </span><br><span class="line"><span class="number">34.</span>	            count &lt;= count + <span class="number">1&#x27;b</span>1;  </span><br><span class="line"><span class="number">35.</span>	    end  </span><br><span class="line"><span class="number">36.</span>	      </span><br><span class="line"><span class="number">37.</span>	    always @(posedge clk_3r)  </span><br><span class="line"><span class="number">38.</span>	    begin  </span><br><span class="line"><span class="number">39.</span>	        <span class="keyword">if</span>(count_r == <span class="number">3&#x27;b</span>111)  </span><br><span class="line"><span class="number">40.</span>	            count_r &lt;= <span class="number">3&#x27;b</span>000;  </span><br><span class="line"><span class="number">41.</span>	        <span class="keyword">else</span>  </span><br><span class="line"><span class="number">42.</span>	            count_r &lt;= count_r + <span class="number">1&#x27;b</span>1;  </span><br><span class="line"><span class="number">43.</span>	    end  </span><br><span class="line"><span class="number">44.</span>	    always @(posedge clk_1g)  </span><br><span class="line"><span class="number">45.</span>	    begin  </span><br><span class="line"><span class="number">46.</span>	        <span class="keyword">if</span>(count_g == <span class="number">3&#x27;b</span>111)  </span><br><span class="line"><span class="number">47.</span>	            count_g &lt;= <span class="number">3&#x27;b</span>000;  </span><br><span class="line"><span class="number">48.</span>	        <span class="keyword">else</span>  </span><br><span class="line"><span class="number">49.</span>	            count_g &lt;= count_g + <span class="number">1&#x27;b</span>1;  </span><br><span class="line"><span class="number">50.</span>	    end  </span><br><span class="line"><span class="number">51.</span>	      </span><br><span class="line"><span class="number">52.</span>	      </span><br><span class="line"><span class="number">53.</span>	      </span><br><span class="line"><span class="number">54.</span>	        <span class="comment">//点阵显示部分   </span></span><br><span class="line"><span class="number">55.</span>	    always@(count <span class="keyword">or</span> count_r <span class="keyword">or</span> count_g)  </span><br><span class="line"><span class="number">56.</span>	    begin  </span><br><span class="line"><span class="number">57.</span>	        <span class="comment">//高音部分，显示黄色  </span></span><br><span class="line"><span class="number">58.</span>	        <span class="keyword">if</span>(SW == <span class="number">3&#x27;b</span>001)  </span><br><span class="line"><span class="number">59.</span>	        begin  </span><br><span class="line"><span class="number">60.</span>	            <span class="built_in"><span class="keyword">case</span></span>(count_r)  </span><br><span class="line"><span class="number">61.</span>	            <span class="number">3&#x27;b</span>000:begin row &lt;= <span class="number">8&#x27;b</span>1111_1111; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">62.</span>	            <span class="number">3&#x27;b</span>001:begin row &lt;= <span class="number">8&#x27;b</span>1011_1111; col_r &lt;= <span class="number">8&#x27;b</span>0100_0000; end  </span><br><span class="line"><span class="number">63.</span>	            <span class="number">3&#x27;b</span>010:begin row &lt;= <span class="number">8&#x27;b</span>1101_1111; col_r &lt;= <span class="number">8&#x27;b</span>0110_0000; end  </span><br><span class="line"><span class="number">64.</span>	            <span class="number">3&#x27;b</span>011:begin row &lt;= <span class="number">8&#x27;b</span>1110_1111; col_r &lt;= <span class="number">8&#x27;b</span>0111_0000; end  </span><br><span class="line"><span class="number">65.</span>	            <span class="number">3&#x27;b</span>100:begin row &lt;= <span class="number">8&#x27;b</span>1111_0111; col_r &lt;= <span class="number">8&#x27;b</span>0111_1000; end  </span><br><span class="line"><span class="number">66.</span>	            <span class="number">3&#x27;b</span>101:begin row &lt;= <span class="number">8&#x27;b</span>1111_1011; col_r &lt;= <span class="number">8&#x27;b</span>0111_1100; end  </span><br><span class="line"><span class="number">67.</span>	            <span class="number">3&#x27;b</span>110:begin row &lt;= <span class="number">8&#x27;b</span>1111_1101; col_r &lt;= <span class="number">8&#x27;b</span>0111_1110; end  </span><br><span class="line"><span class="number">68.</span>	            <span class="number">3&#x27;b</span>111:begin row &lt;= <span class="number">8&#x27;b</span>1111_1110; col_r &lt;= <span class="number">8&#x27;b</span>0111_1111; end  </span><br><span class="line"><span class="number">69.</span>	            endcase  </span><br><span class="line"><span class="number">70.</span>	            <span class="built_in"><span class="keyword">case</span></span>(count_g)  </span><br><span class="line"><span class="number">71.</span>	            <span class="number">3&#x27;b</span>000:begin row &lt;= <span class="number">8&#x27;b</span>1111_1111; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">72.</span>	            <span class="number">3&#x27;b</span>001:begin row &lt;= <span class="number">8&#x27;b</span>1011_1111; col_g &lt;= <span class="number">8&#x27;b</span>0100_0000; end  </span><br><span class="line"><span class="number">73.</span>	            <span class="number">3&#x27;b</span>010:begin row &lt;= <span class="number">8&#x27;b</span>1101_1111; col_g &lt;= <span class="number">8&#x27;b</span>0110_0000; end  </span><br><span class="line"><span class="number">74.</span>	            <span class="number">3&#x27;b</span>011:begin row &lt;= <span class="number">8&#x27;b</span>1110_1111; col_g &lt;= <span class="number">8&#x27;b</span>0111_0000; end  </span><br><span class="line"><span class="number">75.</span>	            <span class="number">3&#x27;b</span>100:begin row &lt;= <span class="number">8&#x27;b</span>1111_0111; col_g &lt;= <span class="number">8&#x27;b</span>0111_1000; end  </span><br><span class="line"><span class="number">76.</span>	            <span class="number">3&#x27;b</span>101:begin row &lt;= <span class="number">8&#x27;b</span>1111_1011; col_g &lt;= <span class="number">8&#x27;b</span>0111_1100; end  </span><br><span class="line"><span class="number">77.</span>	            <span class="number">3&#x27;b</span>110:begin row &lt;= <span class="number">8&#x27;b</span>1111_1101; col_g &lt;= <span class="number">8&#x27;b</span>0111_1110; end  </span><br><span class="line"><span class="number">78.</span>	            <span class="number">3&#x27;b</span>111:begin row &lt;= <span class="number">8&#x27;b</span>1111_1110; col_g &lt;= <span class="number">8&#x27;b</span>0111_1111; end  </span><br><span class="line"><span class="number">79.</span>	            endcase  </span><br><span class="line"><span class="number">80.</span>	              </span><br><span class="line"><span class="number">81.</span>	        end  </span><br><span class="line"><span class="number">82.</span>	        <span class="comment">//中音部分，显示红色  </span></span><br><span class="line"><span class="number">83.</span>	        <span class="keyword">else</span> <span class="keyword">if</span>(SW == <span class="number">3&#x27;b</span>010)  </span><br><span class="line"><span class="number">84.</span>	        begin  </span><br><span class="line"><span class="number">85.</span>	            <span class="built_in"><span class="keyword">case</span></span>(count)  </span><br><span class="line"><span class="number">86.</span>	            <span class="number">3&#x27;b</span>000:begin row &lt;= <span class="number">8&#x27;b</span>1111_1111; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">87.</span>	            <span class="number">3&#x27;b</span>001:begin row &lt;= <span class="number">8&#x27;b</span>1011_1111; col_r &lt;= <span class="number">8&#x27;b</span>0100_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">88.</span>	            <span class="number">3&#x27;b</span>010:begin row &lt;= <span class="number">8&#x27;b</span>1101_1111; col_r &lt;= <span class="number">8&#x27;b</span>0110_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">89.</span>	            <span class="number">3&#x27;b</span>011:begin row &lt;= <span class="number">8&#x27;b</span>1110_1111; col_r &lt;= <span class="number">8&#x27;b</span>0111_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">90.</span>	            <span class="number">3&#x27;b</span>100:begin row &lt;= <span class="number">8&#x27;b</span>1111_0111; col_r &lt;= <span class="number">8&#x27;b</span>0111_1000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">91.</span>	            <span class="number">3&#x27;b</span>101:begin row &lt;= <span class="number">8&#x27;b</span>1111_1011; col_r &lt;= <span class="number">8&#x27;b</span>0111_1100; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">92.</span>	            <span class="number">3&#x27;b</span>110:begin row &lt;= <span class="number">8&#x27;b</span>1111_1101; col_r &lt;= <span class="number">8&#x27;b</span>0111_1110; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">93.</span>	            <span class="number">3&#x27;b</span>111:begin row &lt;= <span class="number">8&#x27;b</span>1111_1110; col_r &lt;= <span class="number">8&#x27;b</span>0111_1111; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">94.</span>	            endcase  </span><br><span class="line"><span class="number">95.</span>	        end  </span><br><span class="line"><span class="number">96.</span>	        <span class="comment">//低音部分，显示绿色  </span></span><br><span class="line"><span class="number">97.</span>	        <span class="keyword">else</span> <span class="keyword">if</span>(SW == <span class="number">3&#x27;b</span>100)  </span><br><span class="line"><span class="number">98.</span>	        begin  </span><br><span class="line"><span class="number">99.</span>	            <span class="built_in"><span class="keyword">case</span></span>(count)  </span><br><span class="line"><span class="number">100.</span>	            <span class="number">3&#x27;b</span>000:begin row &lt;= <span class="number">8&#x27;b</span>1111_1111; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">101.</span>	            <span class="number">3&#x27;b</span>001:begin row &lt;= <span class="number">8&#x27;b</span>1011_1111; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0100_0000; end  </span><br><span class="line"><span class="number">102.</span>	            <span class="number">3&#x27;b</span>010:begin row &lt;= <span class="number">8&#x27;b</span>1101_1111; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0110_0000; end  </span><br><span class="line"><span class="number">103.</span>	            <span class="number">3&#x27;b</span>011:begin row &lt;= <span class="number">8&#x27;b</span>1110_1111; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0111_0000; end  </span><br><span class="line"><span class="number">104.</span>	            <span class="number">3&#x27;b</span>100:begin row &lt;= <span class="number">8&#x27;b</span>1111_0111; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0111_1000; end  </span><br><span class="line"><span class="number">105.</span>	            <span class="number">3&#x27;b</span>101:begin row &lt;= <span class="number">8&#x27;b</span>1111_1011; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0111_1100; end  </span><br><span class="line"><span class="number">106.</span>	            <span class="number">3&#x27;b</span>110:begin row &lt;= <span class="number">8&#x27;b</span>1111_1101; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0111_1110; end  </span><br><span class="line"><span class="number">107.</span>	            <span class="number">3&#x27;b</span>111:begin row &lt;= <span class="number">8&#x27;b</span>1111_1110; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0111_1111; end  </span><br><span class="line"><span class="number">108.</span>	            endcase  </span><br><span class="line"><span class="number">109.</span>	        end  </span><br><span class="line"><span class="number">110.</span>	        <span class="keyword">else</span>  </span><br><span class="line"><span class="number">111.</span>	        begin  </span><br><span class="line"><span class="number">112.</span>	            <span class="built_in"><span class="keyword">case</span></span>(count)  </span><br><span class="line"><span class="number">113.</span>	            <span class="number">3&#x27;b</span>000:begin row &lt;= <span class="number">8&#x27;b</span>0000_0000; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">114.</span>	            <span class="number">3&#x27;b</span>001:begin row &lt;= <span class="number">8&#x27;b</span>0000_0000; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">115.</span>	            <span class="number">3&#x27;b</span>010:begin row &lt;= <span class="number">8&#x27;b</span>0000_0000; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">116.</span>	            <span class="number">3&#x27;b</span>011:begin row &lt;= <span class="number">8&#x27;b</span>0000_0000; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">117.</span>	            <span class="number">3&#x27;b</span>100:begin row &lt;= <span class="number">8&#x27;b</span>0000_0000; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">118.</span>	            <span class="number">3&#x27;b</span>101:begin row &lt;= <span class="number">8&#x27;b</span>0000_0000; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">119.</span>	            <span class="number">3&#x27;b</span>110:begin row &lt;= <span class="number">8&#x27;b</span>0000_0000; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">120.</span>	            <span class="number">3&#x27;b</span>111:begin row &lt;= <span class="number">8&#x27;b</span>0000_0000; col_r &lt;= <span class="number">8&#x27;b</span>0000_0000; col_g &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">121.</span>	            endcase  </span><br><span class="line"><span class="number">122.</span>	        end  </span><br><span class="line"><span class="number">123.</span>	          </span><br><span class="line"><span class="number">124.</span>	        <span class="keyword">if</span>(key[<span class="number">0</span>] == <span class="number">1</span>) begin col_r[<span class="number">0</span>] &lt;= <span class="number">0</span>; col_g[<span class="number">0</span>] &lt;= <span class="number">0</span>; end  </span><br><span class="line"><span class="number">125.</span>	        <span class="keyword">if</span>(key[<span class="number">1</span>] == <span class="number">1</span>) begin col_r[<span class="number">1</span>] &lt;= <span class="number">0</span>; col_g[<span class="number">1</span>] &lt;= <span class="number">0</span>; end  </span><br><span class="line"><span class="number">126.</span>	        <span class="keyword">if</span>(key[<span class="number">2</span>] == <span class="number">1</span>) begin col_r[<span class="number">2</span>] &lt;= <span class="number">0</span>; col_g[<span class="number">2</span>] &lt;= <span class="number">0</span>; end  </span><br><span class="line"><span class="number">127.</span>	        <span class="keyword">if</span>(key[<span class="number">3</span>] == <span class="number">1</span>) begin col_r[<span class="number">3</span>] &lt;= <span class="number">0</span>; col_g[<span class="number">3</span>] &lt;= <span class="number">0</span>; end  </span><br><span class="line"><span class="number">128.</span>	        <span class="keyword">if</span>(key[<span class="number">4</span>] == <span class="number">1</span>) begin col_r[<span class="number">4</span>] &lt;= <span class="number">0</span>; col_g[<span class="number">4</span>] &lt;= <span class="number">0</span>; end  </span><br><span class="line"><span class="number">129.</span>	        <span class="keyword">if</span>(key[<span class="number">5</span>] == <span class="number">1</span>) begin col_r[<span class="number">5</span>] &lt;= <span class="number">0</span>; col_g[<span class="number">5</span>] &lt;= <span class="number">0</span>; end  </span><br><span class="line"><span class="number">130.</span>	        <span class="keyword">if</span>(key[<span class="number">6</span>] == <span class="number">1</span>) begin col_r[<span class="number">6</span>] &lt;= <span class="number">0</span>; col_g[<span class="number">6</span>] &lt;= <span class="number">0</span>; end  </span><br><span class="line"><span class="number">131.</span>	          </span><br><span class="line"><span class="number">132.</span>	    end   </span><br><span class="line"><span class="number">133.</span>	endmodule </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="3-3-4-数码管显示模块"><a href="#3-3-4-数码管显示模块" class="headerlink" title="3.3.4 数码管显示模块"></a>3.3.4 数码管显示模块</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7 段数码管模块由 8 个 7 段数码管组成，每个数码管的结构如图4所示，在2.1.2节中笔者也对数码管的显示原理进行了详细的说明。该模块中，key表示输入的按键信号，控制数码管所显示的数字；clk表示系统时钟信号，用于扫描并呈现所需要展现的数字；seg表示数码管显示信号，为该模块中输出到数码管所用的信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该模块具体的Verilog HDL语言实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="comment">/* </span></span><br><span class="line"><span class="comment">2.	*   Name: show_seg_tube.v </span></span><br><span class="line"><span class="comment">3.	*   Author: lgc0208</span></span><br><span class="line"><span class="comment">4.	*   Date: 2020-11-23 </span></span><br><span class="line"><span class="comment">5.	*   Function: 根据按键显示不同数字 </span></span><br><span class="line"><span class="comment">6.	*   Input: 按键信号key,时钟信号clk </span></span><br><span class="line"><span class="comment">7.	*   Output: 数码管显示信号seg </span></span><br><span class="line"><span class="comment">8.	*/</span>  </span><br><span class="line"><span class="number">9.</span>	  </span><br><span class="line"><span class="number">10.</span>	<span class="function"><span class="keyword">module</span> <span class="title">show_seg_tube</span><span class="params">(key, clk, seg)</span></span>;  </span><br><span class="line"><span class="number">11.</span>	  </span><br><span class="line"><span class="number">12.</span>	    input [<span class="number">6</span>:<span class="number">0</span>] key;  </span><br><span class="line"><span class="number">13.</span>	    input clk;  </span><br><span class="line"><span class="number">14.</span>	    output reg [<span class="number">7</span>:<span class="number">0</span>]seg;  </span><br><span class="line"><span class="number">15.</span>	      </span><br><span class="line"><span class="number">16.</span>	    always@(clk)  </span><br><span class="line"><span class="number">17.</span>	    begin  </span><br><span class="line"><span class="number">18.</span>	    <span class="keyword">if</span>(key[<span class="number">0</span>] == <span class="number">1</span>) begin seg &lt;= <span class="number">8&#x27;b</span>0000_0110; end <span class="comment">//显示1  </span></span><br><span class="line"><span class="number">19.</span>	    <span class="keyword">else</span> <span class="keyword">if</span>(key[<span class="number">1</span>] == <span class="number">1</span>) begin seg &lt;= <span class="number">8&#x27;b</span>0101_1011; end <span class="comment">//显示2  </span></span><br><span class="line"><span class="number">20.</span>	    <span class="keyword">else</span> <span class="keyword">if</span>(key[<span class="number">2</span>] == <span class="number">1</span>) begin seg &lt;= <span class="number">8&#x27;b</span>0100_1111; end <span class="comment">//显示3  </span></span><br><span class="line"><span class="number">21.</span>	    <span class="keyword">else</span> <span class="keyword">if</span>(key[<span class="number">3</span>] == <span class="number">1</span>) begin seg &lt;= <span class="number">8&#x27;b</span>0110_0110; end <span class="comment">//显示4  </span></span><br><span class="line"><span class="number">22.</span>	    <span class="keyword">else</span> <span class="keyword">if</span>(key[<span class="number">4</span>] == <span class="number">1</span>) begin seg &lt;= <span class="number">8&#x27;b</span>0110_1101; end <span class="comment">//显示5  </span></span><br><span class="line"><span class="number">23.</span>	    <span class="keyword">else</span> <span class="keyword">if</span>(key[<span class="number">5</span>] == <span class="number">1</span>) begin seg &lt;= <span class="number">8&#x27;b</span>0111_1101; end <span class="comment">//显示6  </span></span><br><span class="line"><span class="number">24.</span>	    <span class="keyword">else</span> <span class="keyword">if</span>(key[<span class="number">6</span>] == <span class="number">1</span>) begin seg &lt;= <span class="number">8&#x27;b</span>0000_0111; end <span class="comment">//显示7  </span></span><br><span class="line"><span class="number">25.</span>	    <span class="keyword">else</span> begin seg &lt;= <span class="number">8&#x27;b</span>0000_0000; end  </span><br><span class="line"><span class="number">26.</span>	    end  </span><br><span class="line"><span class="number">27.</span>	      </span><br><span class="line"><span class="number">28.</span>	endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h3 id="3-3-5-音乐演奏模块"><a href="#3-3-5-音乐演奏模块" class="headerlink" title="3.3.5 音乐演奏模块"></a>3.3.5 音乐演奏模块</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 音乐演奏模块是该实验中所有功能模块的核心。首先，笔者将先对该部分的输入输出信号进行说明。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; clk表示输入时钟信号，本实验中选用的是1MHZ的系统时钟。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; auto_sw表示自动播放开关，当auto_sw为1时，开始自动播放乐曲《天空之城》；当auto_sw为0时，为手动演奏状态。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SW表示手动演奏的音域切换。当SW=3’b100时，演奏低音音域；当SW=3’b010时，演奏中音音域；当SW=3’b001时，演奏高音音域。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BTN表示手动演奏的音符。BTN[0]至BTN[6]分别表示音符1、2、3、4、5、6、7，按下按键时蜂鸣器即产生响应的音符。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; beep表示输出给蜂鸣器的信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; row, col_r, col_g分别表示输出给点阵列的行、列信号。<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; seg表示控制八段数码管的输出信号。<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在该模块中，首先调用分频器模块，产生低音、中音、高音三个音域共21种不同频率的音符。并调用分频器模块产生一个4HZ的时钟信号，用于控制自动播放每个音符单元的持续时间。当自动播放控制信号auto_sw为1时，用于自动播放的计数器开始工作，循环播放事先存在程序中的《天空之城》音乐。当自动播放控制信号auto_sw为0时，为手动播放模式。此时，通过SW信号检测用户所选择的音域，通过BTN信号检测用户所选择要演奏的音符，并将事先完成分频的对应时钟信号赋值给信号beep，并输出到蜂鸣器，产生对应的音调。同时，根据SW信号和BTN信号的检测结果，将用户所选择的音域和音符信息传递给点阵列扫描模块和数码管显示模块，在点阵列和数码管上出现对应的图案或数字。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 该模块具体的Verilog HDL语言实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="comment">/* </span></span><br><span class="line"><span class="comment">2.	*   Name: play.v </span></span><br><span class="line"><span class="comment">3.	*	Author: lgc0208</span></span><br><span class="line"><span class="comment">4.	*   Date: 2020-11-29 </span></span><br><span class="line"><span class="comment">5.	*   Function: 根据按键演奏不同音符 </span></span><br><span class="line"><span class="comment">6.	*   Input: 时钟信号clk，自动播放信号auto_sw, 按键信号key, 音域切换信号SW </span></span><br><span class="line"><span class="comment">7.	*   Output: 蜂鸣器信号beep, 点阵列行信号row, 点阵列列信号col_r, col_g，数码管显示信号seg </span></span><br><span class="line"><span class="comment">8.	*/</span>  </span><br><span class="line"><span class="number">9.</span>	  </span><br><span class="line"><span class="number">10.</span>	  </span><br><span class="line"><span class="number">11.</span>	<span class="function"><span class="keyword">module</span> <span class="title">play</span><span class="params">(clk, auto_sw, key, SW, beep, row, col_r, col_g, seg)</span></span>;  </span><br><span class="line"><span class="number">12.</span>	  </span><br><span class="line"><span class="number">13.</span>	    input clk; <span class="comment">//输入时钟1MHZ  </span></span><br><span class="line"><span class="number">14.</span>	    input [<span class="number">6</span>:<span class="number">0</span>] key;   </span><br><span class="line"><span class="number">15.</span>	    input [<span class="number">2</span>:<span class="number">0</span>] SW;   </span><br><span class="line"><span class="number">16.</span>	    input auto_sw; <span class="comment">//自动演奏开关  </span></span><br><span class="line"><span class="number">17.</span>	    output reg beep = <span class="number">0</span>; <span class="comment">//蜂鸣器  </span></span><br><span class="line"><span class="number">18.</span>	    output [<span class="number">7</span>:<span class="number">0</span>]row, col_r, col_g; <span class="comment">//点阵控制信号  </span></span><br><span class="line"><span class="number">19.</span>	    output [<span class="number">7</span>:<span class="number">0</span>]seg; <span class="comment">//数码管显示信号  </span></span><br><span class="line"><span class="number">20.</span>	    wire [<span class="number">6</span>:<span class="number">0</span>] high, middle, low; <span class="comment">//定义低中高音  </span></span><br><span class="line"><span class="number">21.</span>	      </span><br><span class="line"><span class="number">22.</span>	    reg [<span class="number">2</span>:<span class="number">0</span>] pitch; <span class="comment">//定义音高  </span></span><br><span class="line"><span class="number">23.</span>	    reg [<span class="number">6</span>:<span class="number">0</span>] tone; <span class="comment">//定义音调  </span></span><br><span class="line"><span class="number">24.</span>	      </span><br><span class="line"><span class="number">25.</span>	    <span class="comment">//调用分频模块  </span></span><br><span class="line"><span class="number">26.</span>	    <span class="comment">//低音1~7(分别为low[0]~low[7])  </span></span><br><span class="line"><span class="number">27.</span>	    division #(<span class="number">3882</span>/<span class="number">2</span>) <span class="built_in">d_l1</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">28.</span>	                                 .<span class="built_in">clk_out</span>(low[<span class="number">0</span>]));  </span><br><span class="line"><span class="number">29.</span>	    division #(<span class="number">3405</span>/<span class="number">2</span>) <span class="built_in">d_l2</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">30.</span>	                                 .<span class="built_in">clk_out</span>(low[<span class="number">1</span>]));  </span><br><span class="line"><span class="number">31.</span>	    division #(<span class="number">3033</span>/<span class="number">2</span>) <span class="built_in">d_l3</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">32.</span>	                                 .<span class="built_in">clk_out</span>(low[<span class="number">2</span>]));  </span><br><span class="line"><span class="number">33.</span>	    division #(<span class="number">2863</span>/<span class="number">2</span>) <span class="built_in">d_l4</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">34.</span>	                                 .<span class="built_in">clk_out</span>(low[<span class="number">3</span>]));  </span><br><span class="line"><span class="number">35.</span>	    division #(<span class="number">2551</span>/<span class="number">2</span>) <span class="built_in">d_l5</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">36.</span>	                                 .<span class="built_in">clk_out</span>(low[<span class="number">4</span>]));  </span><br><span class="line"><span class="number">37.</span>	    division #(<span class="number">2272</span>/<span class="number">2</span>) <span class="built_in">d_l6</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">38.</span>	                                 .<span class="built_in">clk_out</span>(low[<span class="number">5</span>]));  </span><br><span class="line"><span class="number">39.</span>	    division #(<span class="number">2025</span>/<span class="number">2</span>) <span class="built_in">d_l7</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">40.</span>	                                 .<span class="built_in">clk_out</span>(low[<span class="number">6</span>]));  </span><br><span class="line"><span class="number">41.</span>	                        </span><br><span class="line"><span class="number">42.</span>	    <span class="comment">//中音1~7(分别为middle[0]~middle[7])  </span></span><br><span class="line"><span class="number">43.</span>	    division #(<span class="number">1911</span>/<span class="number">2</span>) <span class="built_in">d_m1</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">44.</span>	                                 .<span class="built_in">clk_out</span>(middle[<span class="number">0</span>]));  </span><br><span class="line"><span class="number">45.</span>	    division #(<span class="number">1702</span>/<span class="number">2</span>) <span class="built_in">d_m2</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">46.</span>	                                 .<span class="built_in">clk_out</span>(middle[<span class="number">1</span>]));  </span><br><span class="line"><span class="number">47.</span>	    division #(<span class="number">1516</span>/<span class="number">2</span>) <span class="built_in">d_m3</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">48.</span>	                                 .<span class="built_in">clk_out</span>(middle[<span class="number">2</span>]));  </span><br><span class="line"><span class="number">49.</span>	    division #(<span class="number">1431</span>/<span class="number">2</span>) <span class="built_in">d_m4</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">50.</span>	                                 .<span class="built_in">clk_out</span>(middle[<span class="number">3</span>]));  </span><br><span class="line"><span class="number">51.</span>	    division #(<span class="number">1275</span>/<span class="number">2</span>) <span class="built_in">d_m5</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">52.</span>	                                 .<span class="built_in">clk_out</span>(middle[<span class="number">4</span>]));  </span><br><span class="line"><span class="number">53.</span>	    division #(<span class="number">1136</span>/<span class="number">2</span>) <span class="built_in">d_m6</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">54.</span>	                                 .<span class="built_in">clk_out</span>(middle[<span class="number">5</span>]));  </span><br><span class="line"><span class="number">55.</span>	    division #(<span class="number">1012</span>/<span class="number">2</span>) <span class="built_in">d_m7</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">56.</span>	                                 .<span class="built_in">clk_out</span>(middle[<span class="number">6</span>]));  </span><br><span class="line"><span class="number">57.</span>	                                        </span><br><span class="line"><span class="number">58.</span>	    <span class="comment">//高音1~7(分别为high[0]~high[7])  </span></span><br><span class="line"><span class="number">59.</span>	    division #(<span class="number">956</span>/<span class="number">2</span>) <span class="built_in">d_h1</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">60.</span>	                                 .<span class="built_in">clk_out</span>(high[<span class="number">0</span>]));  </span><br><span class="line"><span class="number">61.</span>	    division #(<span class="number">851</span>/<span class="number">2</span>) <span class="built_in">d_h2</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">62.</span>	                                 .<span class="built_in">clk_out</span>(high[<span class="number">1</span>]));  </span><br><span class="line"><span class="number">63.</span>	    division #(<span class="number">758</span>/<span class="number">2</span>) <span class="built_in">d_h3</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">64.</span>	                                 .<span class="built_in">clk_out</span>(high[<span class="number">2</span>]));  </span><br><span class="line"><span class="number">65.</span>	    division #(<span class="number">715</span>/<span class="number">2</span>) <span class="built_in">d_h4</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">66.</span>	                                 .<span class="built_in">clk_out</span>(high[<span class="number">3</span>]));  </span><br><span class="line"><span class="number">67.</span>	    division #(<span class="number">637</span>/<span class="number">2</span>) <span class="built_in">d_h5</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">68.</span>	                                 .<span class="built_in">clk_out</span>(high[<span class="number">4</span>]));  </span><br><span class="line"><span class="number">69.</span>	    division #(<span class="number">568</span>/<span class="number">2</span>) <span class="built_in">d_h6</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">70.</span>	                                 .<span class="built_in">clk_out</span>(high[<span class="number">5</span>]));  </span><br><span class="line"><span class="number">71.</span>	    division #(<span class="number">506</span>/<span class="number">2</span>) <span class="built_in">d_h7</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">72.</span>	                                 .<span class="built_in">clk_out</span>(high[<span class="number">6</span>]));  </span><br><span class="line"><span class="number">73.</span>	      </span><br><span class="line"><span class="number">74.</span>	    <span class="comment">//4HZ分频,用于自动演奏  </span></span><br><span class="line"><span class="number">75.</span>	    division #(<span class="number">250000</span>/<span class="number">2</span>) <span class="built_in">d_4hz</span>(.<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">76.</span>	                                       .<span class="built_in">clk_out</span>(clk_4HZ));  </span><br><span class="line"><span class="number">77.</span>	    <span class="comment">//《天空之城》选用 126 个音符，需要7位2进制数表示  </span></span><br><span class="line"><span class="number">78.</span>	    reg [<span class="number">6</span>:<span class="number">0</span>]count; <span class="comment">//用于轮流播放不同音符      </span></span><br><span class="line"><span class="number">79.</span>	      </span><br><span class="line"><span class="number">80.</span>	    <span class="comment">//开始计数  </span></span><br><span class="line"><span class="number">81.</span>	    always@(posedge clk_4HZ)  </span><br><span class="line"><span class="number">82.</span>	    begin  </span><br><span class="line"><span class="number">83.</span>	        <span class="comment">//若按键按下，则开启自动播放计数，否则不工作  </span></span><br><span class="line"><span class="number">84.</span>	        <span class="keyword">if</span>(auto_sw)  </span><br><span class="line"><span class="number">85.</span>	        begin  </span><br><span class="line"><span class="number">86.</span>	            <span class="comment">//计数器  </span></span><br><span class="line"><span class="number">87.</span>	            <span class="keyword">if</span>(count == <span class="number">130</span>)  </span><br><span class="line"><span class="number">88.</span>	                count &lt;= <span class="number">0</span>;  </span><br><span class="line"><span class="number">89.</span>	            <span class="keyword">else</span>  </span><br><span class="line"><span class="number">90.</span>	                count &lt;= count + <span class="number">1&#x27;b</span>1;  </span><br><span class="line"><span class="number">91.</span>	        end  </span><br><span class="line"><span class="number">92.</span>	    end  </span><br><span class="line"><span class="number">93.</span>	      </span><br><span class="line"><span class="number">94.</span>	    <span class="comment">//开始演奏  </span></span><br><span class="line"><span class="number">95.</span>	    always@(posedge clk)  </span><br><span class="line"><span class="number">96.</span>	    begin  </span><br><span class="line"><span class="number">97.</span>	      </span><br><span class="line"><span class="number">98.</span>	        <span class="comment">//手动演奏  </span></span><br><span class="line"><span class="number">99.</span>	        <span class="keyword">if</span>(!auto_sw)   </span><br><span class="line"><span class="number">100.</span>	        begin  </span><br><span class="line"><span class="number">101.</span>	            pitch &lt;= SW;  </span><br><span class="line"><span class="number">102.</span>	            tone &lt;= key;  </span><br><span class="line"><span class="number">103.</span>	        end  </span><br><span class="line"><span class="number">104.</span>	              </span><br><span class="line"><span class="number">105.</span>	        <span class="comment">//自动演奏 天空之城  </span></span><br><span class="line"><span class="number">106.</span>	        <span class="keyword">else</span>  </span><br><span class="line"><span class="number">107.</span>	        begin  </span><br><span class="line"><span class="number">108.</span>	                <span class="built_in"><span class="keyword">case</span></span>(count)  </span><br><span class="line"><span class="number">109.</span>	                <span class="number">1</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//低音6   </span></span><br><span class="line"><span class="number">110.</span>	                <span class="number">2</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">111.</span>	                <span class="number">3</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">112.</span>	                <span class="number">4</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">113.</span>	                <span class="number">5</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">114.</span>	                <span class="number">6</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">115.</span>	                <span class="number">7</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">116.</span>	                <span class="number">8</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">117.</span>	                <span class="number">9</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//中音3  </span></span><br><span class="line"><span class="number">118.</span>	                <span class="number">10</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">119.</span>	                <span class="number">11</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">120.</span>	                <span class="number">12</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">121.</span>	                <span class="number">13</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">122.</span>	                <span class="number">14</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">123.</span>	                <span class="number">15</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">124.</span>	                <span class="number">16</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">125.</span>	                <span class="number">17</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//低音3  </span></span><br><span class="line"><span class="number">126.</span>	                <span class="number">18</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">127.</span>	                <span class="number">19</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//低音6   </span></span><br><span class="line"><span class="number">128.</span>	                <span class="number">20</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">129.</span>	                <span class="number">21</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">130.</span>	                <span class="number">22</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//低音5  </span></span><br><span class="line"><span class="number">131.</span>	                <span class="number">23</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//低音6   </span></span><br><span class="line"><span class="number">132.</span>	                <span class="number">24</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">133.</span>	                <span class="number">25</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">134.</span>	                <span class="number">26</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">135.</span>	                <span class="number">27</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//低音5  </span></span><br><span class="line"><span class="number">136.</span>	                <span class="number">28</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">137.</span>	                <span class="number">29</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">138.</span>	                <span class="number">30</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">139.</span>	                <span class="number">31</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">140.</span>	                <span class="number">32</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">141.</span>	                <span class="number">33</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//低音3  </span></span><br><span class="line"><span class="number">142.</span>	                <span class="number">34</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">143.</span>	                <span class="number">35</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_1000; end <span class="comment">//低音4  </span></span><br><span class="line"><span class="number">144.</span>	                <span class="number">36</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_1000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">145.</span>	                <span class="number">37</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_1000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">146.</span>	                <span class="number">38</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//低音3  </span></span><br><span class="line"><span class="number">147.</span>	                <span class="number">39</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_1000; end <span class="comment">//低音4  </span></span><br><span class="line"><span class="number">148.</span>	                <span class="number">40</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">149.</span>	                <span class="number">41</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">150.</span>	                <span class="number">42</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">151.</span>	                <span class="number">43</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//低音3  </span></span><br><span class="line"><span class="number">152.</span>	                <span class="number">44</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">153.</span>	                <span class="number">45</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">154.</span>	                <span class="number">46</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">155.</span>	                <span class="number">47</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">156.</span>	                <span class="number">48</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">157.</span>	                <span class="number">49</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">158.</span>	                <span class="number">50</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">159.</span>	                <span class="number">51</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">160.</span>	                <span class="number">52</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">161.</span>	                <span class="number">53</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">162.</span>	                <span class="number">54</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_1000; end <span class="comment">//低音4  </span></span><br><span class="line"><span class="number">163.</span>	                <span class="number">55</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_1000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">164.</span>	                <span class="number">56</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_1000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">165.</span>	                <span class="number">57</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_1000; end <span class="comment">//低音4  </span></span><br><span class="line"><span class="number">166.</span>	                <span class="number">58</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">167.</span>	                <span class="number">59</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">168.</span>	                <span class="number">60</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">169.</span>	                <span class="number">61</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">170.</span>	                <span class="number">62</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">171.</span>	                <span class="number">63</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">172.</span>	                <span class="number">64</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>000; tone&lt;=<span class="number">7&#x27;b</span>000_0000; end <span class="comment">//休止符  </span></span><br><span class="line"><span class="number">173.</span>	                <span class="number">65</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>000; tone&lt;=<span class="number">7&#x27;b</span>000_0000; end <span class="comment">//休止符  </span></span><br><span class="line"><span class="number">174.</span>	                <span class="number">66</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//低音6   </span></span><br><span class="line"><span class="number">175.</span>	                <span class="number">67</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">176.</span>	                <span class="number">68</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">177.</span>	                <span class="number">69</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">178.</span>	                <span class="number">70</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">179.</span>	                <span class="number">71</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">180.</span>	                <span class="number">72</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">181.</span>	                <span class="number">73</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">182.</span>	                <span class="number">74</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//中音3  </span></span><br><span class="line"><span class="number">183.</span>	                <span class="number">75</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">184.</span>	                <span class="number">76</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">185.</span>	                <span class="number">77</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">186.</span>	                <span class="number">78</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">187.</span>	                <span class="number">79</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">188.</span>	                <span class="number">80</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">189.</span>	                <span class="number">81</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">190.</span>	                <span class="number">82</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//低音3  </span></span><br><span class="line"><span class="number">191.</span>	                <span class="number">83</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">192.</span>	                <span class="number">84</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//低音6   </span></span><br><span class="line"><span class="number">193.</span>	                <span class="number">85</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">194.</span>	                <span class="number">86</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">195.</span>	                <span class="number">87</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//低音5  </span></span><br><span class="line"><span class="number">196.</span>	                <span class="number">88</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//低音6   </span></span><br><span class="line"><span class="number">197.</span>	                <span class="number">89</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">198.</span>	                <span class="number">90</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">199.</span>	                <span class="number">91</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">200.</span>	                <span class="number">92</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//低音5  </span></span><br><span class="line"><span class="number">201.</span>	                <span class="number">93</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">202.</span>	                <span class="number">94</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">203.</span>	                <span class="number">95</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">204.</span>	                <span class="number">96</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">205.</span>	                <span class="number">97</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">206.</span>	                <span class="number">98</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//低音3  </span></span><br><span class="line"><span class="number">207.</span>	                <span class="number">99</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>000_1000; end <span class="comment">//低音4  </span></span><br><span class="line"><span class="number">208.</span>	                <span class="number">100</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">209.</span>	                <span class="number">101</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">210.</span>	                <span class="number">102</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">211.</span>	                <span class="number">103</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">212.</span>	                <span class="number">104</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">213.</span>	                <span class="number">105</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">214.</span>	                <span class="number">106</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0010; end <span class="comment">//中音2  </span></span><br><span class="line"><span class="number">215.</span>	                <span class="number">107</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0010; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">216.</span>	                <span class="number">108</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0100; end <span class="comment">//中音3  </span></span><br><span class="line"><span class="number">217.</span>	                <span class="number">109</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">218.</span>	                <span class="number">110</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">219.</span>	                <span class="number">111</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">220.</span>	                <span class="number">112</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">221.</span>	                <span class="number">113</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>000; tone&lt;=<span class="number">7&#x27;b</span>000_0000; end <span class="comment">//休止符  </span></span><br><span class="line"><span class="number">222.</span>	                <span class="number">114</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>010; tone&lt;=<span class="number">7&#x27;b</span>000_0001; end <span class="comment">//中音1  </span></span><br><span class="line"><span class="number">223.</span>	                <span class="number">115</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">224.</span>	                <span class="number">116</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//低音6   </span></span><br><span class="line"><span class="number">225.</span>	                <span class="number">117</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">226.</span>	                <span class="number">118</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//低音7  </span></span><br><span class="line"><span class="number">227.</span>	                <span class="number">119</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>100_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">228.</span>	                <span class="number">120</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//低音5  </span></span><br><span class="line"><span class="number">229.</span>	                <span class="number">121</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>001_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">230.</span>	                <span class="number">122</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//低音6   </span></span><br><span class="line"><span class="number">231.</span>	                <span class="number">123</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">232.</span>	                <span class="number">124</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">233.</span>	                <span class="number">125</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>100; tone&lt;=<span class="number">7&#x27;b</span>010_0000; end <span class="comment">//延音  </span></span><br><span class="line"><span class="number">234.</span>	                <span class="number">126</span>: begin pitch&lt;=<span class="number">3&#x27;b</span>000; tone&lt;=<span class="number">7&#x27;b</span>000_0000; end <span class="comment">//休止符  </span></span><br><span class="line"><span class="number">235.</span>	                  </span><br><span class="line"><span class="number">236.</span>	                endcase  </span><br><span class="line"><span class="number">237.</span>	        end  </span><br><span class="line"><span class="number">238.</span>	          </span><br><span class="line"><span class="number">239.</span>	          </span><br><span class="line"><span class="number">240.</span>	       <span class="comment">//高音部分  </span></span><br><span class="line"><span class="number">241.</span>	        <span class="keyword">if</span>(pitch == <span class="number">3&#x27;b</span>001)   </span><br><span class="line"><span class="number">242.</span>	            begin  </span><br><span class="line"><span class="number">243.</span>	            <span class="built_in"><span class="keyword">case</span></span>(tone)  </span><br><span class="line"><span class="number">244.</span>	            <span class="number">7&#x27;b</span>000_0000:begin beep&lt;=<span class="number">0</span>; end  </span><br><span class="line"><span class="number">245.</span>	            <span class="number">7&#x27;b</span>000_0001:begin beep&lt;=high[<span class="number">0</span>]; end  </span><br><span class="line"><span class="number">246.</span>	            <span class="number">7&#x27;b</span>000_0010:begin beep&lt;=high[<span class="number">1</span>]; end  </span><br><span class="line"><span class="number">247.</span>	            <span class="number">7&#x27;b</span>000_0100:begin beep&lt;=high[<span class="number">2</span>]; end  </span><br><span class="line"><span class="number">248.</span>	            <span class="number">7&#x27;b</span>000_1000:begin beep&lt;=high[<span class="number">3</span>]; end  </span><br><span class="line"><span class="number">249.</span>	            <span class="number">7&#x27;b</span>001_0000:begin beep&lt;=high[<span class="number">4</span>]; end  </span><br><span class="line"><span class="number">250.</span>	            <span class="number">7&#x27;b</span>010_0000:begin beep&lt;=high[<span class="number">5</span>]; end  </span><br><span class="line"><span class="number">251.</span>	            <span class="number">7&#x27;b</span>100_0000:begin beep&lt;=high[<span class="number">6</span>]; end  </span><br><span class="line"><span class="number">252.</span>	            endcase  </span><br><span class="line"><span class="number">253.</span>	            end  </span><br><span class="line"><span class="number">254.</span>	          </span><br><span class="line"><span class="number">255.</span>	        <span class="comment">//中音部分  </span></span><br><span class="line"><span class="number">256.</span>	        <span class="keyword">else</span> <span class="keyword">if</span>(pitch == <span class="number">3&#x27;b</span>010)  </span><br><span class="line"><span class="number">257.</span>	            begin  </span><br><span class="line"><span class="number">258.</span>	            <span class="built_in"><span class="keyword">case</span></span>(tone)  </span><br><span class="line"><span class="number">259.</span>	            <span class="number">7&#x27;b</span>000_0000:begin beep&lt;=<span class="number">0</span>; end  </span><br><span class="line"><span class="number">260.</span>	            <span class="number">7&#x27;b</span>000_0001:begin beep&lt;=middle[<span class="number">0</span>]; end  </span><br><span class="line"><span class="number">261.</span>	            <span class="number">7&#x27;b</span>000_0010:begin beep&lt;=middle[<span class="number">1</span>]; end  </span><br><span class="line"><span class="number">262.</span>	            <span class="number">7&#x27;b</span>000_0100:begin beep&lt;=middle[<span class="number">2</span>]; end  </span><br><span class="line"><span class="number">263.</span>	            <span class="number">7&#x27;b</span>000_1000:begin beep&lt;=middle[<span class="number">3</span>]; end  </span><br><span class="line"><span class="number">264.</span>	            <span class="number">7&#x27;b</span>001_0000:begin beep&lt;=middle[<span class="number">4</span>]; end  </span><br><span class="line"><span class="number">265.</span>	            <span class="number">7&#x27;b</span>010_0000:begin beep&lt;=middle[<span class="number">5</span>]; end  </span><br><span class="line"><span class="number">266.</span>	            <span class="number">7&#x27;b</span>100_0000:begin beep&lt;=middle[<span class="number">6</span>]; end  </span><br><span class="line"><span class="number">267.</span>	            endcase  </span><br><span class="line"><span class="number">268.</span>	            end  </span><br><span class="line"><span class="number">269.</span>	          </span><br><span class="line"><span class="number">270.</span>	        <span class="comment">//低音部分  </span></span><br><span class="line"><span class="number">271.</span>	        <span class="keyword">else</span> <span class="keyword">if</span>(pitch == <span class="number">3&#x27;b</span>100)  </span><br><span class="line"><span class="number">272.</span>	            begin  </span><br><span class="line"><span class="number">273.</span>	            <span class="built_in"><span class="keyword">case</span></span>(tone)  </span><br><span class="line"><span class="number">274.</span>	            <span class="number">7&#x27;b</span>000_0000:begin beep&lt;=<span class="number">0</span>; end  </span><br><span class="line"><span class="number">275.</span>	            <span class="number">7&#x27;b</span>000_0001:begin beep&lt;=low[<span class="number">0</span>]; end  </span><br><span class="line"><span class="number">276.</span>	            <span class="number">7&#x27;b</span>000_0010:begin beep&lt;=low[<span class="number">1</span>]; end  </span><br><span class="line"><span class="number">277.</span>	            <span class="number">7&#x27;b</span>000_0100:begin beep&lt;=low[<span class="number">2</span>]; end  </span><br><span class="line"><span class="number">278.</span>	            <span class="number">7&#x27;b</span>000_1000:begin beep&lt;=low[<span class="number">3</span>]; end  </span><br><span class="line"><span class="number">279.</span>	            <span class="number">7&#x27;b</span>001_0000:begin beep&lt;=low[<span class="number">4</span>]; end  </span><br><span class="line"><span class="number">280.</span>	            <span class="number">7&#x27;b</span>010_0000:begin beep&lt;=low[<span class="number">5</span>]; end  </span><br><span class="line"><span class="number">281.</span>	            <span class="number">7&#x27;b</span>100_0000:begin beep&lt;=low[<span class="number">6</span>]; end  </span><br><span class="line"><span class="number">282.</span>	            endcase  </span><br><span class="line"><span class="number">283.</span>	            end  </span><br><span class="line"><span class="number">284.</span>	              </span><br><span class="line"><span class="number">285.</span>	    end  </span><br><span class="line"><span class="number">286.</span>	      </span><br><span class="line"><span class="number">287.</span>	      </span><br><span class="line"><span class="number">288.</span>	      </span><br><span class="line"><span class="number">289.</span>	      </span><br><span class="line"><span class="number">290.</span>	    <span class="comment">//显示点阵  </span></span><br><span class="line"><span class="number">291.</span>	    <span class="function">show_LED <span class="title">sL1</span><span class="params">(.clk(clk),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">292.</span>	                    .SW(pitch),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">293.</span>	                    .key(tone),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">294.</span>	                    .row(row),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">295.</span>	                    .col_r(col_r),   </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">296.</span>	                    .col_g(col_g))</span></span>;  </span><br><span class="line"><span class="number">297.</span>	                      </span><br><span class="line"><span class="number">298.</span>	    <span class="comment">//数码管显示  </span></span><br><span class="line"><span class="number">299.</span>	    <span class="built_in">show_seg_tube</span>(.<span class="built_in">key</span>(tone),   </span><br><span class="line"><span class="number">300.</span>	                      .<span class="built_in">clk</span>(clk),   </span><br><span class="line"><span class="number">301.</span>	                      .<span class="built_in">seg</span>(seg));  </span><br><span class="line"><span class="number">302.</span>	endmodule  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h1 id="4-仿真波形分析"><a href="#4-仿真波形分析" class="headerlink" title="4 仿真波形分析"></a>4 仿真波形分析</h1><h2 id="4-1-数码管显示模块"><a href="#4-1-数码管显示模块" class="headerlink" title="4.1 数码管显示模块"></a>4.1 数码管显示模块</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在该模块的仿真中，笔者通过改变不同时间对应的key值，模拟用户在使用简易电子琴演奏器时按下按键的行为。仿真波形图如图6所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/2021013021570161.png" alt=" "></p>
<center><b>图 6 数码管显示模块的仿真波形图<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从图6中可以看出，随着用户按下按键的变化，数码管的输出信号产生了不同形式的变化。数码管的输出信号seg[0]至seg[7]分别对应了八段数码管的a，b，c，d，e，f，g七个显示段。与数码管的结构进行对照可以发现，key[0]至key[6]信号分别为高电平时，数码管上显示的数字为1,2,3,4,5,6,7。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本实验中，数码管显示所需要的行信号在顶层模块中直接赋值以确保只有7号数码管正常工作，因此在该模块仿真中并未体现。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h2 id="4-2-分频模块"><a href="#4-2-分频模块" class="headerlink" title="4.2 分频模块"></a>4.2 分频模块</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在该模块的仿真中，笔者给予输入的信号clk 1MHZ的时钟信号，尝试改变分频系数对时钟信号进行仿真，期望得到原时钟四分之一的频率。仿真的波形图如图7所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/20210130215817184.png" alt=" "></p>
<center><b>图 7 分频模块的仿真波形图<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从图7可以明显的看出，分频后的时钟信号的周期是原时钟信号周期的四倍。由此可知，该分频模块可以得到所需要的分频效果。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h2 id="4-3-点阵扫描模块"><a href="#4-3-点阵扫描模块" class="headerlink" title="4.3 点阵扫描模块"></a>4.3 点阵扫描模块</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在该模块的仿真中，笔者分别改变输入的音调和按下按键的情况，得到仿真波形如图8所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387081008614.png" alt=" "></p>
<center><b>图 8 点阵扫描模块的仿真波形图<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由图8可以看出，该模块中，当SW[2]=1代表播放低音时，只有绿色点阵亮起。同时，当按下key[3]时，列信号中的col_g[3]置0，即对应列全灭。当SW[1]=1代表播放中音时，只有红色点阵亮起，同时，当按下key[4]时，对应列全灭。当SW[0]=1代表播放高音时，红色绿色点阵同时亮起，显示黄色，同时，当按下key[1]时，对应列全灭。由此可知，该模块可以实现预设中所要实现的效果。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h2 id="4-4-乐曲演奏模块"><a href="#4-4-乐曲演奏模块" class="headerlink" title="4.4 乐曲演奏模块"></a>4.4 乐曲演奏模块</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该模块的仿真中，笔者将分别对手动演奏和自动演奏进行仿真。由于音符和系统时钟的频率相差较大，因此手动演奏和自动演奏的部分笔者都将以不同分度值的两幅仿真图展示，分别展示输出到蜂鸣器的频率和点阵、数码管的显示。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;手动演奏的仿真波形图如图9和图10所示。自动演奏的仿真波形图如图11、图12和图13所示。由于演奏部分所需要仿真的时间更长，远大于Quartus II中自带的仿真上限时间100us，故笔者在此编写testbench文件并使用ModelSim软件进行Gate Level Simulation操作。<br>由图9可以看出，当BTN[5]置为1，其他BTN置为0，SW为3’b100时，蜂鸣器输出信号beep变为低音6所对应的频率。同时，由图10可以知道，此时点阵列只出现绿色，且col_g[5]所表示的第6列不亮，数码管显示数字6。由此可知，该模块手动演奏部分可以正常实现所需要的功能。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由图11可以看出，在自动演奏信号auto_sw为1时，随着时间的推移每0.25秒会产生一次点阵列和数码管的变换，音符演奏所引起的行阵列和数码管的持续时间和切换效果符合预期设计。由图12可以看出，在切换音符时输出到蜂鸣器的信号频率也会相应改变，音符的切换效果符合预期设计。由图13可以看出，在自动演奏播放不同音符时，行阵列和数码管显示的效果（即点阵列上音符对应列全灭，数码管上显示音符数字）符合预期设计。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，仿真结果表示该模块设计完全符合预期效果。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387080676212.png" alt=" "></p>
<center><b>图 9 手动演奏的仿真波形图（蜂鸣器部分）<b></b></b></center>

<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387080387510.png" alt=" "></p>
<center><b>图 10 手动演奏的仿真波形图（数码管、点阵列部分）<b></b></b></center>

<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438707749338.png" alt=" "></p>
<center><b>图 11 自动演奏的仿真波形图（总体画面）<b></b></b></center>

<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438707720686.png" alt=" "></p>
<center><b>图 12 自动演奏的波形仿真图（两音符交界处-蜂鸣器）<b></b></b></center>

<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438707518164.png" alt=" "></p>
<center><b>图 13 自动演奏的波形仿真图（两音符交界处-行列信号）<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h1 id="5-功能说明及资源利用情况"><a href="#5-功能说明及资源利用情况" class="headerlink" title="5 功能说明及资源利用情况"></a>5 功能说明及资源利用情况</h1><h2 id="5-1-基本功能"><a href="#5-1-基本功能" class="headerlink" title="5.1 基本功能"></a>5.1 基本功能</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.用 8×8 点阵显示“1 2 3 4 5 6 7”七个音符构成的电子琴键盘。其中点阵的第一列用一个 LED 点亮表示音符“1”，第二列用二个 LED 点亮表示音符“2”，依此类推。当音符为低音 1~7 时，点阵显示为绿色；当音符为中音 1~7 时，点阵显示为红色；当音符为高音 1~7 时，点阵显示为黄色；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.用 BTN7～BTN1 七个按键模拟电子琴手动演奏时的“1 2 3 4 5 6 7”七个音符。当某个按键按下时，数码管 DISP7 显示相应的音符，点阵上与之对应的音符显示列全灭，同时蜂鸣器演奏相应的声音；当按键放开时数码管显示的音符灭掉，点阵显示恢复，蜂鸣器停止声音的输出。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.由拨码开关SW7,SW6,SW5切换选择高、中、低音，点阵颜色进行相应变化。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.可通过一个拨码开关进行手动/自动演奏的切换，自动演奏时，点阵根据乐曲进行颜 色和亮灭的变化。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h2 id="5-2-资源利用情况"><a href="#5-2-资源利用情况" class="headerlink" title="5.2 资源利用情况"></a>5.2 资源利用情况</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本次实验共使用了1150个逻辑单元，占电路板总逻辑单元数的91%；共使用了53个管脚，占电路板总管脚数的46%，如图14所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438707474712.png" alt=" "></p>
<center><b>图 14 逻辑单元及管脚使用情况<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;管脚分配情况如图15和图16所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-Verilog-%E6%95%B0%E7%94%B5%E7%94%B5%E5%AD%90%E7%90%B4/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png" alt=" "></p>
<center><b>图 15 MAX II EPM1270T144C5管脚分配图<b></b></b></center>

<p><div align="center"></div></p>
<p><image src="https://img-blog.csdnimg.cn/20210130220530555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70"><br>&lt;/div&gt;</image></p>
<center><b>图 16 管脚分配图<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h1 id="6-故障问题及分析"><a href="#6-故障问题及分析" class="headerlink" title="6 故障问题及分析"></a>6 故障问题及分析</h1><h2 id="6-1-按键消抖后无法实现功能"><a href="#6-1-按键消抖后无法实现功能" class="headerlink" title="6.1 按键消抖后无法实现功能"></a>6.1 按键消抖后无法实现功能</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故障描述：调用按键消抖后蜂鸣器只产生“噗”的一声，而无法正常发出音调。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题分析：经过分析按键消抖的方式和蜂鸣器发声的条件，发现按键消抖主要是靠产生的脉冲信号实现功能，而电子琴发声需要按键产生持续的高电平。同时，在该情况下按键不消抖并不会影响到电子琴功能的输出和用户的体验，因此取消按键消抖模块，该问题得以解决。</p>
<h2 id="6-2-仿真时蜂鸣器信号无波形"><a href="#6-2-仿真时蜂鸣器信号无波形" class="headerlink" title="6.2 仿真时蜂鸣器信号无波形"></a>6.2 仿真时蜂鸣器信号无波形</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故障描述：在使用Quartus自带仿真时，点击运行仿真，蜂鸣器信号保持为一条直线。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题分析：Quartus自带的仿真时间上限为100us，而需要输出的信号频率导致了其需要更长的时间才能展现出来，因此编写testbench文件，调用ModelSim软件进行仿真，问题得以解决。</p>
<h2 id="6-3-对自动播放进行仿真时没有波形变化"><a href="#6-3-对自动播放进行仿真时没有波形变化" class="headerlink" title="6.3 对自动播放进行仿真时没有波形变化"></a>6.3 对自动播放进行仿真时没有波形变化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故障描述：使用Quartus自带仿真对自动播放功能进行仿真时，无法显示自动播放所产生的各种波形变换。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题分析：Quartus自带的仿真时间上限为100us，而一个四分音符播放所需要的时间至少为0.25秒，远远大于Quartus自带的仿真时间上限，因此通过编写testbench文件，调用ModelSim软件进行仿真，问题得以解决。</p>
<h2 id="6-4-仿真成功但板子上没有现象"><a href="#6-4-仿真成功但板子上没有现象" class="headerlink" title="6.4 仿真成功但板子上没有现象"></a>6.4 仿真成功但板子上没有现象</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故障描述：烧录成功后发现蜂鸣器发声错误，点阵数码管亮得十分混乱。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题分析：电路实验板上的电路拨码开关设置的状态不正确，时钟信号不是1MHz。通过调整拨码开关，将第2位和第4位调至高电平，时钟信号变为1MHz，蜂鸣器正常发声，点阵和数码管正常显示。</p>
<h2 id="6-5-按键消抖后无法实现功能"><a href="#6-5-按键消抖后无法实现功能" class="headerlink" title="6.5 按键消抖后无法实现功能"></a>6.5 按键消抖后无法实现功能</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故障描述：调用按键消抖后蜂鸣器只产生“噗”的一声，而无法正常发出音调。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题分析：经过分析按键消抖的方式和蜂鸣器发声的条件，发现按键消抖主要是靠产生的脉冲信号实现功能，而电子琴发声需要按键产生持续的高电平。同时，在该情况下按键不消抖并不会影响到电子琴功能的输出和用户的体验，因此取消按键消抖模块，该问题得以解决。</p>
<h2 id="6-6-数码管和LED点亮形式不正确"><a href="#6-6-数码管和LED点亮形式不正确" class="headerlink" title="6.6 数码管和LED点亮形式不正确"></a>6.6 数码管和LED点亮形式不正确</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故障描述：左边两个数码管始终亮，且LED半边不亮。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题分析：当拨码开关SW10的第3位和第4位拨到下边时，数码管DS6和DS7的位码 控制端CAT6和CAT7不受EPM1270T144C5芯片的引脚控制。因而需要把使能控制SW10的最右两位拨码成’11’，即可正常显示。</p>
<h2 id="6-7-点阵列反向显示"><a href="#6-7-点阵列反向显示" class="headerlink" title="6.7 点阵列反向显示"></a>6.7 点阵列反向显示</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故障描述：点阵列显示的图案和预计的图案发生了反转。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题分析：经过查对，发现可编程实验板上点阵列的序号是从下往下、从左往右递增的，和笔者预设的高低位值相反，导致了图案发生反转。经过更改管脚使点阵正确显示。</p>
<h2 id="6-8-程序烧录后有的按键有反应有的按键无反应"><a href="#6-8-程序烧录后有的按键有反应有的按键无反应" class="headerlink" title="6.8 程序烧录后有的按键有反应有的按键无反应"></a>6.8 程序烧录后有的按键有反应有的按键无反应</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故障描述：将仿真通过的程序烧录到可编程实验板后，一些按键按下后有正常效果出现，而一些按键按下后没有反应。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题分析：由于部分按键按下后有正常效果，更换可编程实验板后也有正常效果，因此排除程序上的问题。将可编程实验板没有反应的按键的引脚对应引脚接入示波器，按下按键后发现没有波形。再将正常功能按键的引脚接入示波器后，按下按键后可以检测到高电平，因此排除了程序上的故障，问题应是由于按键损坏等原因所引起的。</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
      </tags>
  </entry>
  <entry>
    <title>简易函数信号发生器的设计和实现</title>
    <url>/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文记述了笔者设计并实现以±12V供电电压输出1KHZ~10KHZ频率连续可调的方波、三角波和正弦波的过程。其中，方波输出电压峰峰值为12V（误差&lt;20%），占空比可调、三角波输出电压峰峰值为8V（±20%），正弦波输出电压峰峰值≥1V。</p>
<span id="more"></span>
<h1 id="1-设计任务要求"><a href="#1-设计任务要求" class="headerlink" title="1 设计任务要求"></a>1 设计任务要求</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计并制作一个简易的方波-三角波-正弦波信号发生器，供电电源为 ，要求频率调节方便，并满足以下指标：<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.输出频率在1KHZ~10KHZ范围内连续可调。<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.方波输出电压峰峰值U~OPP~=12V（误差&lt;20%），上升、下降沿均小于10μs。<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.三角波输出电压峰峰值U~OPP~=8V（±20%）。<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.在1KHZ-10KHZ的频率范围内，正弦波输出电压峰峰值U~OPP~≥1V，无明显失真。<br>    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.输出方波为占空比可调的矩形波，占空比可调范围不小于30%-70%。</p>
<h1 id="2-设计思路和整体设计框图"><a href="#2-设计思路和整体设计框图" class="headerlink" title="2 设计思路和整体设计框图"></a>2 设计思路和整体设计框图</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据实验要求，需要制作一个简易方波—三角波—正弦波的信号发生器。因此，容易想到的两种解决方案如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.先通过正弦振荡电路产生正弦波，再通过正弦波-方波变换电路得到方波，最后通过方波-三角波变换电路得到三角波，从而实现功能；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.先通过方波振荡电路产生方波，再通过方波-三角波变换电路产生三角波，最后通过三角波-正弦波变换电路产生正弦波，从而实现功能。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方案1和2所对应的总体流程框图分别如图1和图2所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/2021013022415553.png" alt=" "></p>
<center><b>图 1<b></b></b></center>

<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/20210130224220672.png" alt=" "></p>
<center><b>图 2<b></b></b></center>

<h1 id="3-分块电路和总体电路的设计-含电路图"><a href="#3-分块电路和总体电路的设计-含电路图" class="headerlink" title="3 分块电路和总体电路的设计(含电路图)"></a>3 分块电路和总体电路的设计(含电路图)</h1><h2 id="3-1-矩形和三角波发生器"><a href="#3-1-矩形和三角波发生器" class="headerlink" title="3.1 矩形和三角波发生器"></a>3.1 矩形和三角波发生器</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据LM318N和UA741CP的数据手册和文献资料，LM318N是一种性能好，价格低，使用可靠的高速运算放大器，适合多种情况下信号的高速放大。因此，笔者采用运算速度较快的LM318N作为矩形波发生电路的运放，而实验所提供的UA741CP运放则用于三角波发生电路。该部分的电路图如图3所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png" alt=" "></p>
<center><b>图 3<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该部分电路中，运放LM318N接成迟滞电压比较器，运放UA741CP接成反相输入式积分器，期分期的输入电压来自于迟滞电压比较器的输出，迟滞电压比较器的输入信号来自于积分器的输出。设迟滞电压比较器的输出 的初始值为高电平，经过积分器后可在UA741CP的6端口处得到线性下降的输出信号 。这时该线性下降的信号又反馈至迟滞电压比较器的输入端，当其下降至比较器的下门限电压 时，比较器的输出将产生跳变，由低电平跳变为高电平，如此循环往复，最终迟滞电压比较器的输出 为方波信号，而在反相积分器的输出端 可以得到三角波信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设稳压管反向击穿电压为 ，正向导通电压为 ，故该电路产生的方波和三角波的输出幅度分别为：</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/202101302244371.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该实验中，要求方波的输出电压峰峰值U~OPP~=12V(误差&lt;20%) ，三角波的输出电压峰峰值U~OPP~=8V(误差&lt;20%) ，故可以计算出：</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/20210130224622514.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于在普通实践运用中，电阻值的选取多为千欧量级。选取电阻值过小会导致电路中的电流过大，选取电阻值过大会导致热噪声的过大，进而影响输出结果。故在此笔者选取两个电阻的阻值分别为：</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/20210130224658818.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于要使得集成运放两输入端的对地直流电阻箱等，运放的偏置电流才不会产生附加的失调电压，故运放输入端所接电阻要平衡，因此有</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/20210130224732309.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时，在LM318N的输出端接入一个限流电阻R~O~=3.3KΩ以保护电路。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在矩形波-三角波发生电路中，由理论分析，电路的震荡频率为：</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/20210130224828658-164387022312442.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要满足输出频率在1KHZ-10KHZ范围内连续可调，于是选用 100KΩ的可调电位器进行调频，且选择电容值C=0.01μF的电容，电阻值R~2~=10kΩ。与上文相同，在运放的输入端所接电阻要平衡，故可以得到R~4~=R~2~=10kΩ。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于Multisim中的元器件库缺乏双稳压管，根据实验中方波峰峰值的要求，选择两个稳压值为6V的稳压管D1,D2代替元件2DW232进行仿真。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，改变方波的占空比可以通过将RC反馈电路中的R变成一个滑动变阻器和两个二极管组成的模块，通过调节滑动变阻器使其充放电时间不同，从而改变方波的占空比。改进后的方波-三角波发生电路如图4所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387021984240.png" alt=" "></p>
<center><b>图 4<b></b></b></center>

<h2 id="3-2-正弦波发生器"><a href="#3-2-正弦波发生器" class="headerlink" title="3.2 正弦波发生器"></a>3.2 正弦波发生器</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在该设计中的前半部分已经成功得到了符合实验要求的矩形波和三角波，因此，该部分模块所要实现的主要功能为三角波到正弦波的转变。三角波到正弦波的转换电路种类多样，包括了二极管桥式电路、二极管可变分压器电路和差分放大器等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本实验中，笔者利用差分放大器传输特性曲线的非线性，进而实现三角波到正弦波的变换。其原理图如图5所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/20210130225130515.png" alt=" "></p>
<center><b>图 5<b></b></b></center>

<p>由图5可知：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    （1）差分放大器的传输特性曲线越对称、线性区越窄越好；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    （2）输入三角波的幅度应该正好使得晶体管接近截止区。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    图6为笔者在Multisim软件上实现三角波到正弦波变换的差分电路。图中的Rp1用来调节输入三角波的幅度大小，Rp2调整电路的对称性，并联电阻R9用来减小差分放大器传输特性曲线的线性区。电容C2,C3,C4为隔直流电容，C5为滤波电容，用于滤除正弦波波峰和波谷处的毛刺，滤除谐波分量，改善输出正弦波的波形。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387021444437.png" alt=" "></p>
<center><b>图 6<b></b></b></center>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据电路实际情况，隔直流电容C2,C3采用了33uF的电容，C4采用了1uF的电容，并根据仿真出的正弦波效果选择了6800pF的C5作为滤波电容。Q1,Q2,Q3,Q4根据实验室提供的元器件，在仿真时选择的是8050NPN管。</p>
<h2 id="3-3-整体电路"><a href="#3-3-整体电路" class="headerlink" title="3.3 整体电路"></a>3.3 整体电路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将三角波发生器的输出端接入正弦波发生器的输入端，即可获得完整的方波-三角波-正弦波发生电路。整体的实际电路图如图7所示。整体的Multisim仿真原理图及波形图将在本文第七部分详细呈现。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387021141035.png" alt=" "></p>
<center><b>图 7<b></b></b></center>

<h1 id="4-所实现的功能说明"><a href="#4-所实现的功能说明" class="headerlink" title="4 所实现的功能说明"></a>4 所实现的功能说明</h1><h2 id="4-1-矩形和三角波发生器"><a href="#4-1-矩形和三角波发生器" class="headerlink" title="4.1 矩形和三角波发生器"></a>4.1 矩形和三角波发生器</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现了将输入的±12V直流信号转变为输出电压峰峰值U~OPP~=12V（误差≤20%）的方波，上升、下降沿均小于10μs且输出的方波的占空比在30%-70%内可调节，频率在1KHZ-10KHZ内可调节，并可以输出电压峰峰值U~OPP~=8V（误差≤20%）的三角波信号。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实验室实测的波形图如图8，图9，图10所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387020780133.png" alt=" "></p>
<center><b>图 8<b></b></b></center>

<p><div align="center"></div></p>
<p><image src="https://img-blog.csdnimg.cn/2021013022592943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70"><br>&lt;/div&gt;</image></p>
<center><b>图 9<b></b></b></center>

<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387020462631.png" alt=" "></p>
<center><b>图 10<b></b></b></center>

<h2 id="4-2-正弦波发生器"><a href="#4-2-正弦波发生器" class="headerlink" title="4.2 正弦波发生器"></a>4.2 正弦波发生器</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现了将输入的三角波转换为正弦波的功能，正弦波峰峰值大于1V~PP~，无明显失真。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实验室实测波形图如图11，图12所示。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387020203529.png" alt=" "></p>
<center><b>图 11<b></b></b></center>
![ ](%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387019908527.png)

<center><b>图 12<b></b></b></center>

<h1 id="5-故障及问题分析"><a href="#5-故障及问题分析" class="headerlink" title="5 故障及问题分析"></a>5 故障及问题分析</h1><h2 id="5-1-无法正确提供-12V的电压值"><a href="#5-1-无法正确提供-12V的电压值" class="headerlink" title="5.1 无法正确提供-12V的电压值"></a>5.1 无法正确提供-12V的电压值</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因分析：初步尝试时，将双输出恒压源的其中一个输出端（红线）和另一个输入端（黑线）分别接在了面包板两侧的地，导致获得的波形与仿真结果相差甚远，如图13所示。通过分析和查阅相关文献资料后，将接法修改为将红线和黑线接在同一个位置后，再通过导线将面包板两侧的地连接起来，成功解决了该故障。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387019500525.png" alt=" "></p>
<center><b>图 13<b></b></b></center>

<h2 id="5-2-波形频率无法满足1KHZ-10KHZ范围内可调"><a href="#5-2-波形频率无法满足1KHZ-10KHZ范围内可调" class="headerlink" title="5.2 波形频率无法满足1KHZ-10KHZ范围内可调"></a>5.2 波形频率无法满足1KHZ-10KHZ范围内可调</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因分析：根据理论分析可知，电路的震荡频率为</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/20210130224828658.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;笔者最初的设想是随着滑动变阻器划片的移动， R~P2~可以趋近于无穷小，此时<script type="math/tex">\frac{R_{P2}}{R_{P1}}</script>趋近于0。同理，R~P1~可以趋近于无穷大，此时<script type="math/tex">\frac{R_{P2}}{R_{P1}}</script>应当趋近于无穷大。然而实际电路中，波形的频率增加或降低到一定值时，无论如何调整滑动变阻器的划片都无法使得波形频率进一步改变。因此，笔者通过改变震荡频率公式前的系数 <script type="math/tex">\frac{R_{f}}{4R_1R_2C}</script>，即通过改变R~1~、R~2~和C的值来改变电路的震荡频率范围。</p>
<h2 id="5-3-双稳压管2DW232接入电路中后没有稳压效果"><a href="#5-3-双稳压管2DW232接入电路中后没有稳压效果" class="headerlink" title="5.3 双稳压管2DW232接入电路中后没有稳压效果"></a>5.3 双稳压管2DW232接入电路中后没有稳压效果</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因分析：查阅资料后发现，双稳压管2DW232是电压基准二极管，参数为6.0V-6.5V，30mA和200mW，2DW232的示意图如图14所示。2DW232中封装了一对稳压二极管，内部结构如图15所示。因此，将2DW232接入电源时应该从两个稳压管两端接线。在确定管脚时先用万用表的电阻档，分别测量两个管脚之间的电阻值。当测量到某一个管脚和另外两个管脚之间的电阻值都相同时，该管脚即为图14所示的2号管脚，不接入电路。调整2DW232后，稳压效果生效，故此解决问题。</p>
<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/20210130230730907.png" alt=" "></p>
<center><b>图 14<b></b></b></center>

<p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387018156120-164387018295322.png" alt=" "></p>
<center><b>图 15<b></b></b></center>

<h2 id="5-4-正弦波波形出现截止失真"><a href="#5-4-正弦波波形出现截止失真" class="headerlink" title="5.4 正弦波波形出现截止失真"></a>5.4 正弦波波形出现截止失真</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因分析：根据理论分析可知，当晶体管的静态工作点设置较低时，由于输入信号的叠加有可能使叠加后的波形一部分进入截止区，输出电压的顶部出现削波。因此，需要给三极管足够的偏置，使得BJT都工作在放大区，而不进入饱和区或截止区。</p>
<h2 id="5-5-将RC电路中的R替换为二极管和滑动变阻器的组合后波形消失"><a href="#5-5-将RC电路中的R替换为二极管和滑动变阻器的组合后波形消失" class="headerlink" title="5.5 将RC电路中的R替换为二极管和滑动变阻器的组合后波形消失"></a>5.5 将RC电路中的R替换为二极管和滑动变阻器的组合后波形消失</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因分析：无法出现波形后，笔者首先将改变后的部分还原，发现仍然有波形出现。因此锁定出现问题的部分为二极管和滑动变阻器的组合。检查后发现二极管和滑动变阻器都接在该有的位置，因此怀疑是否存在二极管或滑动变阻器损坏的问题。更换二极管后，示波器上出现波形，故此解决问题。</p>
<h2 id="5-6-不小心将接好的面包板摔在地上后无法出现波形"><a href="#5-6-不小心将接好的面包板摔在地上后无法出现波形" class="headerlink" title="5.6 不小心将接好的面包板摔在地上后无法出现波形"></a>5.6 不小心将接好的面包板摔在地上后无法出现波形</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因分析：首先检查元器件是否有缺失，电路连线是否有缺失。肉眼检查后发现元件和连线无误，重新接入电源和示波器后发现仍然没有波形。此时使用改锥对触碰每一条导线，发现触碰其中一条接地线时示波器上有波形跳动。将该条导线替换后示波器上波形正常，故此解决问题。</p>
<h2 id="5-7-找不到仿真中合适的电阻值"><a href="#5-7-找不到仿真中合适的电阻值" class="headerlink" title="5.7 找不到仿真中合适的电阻值"></a>5.7 找不到仿真中合适的电阻值</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因分析：通过查阅资料发现，电阻的制造过程中每一个电阻的阻值都存在一定范围内的误差，且并非所有的阻值都有对应的电阻。因此在选择电阻接入电路时，笔者尽可能选择接近仿真时所使用的电阻值接入电路，以减小影响。</p>
<h1 id="6-Multisim仿真原理图、波形图"><a href="#6-Multisim仿真原理图、波形图" class="headerlink" title="6 Multisim仿真原理图、波形图"></a>6 Multisim仿真原理图、波形图</h1><h2 id="6-1-矩形和三角波发生器"><a href="#6-1-矩形和三角波发生器" class="headerlink" title="6.1 矩形和三角波发生器"></a>6.1 矩形和三角波发生器</h2><h3 id="6-1-1-仿真原理图"><a href="#6-1-1-仿真原理图" class="headerlink" title="6.1.1 仿真原理图"></a>6.1.1 仿真原理图</h3><p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387016749217-164387017240019.png" alt=" "></p>
<h3 id="6-1-2-仿真波形图"><a href="#6-1-2-仿真波形图" class="headerlink" title="6.1.2 仿真波形图"></a>6.1.2 仿真波形图</h3><p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387016164815.png" alt=" "></p>
<h3 id="6-1-3-实测波形图"><a href="#6-1-3-实测波形图" class="headerlink" title="6.1.3 实测波形图"></a>6.1.3 实测波形图</h3><p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387014524312-164387014703314.png" alt=" "></p>
<h2 id="6-2-正弦波发生器"><a href="#6-2-正弦波发生器" class="headerlink" title="6.2 正弦波发生器"></a>6.2 正弦波发生器</h2><h3 id="6-2-1-仿真原理图"><a href="#6-2-1-仿真原理图" class="headerlink" title="6.2.1 仿真原理图"></a>6.2.1 仿真原理图</h3><p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438701238485.png" alt=" "></p>
<h3 id="6-2-2-仿真波形图"><a href="#6-2-2-仿真波形图" class="headerlink" title="6.2.2 仿真波形图"></a>6.2.2 仿真波形图</h3><p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438701297688.png" alt=" "></p>
<h3 id="6-2-3-实测波形图"><a href="#6-2-3-实测波形图" class="headerlink" title="6.2.3 实测波形图"></a>6.2.3 实测波形图</h3><p><img src="/2021/01/30/%E9%A1%B9%E7%9B%AE-%E6%A8%A1%E7%94%B5-%E6%A8%A1%E7%94%B5%E5%87%BD%E6%95%B0%E4%BF%A1%E5%8F%B7%E5%8F%91%E7%94%9F%E5%99%A8/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387013126410.png" alt=" "></p>
<h1 id="7-所用元器件及测试仪表清单"><a href="#7-所用元器件及测试仪表清单" class="headerlink" title="7 所用元器件及测试仪表清单"></a>7 所用元器件及测试仪表清单</h1><h2 id="7-1-所用元器件"><a href="#7-1-所用元器件" class="headerlink" title="7.1 所用元器件"></a>7.1 所用元器件</h2><div class="table-container">
<table>
<thead>
<tr>
<th>电阻R（Ω）</th>
<th>个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>1</td>
</tr>
<tr>
<td>1k</td>
<td>3</td>
</tr>
<tr>
<td>3.3k</td>
<td>2</td>
</tr>
<tr>
<td>4.7k</td>
<td>2</td>
</tr>
<tr>
<td>5.6k</td>
<td>2</td>
</tr>
<tr>
<td>12k</td>
<td>1</td>
</tr>
<tr>
<td>20k</td>
<td>1</td>
</tr>
<tr>
<td>22k</td>
<td>1</td>
</tr>
<tr>
<td>30k</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>电位器（Ω）</th>
<th>个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>1</td>
</tr>
<tr>
<td>100k</td>
<td>2</td>
</tr>
<tr>
<td>200k</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>电容(uF)</th>
<th>个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>0.0068</td>
<td>1</td>
</tr>
<tr>
<td>0.01</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>33</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>其他元器件(名称)</th>
<th>个数</th>
</tr>
</thead>
<tbody>
<tr>
<td>运算放大器LM318N</td>
<td>1</td>
</tr>
<tr>
<td>运算放大器UA741CP</td>
<td>1</td>
</tr>
<tr>
<td>三极管8050</td>
<td>4</td>
</tr>
<tr>
<td>双稳压管2DW232</td>
<td>1</td>
</tr>
<tr>
<td>二极管1N4148</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<h2 id="7-2-测试所用的仪器"><a href="#7-2-测试所用的仪器" class="headerlink" title="7.2 测试所用的仪器"></a>7.2 测试所用的仪器</h2><div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>型号</th>
</tr>
</thead>
<tbody>
<tr>
<td>示波器</td>
<td>MDO3012</td>
</tr>
<tr>
<td>直流稳压电源</td>
<td>SS2323</td>
</tr>
<tr>
<td>面包板</td>
<td>无</td>
</tr>
<tr>
<td>万用表</td>
<td>UT61A</td>
</tr>
</tbody>
</table>
</div>
<h1 id="8-参考文献"><a href="#8-参考文献" class="headerlink" title="8 参考文献"></a>8 参考文献</h1><p>[1]杨世清.高速运算放大器LM318N应用简介[J].集成电路应用,1993,05:19-20.<br>[2]王骥,王立臣,杜爽.模拟电路分析与设计[M].清华大学出版社:北京,2012:202-277.<br>[3]周开邻,王彩君,杨睿.模拟电路实验[M].国防工业出版社:北京,2009:99-102.<br>[4]Texas Instruments.LM118/LM218/LM318 Operational Amplifiers datasheet (Rev. C)[EB/OL].<a href="https://www.ti.com/lit/ds/symlink/lm318-n.pdf?ts=1603718649867&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FLM318-N,2013-3-20">https://www.ti.com/lit/ds/symlink/lm318-n.pdf?ts=1603718649867&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fproduct%252FLM318-N,2013-3-20</a>.<br>[5]Texas Instruments.µA741 General-Purpose Operational Amplifiers[EB/OL].<a href="https://www.ti.com/lit/ds/symlink/ua741.pdf?ts=1603718760064&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fsitesearch%252Fdocs%252Funiversalsearch.tsp%253FsearchTerm%253Dua741,2018-1-15">https://www.ti.com/lit/ds/symlink/ua741.pdf?ts=1603718760064&amp;ref_url=https%253A%252F%252Fwww.ti.com%252Fsitesearch%252Fdocs%252Funiversalsearch.tsp%253FsearchTerm%253Dua741,2018-1-15</a>.<br>[6]电子爱好者.2DW232参数[EB/OL].<a href="https://www.dianziaihaozhe.com/jingtiguan/?model=2DW232,2010">https://www.dianziaihaozhe.com/jingtiguan/?model=2DW232,2010</a>.<br>[7]电子发烧友.1N4148二极管的作用[EB/OL].<a href="http://www.elecfans.com/yuanqijian/erjiguang/20171031573210.html,2017-10-31">http://www.elecfans.com/yuanqijian/erjiguang/20171031573210.html,2017-10-31</a>.<br>[8]Tektronix.MDO3000系列混合域示波器用户手册[EB/OL].www.tektronix.com,2020-8-13.<br>[9]陈翠.函数信号发生器的工作原理[EB/OL].<a href="http://www.elecfans.com/d/775486.html,2018-9-12">http://www.elecfans.com/d/775486.html,2018-9-12</a>.<br>[10]刘宝玲,北京邮电大学信息与通信工程学院.电子电路基础 第二版[M].高等教育出版社:北京,2013:392-395.</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>模电</category>
      </categories>
      <tags>
        <tag>模电</tag>
      </tags>
  </entry>
  <entry>
    <title>金工实习报告</title>
    <url>/2021/07/19/%E9%A1%B9%E7%9B%AE-%E9%87%91%E5%B7%A5%E5%AE%9E%E4%B9%A0-%E9%87%91%E5%B7%A5%E5%AE%9E%E4%B9%A0%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录了2019级金工实习内容。</p>
<span id="more"></span>
<h1 id="车工"><a href="#车工" class="headerlink" title="车工"></a>车工</h1><h2 id="车床的附件"><a href="#车床的附件" class="headerlink" title="车床的附件"></a>车床的附件</h2><p><strong>1.1.1 三爪卡盘</strong></p>
<p>三爪卡盘是车床最常用的附件之一。</p>
<p><strong>（1）组成</strong></p>
<p>三爪卡盘主要由卡爪、大锥齿轮、小锥齿轮、卡盘体和后盖五部分组成。其中，大锥齿轮与三个小锥齿轮啮合，三抓扳手的方头可以插入任意一个小锥齿轮端部的方孔内。大锥齿轮背面有平面螺纹，平面螺纹与三个卡爪背面的螺纹相啮合。</p>
<p><strong>（2）安装和用法</strong></p>
<p>将大锥齿轮装入卡盘体内，装上小锥齿轮，盖上盖板，装上后盖，将其翻转过来后装上三个卡爪。用三抓扳手转动任意一个小锥齿轮均可带动大锥齿轮，大锥齿轮通过背面的平面螺纹同时带动三个卡爪进行向心或离心活动，以夹紧或松开空间。三爪卡盘是通过锥面定位，依靠间传递扭矩，用螺母锁紧安装到车床主轴上的。三爪卡盘主要用来装载截面为圆形的短棒料和盘套类的中小型工件、正六边形工件。</p>
<p>三爪卡盘配有正爪和反爪各一套，台阶向外的为正爪、台阶向里的为反爪。反爪用于安装直径较大的工件。三爪卡盘可以十分方便的装卸工件。</p>
<p>需要注意的是，三爪卡盘对中精度较低。对两端有同轴度要求的工件，在三抓卡盘上用调头车削的方法，一般是不能保证完成同轴度的需求的。</p>
<p><strong>1.1.2 四爪卡盘</strong></p>
<p><strong>（1）组成</strong></p>
<p>四爪卡盘又称四爪单轴卡盘，由卡盘体、调整螺杆和四个卡爪组成。每个卡爪内部的半周内螺纹与调整螺杆相啮合。调整螺杆端部有一方孔。当四爪扳手插入方孔用手转动一根螺杆时，该螺杆带动与之相啮合的卡爪一起移动。四爪卡盘的四个卡爪都可以独立移动。</p>
<p><strong>（2）安装和用法</strong></p>
<p>四爪卡盘也是通过锥面定位，依靠间传递扭矩，用螺母锁紧安装到车床主轴上的。四爪卡盘与三爪卡盘不同的地方在于，它不需要正反两套卡爪。四爪卡盘的卡爪即可用作正爪可也用作反爪。其中，反爪用来安装尺寸较大的工件。</p>
<p>四爪卡盘用于装夹工件时，为使工件上加工表面的轴线与车床主轴一致，必须人为进行矫正。可用划线盘进行毛坯面的矫正，其校正精度较低。工件矫正之后即可进行加工。若较正面为已加工表面，需要用百分表进行矫正，其校正精度较高。</p>
<p>四爪卡盘适宜安装偏心工件、截面为方形的工件、长方形、椭圆形和不规则形状的工件、</p>
<p><strong>1.1.3 花盘</strong></p>
<p><strong>（1）组成</strong></p>
<p>花盘是一个铸铁大圆盘，与卡盘一样，可以装在车床主轴上。</p>
<p><strong>（2）安装和用法</strong></p>
<p>花盘的端面是装夹工件的工作面，要求有较高的平面度，并与主轴轴线垂直，因此安装工件前应用百分表检测。花盘上有许多长槽，供安装工件时穿放螺塞。在花盘上加工可以保证工件外圆与孔的轴线和基准面垂直或端面与基准面平行。</p>
<p>花盘适宜安装要求孔和外圆与基准面垂直，或断面与基准面平行的外形复杂的工件。</p>
<p><strong>1.1.4 花盘-弯板</strong></p>
<p><strong>（1）组成</strong></p>
<p>弯板又称角铁，工作面与安装面垂直。在车床上，弯板要和花盘配合使用，弯板安装在花盘上。</p>
<p><strong>（2）安装和用法</strong></p>
<p>弯板的工作面必须与车床主轴轴线平行，因此安装工件前应用百分表检测。若不平行可在弯板与花盘之间垫铜皮或纸片来调整。</p>
<p>安装工件时，将工件的基准面贴靠在弯板的工作面上，用螺栓轻轻压紧，用划线盘按划线进行矫正。矫正之后将工件锁紧。由于弯板和工件的重心偏向工件一边，应在花盘的另一边配上重量适当的平衡重物。安装完毕之后即可进行车削加工。</p>
<p>在花盘-弯板可以保证孔的轴线和基准面平行或端面与基准面垂直。因此花盘-弯板适宜安装要求外圆和孔的轴线与基准面平行，或端面与基准面垂直的支架、壳体类工件。</p>
<p><strong>1.1.5 中心架</strong></p>
<p><strong>（1）组成</strong></p>
<p>中心架不能单独使用，一定要与卡盘或双体件配合使用。中心架既可以作为夹具的一部分，也可以只起辅助的支撑作用。</p>
<p>中心架主要由底座、支承爪、盖子、调整螺钉、紧固螺钉和压板等组成。三个支承爪可以单独向里或向外调整伸出的长度，盖子可以打开或合上，可以用紧固螺钉使其和底座紧固在一起。</p>
<p><strong>（2）安装和用法</strong></p>
<p>中心架可以根据工件的长度放置在车床导轨面纵向任何位置上，用压板螺栓将其压紧在床身导轨上。因此，在工作过程中中心架是固定不动的。</p>
<p>中心架只能放置在已加工面上，与卡盘配合使用，用于安装轴或套筒工件以加工端面和孔；与双顶尖配合使用可以安装细长阶梯轴；作为辅助支撑可以增加工件刚度，减少弹性弯曲变形。</p>
<p><strong>1.1.6 跟刀架</strong></p>
<p>跟刀架要与双顶尖配合使用，一般只起到辅助支撑的作用。</p>
<p>跟刀架由支承爪、架体和调整螺钉组成。跟刀架固定在大刀架的左侧。在工作过程中，可以随大刀架纵向移动。</p>
<p>跟刀架用于车削细长光滑轴的辅助支撑，以增加工件刚度，减少工件弹性弯曲变形。</p>
<h2 id="车床的基本操作"><a href="#车床的基本操作" class="headerlink" title="车床的基本操作"></a>车床的基本操作</h2><p>将工件稳固地安装在车床上是车削加工的前提。</p>
<p><strong>1.2.1 安装工件</strong></p>
<p>以三爪卡盘为例，直径较小的工件使用正爪三爪卡盘，将工件放入三个卡爪的中心部位，用三爪扳手轻轻拧紧，低速开车，观察工件端面是否摆动。若摆动，则轻轻敲打工件进行矫正，矫正后牢牢卡紧工件。对于直径较大的工件使用反爪三爪卡盘，轻轻夹紧，再用小锤轻敲工件端面使其贴近反爪的台阶面，最后夹紧工件。</p>
<p>安装工件时应注意以下四点：</p>
<p>（1）应尽量减少工件悬伸长度；</p>
<p>（2）工件要装正夹牢；</p>
<p>（3）夹紧后随手取下三爪扳手，以免开车时速度过快飞出伤人；</p>
<p>（4）安装大工件要垫木板。</p>
<p><strong>1.2.2 安装车刀</strong></p>
<p>车刀安装在方刀架上，安装时刀面朝上，刀尖应与工件轴线等高，一般通过安装在尾座套筒上的顶尖的尖端来判断刀尖的高低。若低于工件轴线，可在车道下面放置垫片进行调整，直到刀尖与工件轴线等高为止。</p>
<p>安装车刀时应注意以下三点：</p>
<p>（1）垫片必须放置平整；</p>
<p>（2）车刀伸出长度要合适；</p>
<p>（3）应有合适的副偏角。</p>
<p>在装好车刀和工件后要进行极限位置检查。即将车刀移到极限位置处，用手转动主轴，检查卡盘等刀具或夹具有无碰撞的可能。</p>
<p><strong>1.2.3 切削</strong></p>
<p>切削的步骤应按下列步骤进行：</p>
<p>（1）开车对零点。注意，对零点时必须开车；</p>
<p>（2）延进给反方向退刀；</p>
<p>（3）进切深；</p>
<p>（4）走刀切削；</p>
<p>（5）退刀。</p>
<p>因为刻度盘和丝杠的螺距均有一定误差，往往不能满足精车尺寸精度的要求。在单件小批生产中通常采用试切的方式来保证精度。试切前，先测量工件的现有尺度，然后按以下步骤进行：</p>
<p>（1）开车对零点</p>
<p>（2）延进给反方向退刀；</p>
<p>（3）进切深；</p>
<p>（4）走刀切削2至3毫米；</p>
<p>（5）退刀，并测量尺寸。</p>
<p>其中，（3）至（5）步为一个循环，若测量尺寸合格，则进行：</p>
<p>（6）走刀切削整个表面</p>
<p>若测量尺寸不合格，重复（3）至（5）步，直到尺寸合格。</p>
<p>车外圆试切调整切身时，当调整方向与进切深方向相同时，可直接顺时针摇动横向刻度盘手柄；当调整方向与进切深方向相反时，由于丝杠与螺母间有间隙，绝对不能直接逆时针摇动横向刻度盘手柄，必须先退回半周左右取消丝杠与螺母间间隙，再进行调整。</p>
<p><strong>1.2.4 击中基本表面的切削方法</strong></p>
<p><strong>（1）车端面</strong></p>
<p>车端面的方法主要有右偏刀车端面和弯头刀车端面两种。右偏刀车端面可以从外向中心走刀，也可以从中心向外走刀。弯头刀车端面操作和右偏刀车端面方式相同。当端面的中心为实心时，两种方法都需要使刀尖与工件轴线等高，只有这样刀尖才能车到工件中心。</p>
<p><strong>（2）车台阶面</strong>    </p>
<p>台阶面分为低台阶面（台阶高度低于5毫米）和高台阶面（台阶高度高于5毫米）。车低台阶面时主切削面最好与工件轴线垂直，高台阶面要分多次走刀车出，车刀主切削刃应略微倾斜。</p>
<p><strong>（3）镗孔</strong></p>
<p>镗孔常见的有镗通孔和镗盲孔两种方式。需要注意的是，镗刀杆刚性较差，全身长度尽可能短些；刀尖可略高于工件中心；镗刀装好后要用手缓慢摇入毛坯孔中，看刀杆四周是否与孔壁相碰，并做出记号。</p>
<p><strong>（4）切槽和切断</strong></p>
<p>切槽和切断没有本质区别，切的浅的叫切槽，切到中心的叫切断。切断刀既可切断也可切槽。</p>
<h2 id="特型表面车削加工"><a href="#特型表面车削加工" class="headerlink" title="特型表面车削加工"></a>特型表面车削加工</h2><p><strong>1.3.1 车锥面</strong></p>
<p>锥面有内锥面（锥孔）和外锥面（椎体）之分，内外锥面配合紧密，拆卸方便，多次拆卸后仍能保持准确的对中性。因此，锥面广泛用于要求对中准确和需要经常拆卸的配合件上。</p>
<p><strong>（1）标准圆锥的型号和应用</strong></p>
<p>常用的标准圆锥有莫氏圆锥、米制圆锥和专用圆锥三种。莫氏圆锥在机械制造中最为常用。莫氏圆锥分为0、1、2、3、4、5、6共七个号，0号最小，6号最大，各号的锥度不相等，但相差不大。米制圆锥有4、6、80、100、120、140、160、200共八个号，其号数值表示圆锥大端直径，各号的锥度相同。专用圆锥用于一些特定的场景，如铣床主轴锥孔、圆推销等。</p>
<p><strong>（2）车锥面的方法</strong></p>
<p>车锥面的方法有小滑板转位法、尾座偏移法、靠模法和宽刀法四种。尾座偏移法主要用于单件和成批生产中加工轴类零件上较长的外锥面，表面粗糙度值可达。这种方法不能车削内锥面。靠模法主要用于成批和大量生产中加工圆锥角较长的内、外锥面。表面粗糙度值可达。宽刀法主要用于成批和大量生产中加工较短的内、外锥面。多在自动机床上使用。表面粗糙度值一般为。</p>
<p><strong>（3）螺纹的用途和分类</strong></p>
<p>螺纹主要用途如下：</p>
<p>①连接：如自来水管螺纹；</p>
<p>②紧固：如方刀架螺钉；</p>
<p>③传动：如车床丝杠和螺母；</p>
<p>④调节：如调节位移量。</p>
<p>螺纹按牙型分可以分为三角形螺纹、矩形螺纹、梯形螺纹等。三角形螺纹主要用于连接件、紧固件，也可用于某些调节装置；矩形螺纹和梯形螺纹主要用于传动，如千斤顶等。螺纹按线数可分为单线螺纹和多线螺纹。单线螺纹圆柱体上只有一根螺旋线。多线螺纹圆柱体上有两条及以上螺旋线。多线螺纹主要用于快进、快退机构或涡轮传动机构中。螺纹按旋向分可以分为右旋螺纹和左旋螺纹。右旋螺纹螺旋线向右边上升，用于大多数场合。左旋螺纹螺旋线向左边上升。左旋螺纹只用于某些特殊部位，如自行车左脚蹬的连接螺纹。</p>
<p><strong>（4）螺纹的三要素</strong></p>
<p>螺纹的三要素包括牙型、中径和螺距。牙型是在通过螺纹轴线的剖面上，螺纹的轮廓形状；中径是一个假想圆柱的直径，该圆柱的母线通过牙型上沟槽和突起宽度相等的地方，用或表示；螺距是相邻两牙在中轴线上对应点间的轴向距离，用P表示。  </p>
<p><strong>（5）螺纹的车削方法</strong></p>
<p>螺纹的车削方法有车削单线右旋三角形螺纹、车削双线右旋三角螺纹、车削单线左旋三角形螺纹、车削双线左旋三角螺纹方法。不同点在于车削双线右旋三角螺纹要换成梯形螺纹车刀、要根据导程调整机床以及要进行分线。车左旋螺纹和右旋螺纹的主要区别是车刀进给方向不同：车右旋螺纹时工件正转、车刀左移；车左旋螺纹时工件正转、车刀右移。</p>
<p><strong>1.3.2 车成形面</strong></p>
<p>主要方法有双手控制法和成型刀具法。</p>
<p><strong>1.3.3 滚花</strong></p>
<p>滚花是利用滚花刀挤压工件，使其表面发生塑性变形而形成花纹的。其中，滚花刀由上滚轮和下滚轮组成，安装在方刀架上。</p>
<h2 id="卧式车床的操作"><a href="#卧式车床的操作" class="headerlink" title="卧式车床的操作"></a>卧式车床的操作</h2><p><strong>1.4.1 车床的型号</strong></p>
<p>以C6136A为例，其中第一个字母C表示车床类，61表示卧式车床，36表示床身上工件最大回转直径的十分之一，A表示车床结构的第一次重要改进。卧式车床主要由主轴箱、进给箱、床身、刀架、尾座、光杆、丝杠、溜板箱和床腿组成。</p>
<p><strong>1.4.2 车床的切削运动</strong></p>
<p>车床的切削运动主要分为主运动和进给运动。主运动提是提供切削可能性的运动，其特点是运动速度最高、消耗动力最大。进给运动是提供继续切削可能性的运动。</p>
<p>此外，车床主轴转速的调整是通过变化三个变速手柄位置进行的。变换手柄位置时应当左推或右拉。开车后如果主轴不旋转，说明变速手柄没有到位，此时应该停车，等机床电动机停止转动后再将手柄扳到正常位置，这时再开车，主轴即可正常旋转。诺顿手柄和倍增手柄配合使用可以得到12种不同的进给量。</p>
<p><strong>1.4.3 车床的适宜加工对象</strong></p>
<p>车床适宜加工回转表面有端平面、内外圆柱面、内外圆锥面、内外螺纹、回转沟槽、回转成形面、滚花面。</p>
<h1 id="焊接（手工电弧焊）"><a href="#焊接（手工电弧焊）" class="headerlink" title="焊接（手工电弧焊）"></a>焊接（手工电弧焊）</h1><h2 id="手工电弧焊及其特点"><a href="#手工电弧焊及其特点" class="headerlink" title="手工电弧焊及其特点"></a>手工电弧焊及其特点</h2><p>手弧焊是手工操作焊条进行焊接的电弧焊方法，又称为焊条电弧焊。焊钳夹持焊条进行传导电流。手弧焊主要特点是焊接灵活，设备简单，但对操作技术要求高，生产率低。手弧焊用于单件、小批生产，短的焊缝及自动焊机不便焊接的焊缝的焊接。</p>
<h2 id="手弧焊机的种类"><a href="#手弧焊机的种类" class="headerlink" title="手弧焊机的种类"></a>手弧焊机的种类</h2><p>手弧焊机是手弧焊的电源，有直流和交流两大类。交流手弧焊机是供电弧焊专用的变压器，叫做弧焊变压器，除了有固定铁芯之外还有可动铁芯。直流弧焊机是供电弧焊专用的整流器，叫做弧焊整流器。</p>
<h2 id="手弧焊机的型号"><a href="#手弧焊机的型号" class="headerlink" title="手弧焊机的型号"></a>手弧焊机的型号</h2><p>手弧焊机的型号共有四部分组成，以BX1-250为例，B表示弧焊变压器（Z则表示弧焊整流器）、X表示下降外特性、1表示系列序号1（动铁芯式）、250表示额定焊接电流250A。</p>
<h2 id="手弧焊机的特点和用法"><a href="#手弧焊机的特点和用法" class="headerlink" title="手弧焊机的特点和用法"></a>手弧焊机的特点和用法</h2><p><strong>2.4.1 手弧焊机的主要特点</strong></p>
<p>交流弧焊机的主要特点是结构简单成本低，但稳弧性较差；直流弧焊机结构和电路复杂，成本高，但是稳弧性好。直流弧焊机的输出端分正极和负极，工件接其正极、焊条接其负极，称为直流正接，反之称为直流反接。</p>
<p><strong>2.4.2 焊条的组成和特点</strong></p>
<p>焊条由焊芯和药皮组成。焊芯既作为电极，传导电流、产生电弧，又作为填充金属，与融化的母材一起形成焊缝。药皮可以促使电弧稳定燃烧；产生气体和熔渣，起机械保护作用，防止空气进入熔池；具有冶金处理作用，可以脱氧、去硫、去氢、渗合金。焊条又分为酸性焊条和碱性焊条。酸性焊条以酸性氧化物为主，碱性焊条以碱性氧化物和氟化钙为主。酸性焊条的稳弧性好，而焊缝性能一般；碱性焊条的稳弧性较差，但焊缝含氢量低，力学性能好，抗裂性能好。</p>
<p><strong>2.4.3 焊条的牌号</strong></p>
<p>焊条的牌号以J422为例，J表示结构钢焊条，42表示焊缝金属抗拉强度等级为420MPa，2表示钛钙型药皮，交流或直流。</p>
<p><strong>2.4.4 焊接工艺参数</strong></p>
<p>焊接工艺参数是焊接时，为了保证焊接质量而选定的各项参数的总称，又称为焊接参数。手工电弧焊的工艺参数主要是焊条直径和焊接电流。</p>
<h2 id="手工电弧焊的安全技术"><a href="#手工电弧焊的安全技术" class="headerlink" title="手工电弧焊的安全技术"></a>手工电弧焊的安全技术</h2><p>使用手弧焊的过程中需要注意以下几点内容：</p>
<p>（1）电焊机机壳要接地；</p>
<p>（2）要穿好工作服、绝缘鞋；</p>
<p>（3）戴电焊手套、面罩；</p>
<p>（4）焊接作业点周围不能有易燃易爆物；</p>
<p>（5）敲渣时注意焊渣不蹦到脸上；</p>
<p>（6）离开工作场地要拉闸；</p>
<p>（7）工作结束时要清理现场、消除火种；</p>
<p>（8）要通风排烟；</p>
<h2 id="焊接缺陷和焊接变形"><a href="#焊接缺陷和焊接变形" class="headerlink" title="焊接缺陷和焊接变形"></a>焊接缺陷和焊接变形</h2><p>焊接缺陷是由于焊接造成在焊接接头中产生的金属不连续、不致密或连接不良的现象。常见的焊接缺陷有裂纹、气孔、夹渣、未焊透和咬边等。焊接后还可能出现焊接变形，包括了角变形、翘曲变形或弯曲变形。</p>
<h1 id="钳工"><a href="#钳工" class="headerlink" title="钳工"></a>钳工</h1><h2 id="机器的装配方法与技术"><a href="#机器的装配方法与技术" class="headerlink" title="机器的装配方法与技术"></a>机器的装配方法与技术</h2><p><strong>3.1.1 联接键的装配方法</strong></p>
<p>联接件的装配方法有螺纹联接、键联接和销联接等形式。绝大多数机器都要用到螺纹联接。螺钉联接要注意以下几点：</p>
<p>（1）螺栓与机体内螺纹的配合应有足够的紧固性，不能松动；</p>
<p>（2）装配时拧紧螺距要适当；</p>
<p>（3）联接后的螺钉、螺栓、轴线要垂直于机体平面；</p>
<p>（4）为了润滑和防止生锈，联接螺纹部分要涂上润滑油脂；</p>
<p>（5）紧固后螺栓头部一般高出螺纹表面1.5个螺距；</p>
<p>（6）联接键处于震动或冲击等工作环境中必须采用防松装置。</p>
<p><strong>3.1.2 键的种类</strong></p>
<p>键主要用于轴和轮内零件的联接，分为松键、紧键和花键三种。普通平键和半圆键属于松键，紧键又称锲键。花键用于紧固齿轮联接和滑动联接。</p>
<p><strong>3.1.3 轴承和传动部件的分类和装配</strong></p>
<p><strong>（1）轴承的分类</strong></p>
<p>轴承分为滑动轴承和滚动轴承两类。滚动轴承又可分为圆柱孔轴承、圆锥孔轴承和推力球轴承三种，又可分为整体式和分离式。</p>
<p><strong>（2）整体圆式轴承（轴套）的装配</strong></p>
<p>装配时测量好尺寸，擦洗干净，去除尖角毛刺，涂上润滑油或润滑脂，一般用铜棒敲入或用压合法将轴套压入座孔中。轴套装入时要防止倾斜，相对位置要对准。装好后常用轴向或径向螺钉防松。</p>
<p><strong>（3）轴承的装配</strong></p>
<p>轴瓦的装配：轴瓦装入座孔后，轴瓦边应高出座孔平面，拧紧轴承盖后使其保持一定的过盈量。</p>
<p>轴承转配的技术要点：</p>
<p>①具有一定的配合性质；</p>
<p>②装配位置准确、位置精度符合要求；</p>
<p>③联接可靠；</p>
<p>④零件干净、涂油；</p>
<p>⑤使用工具得当，用力均匀；</p>
<p>⑥严格检查。</p>
<p><strong>（4）传动装置的注意事项</strong></p>
<p>带传动：不允许带轮端平面倾斜，两轮轴间中心平面要重合，其倾斜角和轴间偏移量不超过规定数据；两轮轴心线要相互平行并位于同一平面内；胶带在带轮上的包角不能太小，而且胶带张紧力要适当。</p>
<p>齿轮传动：齿轮孔与轴的配合要符合规定；装配后不得偏心或歪斜，轮轴中心距要准确，并且有适当尺寸间隙。相互啮合的齿轮在装配后要符合要求，使得轮齿在传动中受力均匀、传动平稳。要注意检查箱体口的相对位置精度和两齿轮的轴向位置精度。</p>
<p>车床装配：先清除结合面毛刺，在床腿上放上调节垫铁，使床身处于水平位置。保证溜板箱开合螺母轴心线与床身导轨的平行度。床身导轨下的齿条要和小齿轮准确啮合，并与标准齿轮进行矫正。丝杠与导轨的平行度要符合要求。安装尾座时，尾座套筒轴线要和主轴中心线重合，同时要满足主轴锥孔中心线和尾座套孔轴线与床身导轨面等高。装配过程要符合工艺要求。</p>
<h2 id="攻丝和套丝"><a href="#攻丝和套丝" class="headerlink" title="攻丝和套丝"></a>攻丝和套丝</h2><p><strong>3.2.1 攻丝及其注意事项</strong></p>
<p>攻丝是指用丝锥在孔中切削出内螺纹的方法。使用工具包括丝锥和丝锥绞手，攻丝前要先加工出螺纹底孔，底孔直径的大小要根据工件的塑性大小和钻孔扩张量考虑。加工钢和塑性较大的材料时，所使用的钻头直径应符合钻头直径=螺纹大径-螺距。加工铸铁等塑性较小的材料，钻头直径=螺纹大径-1.05~1.1螺距。加工不通孔时，钻孔深度要大于所需的螺孔深度。</p>
<p>注意：</p>
<p>（1）工件螺纹底孔的孔口要倒角，通孔螺纹两端倒角；</p>
<p>（2）工件的安装位置要正确，尽量使螺纹孔中心线置于水平线垂直位置；</p>
<p>（3）开始攻丝时要把丝锥放正，然后对其加压力并转动脚手。一般在切入三到四圈螺纹时丝锥位置正确无误，而后只转动脚手而不应再对丝锥加压力；</p>
<p>（4）攻丝时每转把手二分之一圈至一圈时要倒转约二分之一圈；</p>
<p>（5）攻不通孔的螺纹时要注意经常退出丝锥，排除孔中的切线；</p>
<p>（6）攻塑性元件时要加润滑液以减少切削阻力；</p>
<p>（7）丝锥有头攻、二攻之分。攻丝时要注意两根丝锥的使用顺序。</p>
<p><strong>3.2.2 套丝及其注意事项</strong></p>
<p>套丝是指用板牙在圆杆上切削出外螺纹的工艺。使用工具包括板牙和板牙绞手。套丝前要首先确定圆杆直径，其圆杆直径=螺纹大径-0.13螺距。</p>
<p>注意：</p>
<p>（1）套丝前要将圆杆顶端套成15度至20度的斜角；<br>（2）套丝时切削力很大，圆杆要夹持稳固可靠；<br>（3）要保证板牙的端面与圆杆轴线垂直；<br>（4）开始套丝时要施加压力，转动要慢，压力要大，板牙旋入切出的螺旋槽时停止施加压力；<br>（5）在钢料上套丝要加润滑冷却液，以减少磨损。</p>
<h2 id="划线"><a href="#划线" class="headerlink" title="划线"></a>划线</h2><p><strong>3.3.1 划线的基本概念</strong></p>
<p>在毛坯或半成品零件上，用画线工具划出待加工部位的轮廓线或作为基准的点，统称为划线。</p>
<p><strong>3.3.2 划线的作用</strong></p>
<p>划线可以让加工者明确毛坯或半成品加工的位置、合理分配加工余量、及时发现毛坯是否合格；</p>
<p><strong>3.3.3 划线的工具</strong></p>
<p>基准工具（操作平台：放置工件、方箱：将相互垂直的面上的线依次画出来，保证精度要求、微型铁：将工件固定在微型槽中、角铁：画出角铁高度上的尺寸线或界限线）；</p>
<p>直接画线工具（单尖划针和双尖划针；划针盘，圆规分普通圆规和弹簧圆规两种；样冲）；</p>
<p>测量工具：钢直尺、高度尺、游标高度尺、万能量角器。</p>
<p><strong>3.3.4 划线的步骤</strong></p>
<p>划线的步骤主要如下：</p>
<p>（1）熟悉图纸</p>
<p>（2）确定划线基准</p>
<p>（3）清理、检查毛坯、涂料</p>
<p>（4）准备划线工具</p>
<p>（5）划线</p>
<p>（6）校对、检查、打样冲眼</p>
<h2 id="金属的锉削"><a href="#金属的锉削" class="headerlink" title="金属的锉削"></a>金属的锉削</h2><p><strong>3.4.1 锉削的定义和指标</strong></p>
<p>用锉刀对工件进行切削加工，使工件达到切削要求，这种操作方法称为锉削。可对各种表面进行加工，精度最高可达到0.01毫米，表面的粗糙程度可达到Ra0.4，常用于零部件装配和小量零部件加工。</p>
<p><strong>3.4.2 锉刀的种类</strong></p>
<p>锉刀的种类包括整形锉、普通锉（平锉、圆锉、方锉、三角锉、半圆锉）、特种锉等。</p>
<p><strong>3.4.3 锉刀的选择</strong></p>
<p><strong>（1）锉刀粗细选择</strong></p>
<p>主要是根据工件的加工余量大小、加工精度、表面粗糙度的高低和工件材料的性质进行选择；</p>
<p><strong>（2）锉刀断面形状选择</strong></p>
<p>根据加工部位的形状选择；</p>
<p><strong>（3）锉刀长度规格的选择</strong></p>
<p>根据零件加工表面的大小和加工余量的大小选择。</p>
<p><strong>3.4.4 锉刀的使用保养规则</strong></p>
<p>（1）不能用锉刀面锉削毛坯面的硬皮、氧化皮和硬度高的工件，毛坯面的表面可以用锉刀侧刃进行锉削；</p>
<p>（2）锉刀应先用一面，用钝后再用另一面；</p>
<p>（3）在每次使用完锉刀后，应用钢丝刷除掉锉刀中残留的铁屑；</p>
<p>（4）锉刀放置时不能与其他工具重叠堆放；</p>
<p>（5）锉刀不能沾水沾油；</p>
<p>（6）严禁将锉刀作为拆卸工具；</p>
<p>（7）在使用较小锉刀时施力不要过大。</p>
<h2 id="锯削"><a href="#锯削" class="headerlink" title="锯削"></a>锯削</h2><p><strong>3.5.1 锯削的概念和工件</strong></p>
<p>锯削是用锯对材料或工件进行切断或切槽的加工方法称为锯削。</p>
<p>常用的手锯由锯条和锯弓构成。锯条的材料为碳素工具钢或合金钢，长度以安装口的间距表示，其前脚为0度，后角为40度，楔角为50度；锯条上锯路的作用是使锯条在锯削时不会被卡住，减小锯条与锯缝的摩擦力。</p>
<p><strong>3.5.2 锯削前的准备</strong></p>
<p>（1）锯条的选用：主要指锯齿粗细的选择，应根据加工材料的硬度、断面的大小进行选择</p>
<p>（2）锯条的安装：尺尖向前，锯条与锯弓接触面贴近，螺钉拉紧程度适中</p>
<p>（3）工件的安装：锯缝尽量靠近钳口，以免锯削时工件松动或震动导致锯条折断。</p>
<p><strong>3.5.3 锯削要点</strong></p>
<p>（1）卧锯与扶锯：右手手掌向前，五指握住锯弓后部，左手扶住锯弓前端保持平稳。</p>
<p>（2）站立姿势：左脚在前右脚在后，身体与工件呈45度，锯削时略向前倾斜，推压用力。</p>
<p>（3）起锯方式：锯齿靠近近端或远端切入，远端起锯角度约为15度，起锯时左手拇指靠近锯条起导向作用。</p>
<p>（4）锯削过程要点：开始时锯齿要逐步切入工件，手的力气不宜太大，回程时不应施加压力。速度以每分钟20~40次为宜，尽量拉满据。</p>
<p><strong>3.5.4 各种工件锯削方式</strong></p>
<p><strong>（1）锯削棒料</strong></p>
<p>将工件加持在台虎钳中，是锯缝靠近台虎钳，检查锯条松紧。若断面要求平整，则从头至尾沿一个方向锯削；若要求不高，则可在锯削时改变方向，每次使棒料转动一定角度后再锯。非圆棒料起锯时尽量从宽面开始。</p>
<p><strong>（2）锯削管子</strong></p>
<p>厚壁管子锯削方法与锯削棒料大致相同。对薄壁管子的锯削首先将管子放在有微型槽的木垫之间，然后夹在台虎钳中，夹紧时用力不要过大。锯削时逐渐将管子转换一定角度，只锯到管子的内壁处。转动时要将已经锯了的部分向锯削的方向转动。</p>
<p><strong>（3）锯削薄板料</strong></p>
<p>应从宽面锯下。对窄长薄板的锯削首先应将薄板夹在两块厚木板之间，再一起装在台虎钳中，连同木板一起锯削。</p>
<p><strong>（4）深缝锯削</strong></p>
<p>工件必须装正，锯条安装松紧一定要适当，姿势要合适，用力要适当，不断观察锯缝是否按照划线走。</p>
<h1 id="铣工"><a href="#铣工" class="headerlink" title="铣工"></a>铣工</h1><h2 id="介绍与操作"><a href="#介绍与操作" class="headerlink" title="介绍与操作"></a>介绍与操作</h2><p><strong>4.1.1 铣床的型号和组成</strong></p>
<p>铣床型号以X61W为例，X表示铣床类，6表示卧室铣床，1表示升降台铣床，W表示万能铣床。以X5030为例，X表示铣床类，5表示立式铣床，0表示立式升降台铣床，30表示工作台宽度的十分之一。卧式铣床由床身、横梁、主轴、纵向工作台、横向工作台、升降台、转台和底座等组成。立式铣床主要由床身、底座、主轴、纵向工作台、横向工作台和升降台组成。</p>
<p><strong>4.1.2 铣刀的安装</strong></p>
<p>铣刀的安装包括带孔铣刀安装和带柄铣刀安装两种方式。带孔铣刀一般安装在卧式铣床上。将刀轴、锥柄装入主轴锥孔内，用拉杆将拉轴拉紧，先装部分套筒，再装铣刀，再装其余套筒。最后拧上螺母，安装吊架，最后拧紧螺母。</p>
<p><strong>4.1.3 不同类型面的加工方法</strong></p>
<p><strong>（1）铣削水平面</strong></p>
<p>启动机床后，先摇动纵向手轮，使工件处于铣刀下方，然后顺时针摇动垂向手柄，使工作台带动工件上升，直到工件与铣刀接触为止。逆时针摇动纵向手轮，使工件从铣刀下方纵向退出，然后升高工件，再使工作台纵向自动进给。当工件达到规定尺寸后，停止工作台自动进给，使其下降并快速纵向退出，停机，取下工件。</p>
<p><strong>（2）铣削垂直面</strong></p>
<p>一般在卧铣上进行。装夹工件时，使被加工表面伸出侧面钳口，先开车对刀，再让工件纵向退出，使工件横向加切身，再使工件纵向自动进给，铣削整个垂直面。当加工表面达到规定尺寸后，工件横向退刀。</p>
<p><strong>（3）铣削斜面</strong></p>
<p>常在立铣上进行。利用斜垫铁使工件上的斜面处于水平位置，用铣削水平面的方法对其进行加工。</p>
<h2 id="附件与齿形加工"><a href="#附件与齿形加工" class="headerlink" title="附件与齿形加工"></a>附件与齿形加工</h2><p>例如铣床的附件和安装、齿形加工的常用方法和操作。</p>
<p><strong>4.2.1 铣床的附件和安装</strong></p>
<p><strong>（1）平口钳</strong></p>
<p>装夹小型规则的工件，靠安装在底面上的两个定位键块和直槽相配合来定位，使用时用螺栓压紧在工作台上。</p>
<p><strong>（2）压板螺栓</strong></p>
<p>把工件直接压在工作台上。压紧螺栓应靠近加工工件、垫铁的高度应与工件夹紧部位等高、压板应压在工件的实处，不能压在悬空部位、压板要放正，不要偏斜、压板搭压时，螺母下应垫上垫圈，先轻微拧紧所有螺母，再按交叉顺序逐个拧紧，压紧力要合适。此外，用压板螺栓装夹工件要考虑压板的个数、受力点等多种因素。</p>
<p><strong>（3）分度头</strong></p>
<p>用于使工件绕本身轴线进行分度；</p>
<p><strong>（4）回转工作台</strong></p>
<p>用于装载工件；</p>
<p><strong>（5）立铣头和万能铣头</strong></p>
<p>卧式铣床的附件，使卧铣具有立铣的功能，做到一机多用。</p>
<p><strong>4.2.2 加工齿轮齿形的常用方法</strong></p>
<p>加工齿轮齿形的常用方法包括成型法和展成法。其中，成型法具体有铣齿等，展成法具体有插齿、滚齿等。</p>
<p><strong>（1）铣齿</strong></p>
<p>铣齿要在铣床上进行，所用刀具为魔术铣刀。先根据被加工齿数来选择刀号，再将该刀号铣刀安装在铣床上，安装方法与带孔铣刀基本相同，再将齿轮安装在圆柱心轴上并固定在一起。铣削齿轮的关键是正确进行分度。铣完一个齿槽后，将下一个要加工的齿槽部位转到相应的位置上，依次加工出所有齿槽。</p>
<p><strong>（2）插齿</strong></p>
<p>插齿是在插齿机上利用插齿刀完成加工齿形的一种方法。插齿刀实际是具有切削能力的齿轮。</p>
<h1 id="铸造"><a href="#铸造" class="headerlink" title="铸造"></a>铸造</h1><p>铸造是将金属液浇入铸型腔，冷却凝固后获得铸件的生产方法，是机械制造的重要方法之一，主要用于各类机械零件毛坯的生产。</p>
<h2 id="手工造型"><a href="#手工造型" class="headerlink" title="手工造型"></a>手工造型</h2><p><strong>5.1.1 砂型铸造的过程</strong></p>
<p>砂型铸造的过程如图1所示。</p>
<div align="center">
<img src="https://img-blog.csdnimg.cn/20210719203943827.png">
</div>


<center> 图 1 </center>

<p><strong>5.1.2 造型及其主要方法</strong></p>
<p>造型是利用模样和型砂制造砂型的过程。造型的主要方法有手工制造和机器制造，其中手工制造又分为整模造型、分模造型、挖砂造型、活板块造型、三箱造型、活砂造型和刮板造型等等。</p>
<p>整模造型适用于形状简单、且最大截面为某一端面的铸件；分模造型适用于最大截面不在端部，不能或不便于采用整模造型的铸件；挖砂造型的分型面是曲面，其优点有建华模样制造、避免错箱缺陷，缺点有挖砂操作麻烦、造型效率低，适用于最大截面不在端部或不是平面，不能或不必采用分模造型的铸件的单件生产；假箱造型省去了挖砂操作，使造型简化，生产率显著提高。所谓假箱，是参与造型、但是不参与浇筑的一半砂型，适用于小批量生产；成型地板造型适用于成批生产；活块模造型适用于在垂直于分型面的表面上有局部凸起而妨碍出模的铸件的手工造型；三箱造型适用于两端截面尺寸比中间部分的尺寸大，造型时必须从两个平行的分型面出模的铸件；</p>
<p><strong>5.1.3 活砂造型特点</strong></p>
<p>（1）造型过程复杂，要做活砂，要经过两次翻型，两次敞箱和合箱；</p>
<p>（2）活砂位于上、下砂型之间，相当于一个小的中砂型，活砂与上、下砂型之间有两个分型面，用以解决模样出模问题。</p>
<p>活砂造型适用于需要从两个平行的分型面出模，而又不能或不便于采用三箱造型的铸件。</p>
<p><strong>5.1.4 刮板造型</strong></p>
<p>刮板造型可节省较多制模材料和制模工时，但其造型操作非常复杂，效率很低，并且容易产生错箱缺陷，主要用于直径较大（500毫米）的轮形铸件（如飞轮、齿轮、带轮）的单件生产。</p>
<p><strong>5.1.5 手工造型的特点</strong></p>
<p>（1）投资费用低，不需要造型设备，只使用简单的通用造型工具；</p>
<p>（2）适应性好，可以为各种形状和尺寸的铸件铸型；</p>
<p>（3）操作工序多，生产率低，且铸件质量稳定性差；</p>
<p>（4）对工人的操作技术要求高，而且劳动强度较大。</p>
<p>简而言之，手工造型应用于各种形状和尺寸的铸件的单件和小批量生产。</p>
<h2 id="机器造型"><a href="#机器造型" class="headerlink" title="机器造型"></a>机器造型</h2><p><strong>5.2.1 机器造型的概念</strong></p>
<p>机器造型是用机器全部完成或至少完成紧砂操作的造型方法。一般的单台造型机可以完成紧砂和出模操作。</p>
<p><strong>5.2.2 镇压式造型机的组成和原理</strong></p>
<p>镇压式造型机通过震击和压实实现紧砂。镇压式造型机由震击活塞、压实气缸、压实活塞、模板、起模油缸、起模顶杆和砂箱组成。工作时首先加满型砂，打开进气口1，压缩空气进入震击气缸的底部，气体压力将震击活塞顶起。当顶起到一定高度后，进气通道堵死，同时排气通道开通，压缩空气从排气口排出，气缸内压力下降，震击活塞下降，并在惯性力的作用下撞击震击气缸，实现一次震击。与此同时，压缩空气再次加入压缩气缸，循环往复，在震击作用下，型砂得到紧实。该步骤用于紧实砂型的下半部分。接着需要把上半部分压实，打开进气口2，将压缩空气通入压实气缸的底部，气体压力将压实活塞连同砂型一起顶起，在压头的压力作用下将上部的型砂紧实，这样整个砂型的紧实度都能达到要求。最后一步起模，在机器两侧的起模油缸加入压力油，活塞推动四根起模顶杆将砂箱顶起，而模板原地不动。</p>
<p><strong>5.2.3 镇压式造型机的操作步骤</strong></p>
<p>镇压式造型机的操作步骤为：</p>
<p>①装模板；</p>
<p>②放砂箱；</p>
<p>③放直浇口棒（上砂型）；</p>
<p>④填砂；</p>
<p>⑤震击；</p>
<p>⑥压实；</p>
<p>⑦起模；</p>
<p>⑧取下砂型。</p>
<p><strong>5.2.4 机器造型的特点</strong></p>
<p>机器造型主要有以下几个特点：</p>
<p>（1）造型效率高；</p>
<p>（2）操作简单；</p>
<p>（3）铸型质量好；</p>
<p>（4）只能进行两箱整模或分模造型，不能进行挖砂、活块或三箱、假箱造型；</p>
<p>（5）形状复杂的铸件往往需要设置多个内外型芯，以解决出模问题。</p>
<p>机器造型主要应用于中小型铸件的批量生产（二、三百件以上）</p>
<h1 id="安全生产"><a href="#安全生产" class="headerlink" title="安全生产"></a>安全生产</h1><h2 id="车床安全操作"><a href="#车床安全操作" class="headerlink" title="车床安全操作"></a>车床安全操作</h2><p>（1）进入车间要穿好工作服，扎紧袖口，女生需佩戴安全帽，在加工硬脆工件或高速切削时需佩戴眼镜。</p>
<p>（2）必须熟悉车床性能，掌握操控手柄的功用，否则不得动用车床。</p>
<p>（3）车床启动前要检查手柄位置是否正常，手动操作各移动部件有无碰撞或不正常现象，润滑部位要加油润滑，</p>
<p>（4）工件、刀具和夹具都必须装夹牢固，才能进行切削。</p>
<p>（5）车床主轴变速、装夹工件、紧固螺钉、清除切屑或离开车床等都必须停车。</p>
<p>（6）装卸卡盘或装夹重工件时，要有人协助，床面上必须垫木板。</p>
<p>（7）工件转动中，不准手摸工件，或棉丝擦拭工件，不准用手去清除切屑，不准用手强行刹车。</p>
<p>（8）车床运转不正常，有异声或异常现象，轴承温度过高，要立即停车，报告指导师傅。</p>
<p>（9）工作场地保持整洁。刀具、工具、量具要分别放在规定地方。床面上禁止放各种物品。</p>
<p>（10）工作结束后，应擦净车床并在导轨面上加润滑油。关闭车床电门，拉开墙壁上的电闸。</p>
<h2 id="锻造安全操作规程"><a href="#锻造安全操作规程" class="headerlink" title="锻造安全操作规程"></a>锻造安全操作规程</h2><p>（1）实习时要穿好工作服、工作鞋。</p>
<p>（2）工作前必须进行设备及工具检查，当工具开裂及铆钉松动时，不准使用。</p>
<p>（3）操作时要思想集中，掌钳者必须夹牢和放稳工件，打锤者应按掌钳指挥要求操锤，注意控制锤击方向。</p>
<p>（4）握钳时将钳把置于体侧，不要正对腹部。也不要将手放入钳股之间。</p>
<p>（5）锻打时，锻件应放在下抵铁的中央，锻件及垫铁等工具必须放正、放平，以防飞出伤人。</p>
<p>（6）踩踏杆时，脚跟不许悬空，以保证操作的稳定和准确。不锤击时，应随即将脚离开踏杆，以防误踏出事故。</p>
<p>（7）不要用手模或脚踏未冷却透的锻件。需要拿模锻件，则必须以水检验温度后，方可拿取。</p>
<p>（8）不得随意拨动锻压设备的开关和操纵手柄等。严禁用锤头空击下抵铁，也不许锻打过烧或已冷的锻件。</p>
<p>（9）不要站立在容易飞出火星和锻件毛边的地方。</p>
<h2 id="滚齿机安全操作规程"><a href="#滚齿机安全操作规程" class="headerlink" title="滚齿机安全操作规程"></a>滚齿机安全操作规程</h2><p>（1）铣齿轮时，毛坯底面与工作台之间的高度不能低于机床规定高度。</p>
<p>（2）轮坯垫圈的直径，应小于被加工齿轮根圆直径的3毫米。</p>
<p>（3）刀杆、刀杆支架、刀杆垫圈、刀孔装卡时应擦净。装卡铣刀时，要穿入合适的键。</p>
<p>（4）搬动刀架角度时，要注意刀架下滑。</p>
<p>（5）根据被加工齿轮的要求，在吃刀前应对调整部位检查。</p>
<p>（6）铣斜齿轮时，一定要把工件卡牢，以免在铣削中发生转动。不准碰撞刀架，不准拆开走刀丝杠，提升刀架必须退刀。</p>
<p>（7）开快速时，铣刀不准与工件碰撞，退出时距离不得太长，以免刀架与工作台碰撞。</p>
<p>（8）被加工齿轮的模数、直径等，不允许超出机床的技术规范。</p>
<p>（9）挂轮时应切断电源。</p>
<h2 id="焊接安全操作规程"><a href="#焊接安全操作规程" class="headerlink" title="焊接安全操作规程"></a>焊接安全操作规程</h2><p>（1）实习时要穿好工作鞋。电焊操作要戴好面罩和电焊手套等防护用品。</p>
<p>（2）电焊机外壳应接上地线;焊钳手把和导线的绝缘应良好，以防止触电。</p>
<p>（3）焊钳任何时候都不得放在工作台上，以免短路烧坏电焊机。</p>
<p>（4）电焊机或线路发热烫手时，应立即停止工作。</p>
<p>（5）焊后清渣时，注意敲渣方向，以免焊渣烫伤脸目。</p>
<p>（6）氧气瓶不得撞击和高温烘、晒，不得沾上油脂或其它易燃物品。</p>
<p>（7）乙炔发生器或乙炔瓶和氧气瓶附近严禁烟火。</p>
<p>（8）工作前要检查回火防止器的水位，回火时要立即关闭乙炔阀门。</p>
<p>（9）工作场地应通风良好，防止有害气体影响健康。</p>
<p>（10）焊接操作时，周围不能有易燃易爆物品。</p>
<p>（11）操作完毕及下班时，要检查工作场地，交回焊接工具等,并要拉掉电闸。</p>
<h2 id="钳工安全操作规程"><a href="#钳工安全操作规程" class="headerlink" title="钳工安全操作规程"></a>钳工安全操作规程</h2><p><strong>6.5.1 錾切</strong></p>
<p>（1）锤头和锤把要安牢固，没有楔子不准使用。</p>
<p>（2）锤头和扁铲上不得有飞边、毛刺、碎顶等。</p>
<p>（3）锤击时要注意周围环境，根据工作场所情况在工作前放安全网。</p>
<p>（4）锤击时应尽里将锤头和锤把上的油擦净，不得戴手套操作。</p>
<p><strong>6.5.2 锉削</strong></p>
<p>（1）使用锉刀应装上手柄。</p>
<p>（2）锉刀柄不得有裂缝，必须有箍，不得结扎铁丝。</p>
<p>（3）锉刀放置不得伸出工作台外。</p>
<p>（4）不准用锉刀撬、砸、敲打其他物品。</p>
<p>（5）锉刀在工件上不能推拉过端。</p>
<p>（6）不得将坚硬物品放置于锉刀之上。</p>
<p><strong>6.5.3 划线</strong></p>
<p>（1）工件支撑一定要牢固平稳，在支撑过程中要随时加木垫。</p>
<p>（2）大工件翻身调面，必须有起重工具，并加木垫。</p>
<p>（3）平台要保持洁净，搬动时要防止平面划伤，保持平台工作面的精度。</p>
<p><strong>6.5.4 锯割</strong></p>
<p>（1）锯条不宜过松或过紧，以免断裂。</p>
<p>（2）锯割工件用虎钳夹持时，锯切位置不宜伸出过长。</p>
<p>（3）工件锯割开始或将要切断时，须轻轻推锯，以防滑出或使锯条断裂。</p>
<p>（4）锯切工件一定要夹紧，锯切钢件时要润滑。</p>
<p><strong>6.5.5 攻丝套丝</strong></p>
<p>（1）工作前必须检查扳牙、扳牙架、丝锥和丝杠是否有损坏裂纹。</p>
<p>（2）使用丝锥和扳牙时，一定要垂直加工工件，用力均匀，不要过猛，以防工具及工件损坏，攻不透孔螺丝更要特别小心。</p>
<h2 id="铸造安全操作规程"><a href="#铸造安全操作规程" class="headerlink" title="铸造安全操作规程"></a>铸造安全操作规程</h2><p><strong>6.6.1 造型</strong></p>
<p>（1）工作场地必须保持整洁。操作人员穿戴好劳动保护品。</p>
<p>（2）造型时注意压勺、通气针等物刺伤人，卧模型和用手塞砂子时注意铁刺和铁钉。</p>
<p>（3）抹箱时砂子应过筛，以免有杂物伤人。</p>
<p>（4）扣箱和翻箱时，动作要协调一致。</p>
<p>（5）不得在砂箱悬挂的情况下修型。</p>
<p>（6）使用手提灯时，应注意检查灯头、灯线是否漏电。</p>
<p><strong>6.6.2 化铁炉</strong></p>
<p>（1）炉上操作人员一定要穿戴劳动保护品。</p>
<p>（2）场地保持整洁。做好开炉前的准备工作，并检查设备完好情况。</p>
<p>（3）上料不得太满，上料时炉子附近不得有人停留。严禁潮湿及易爆物进入炉内。</p>
<p>（4）化铁炉附近不得有积水。打炉时附近不得站人。</p>
<p>（5）使用工具不得乱扔。打锤时不准带手套。</p>
<p>（6）雨天不准开炉。</p>
<p>（7）看风眼时不准对正风眼。停风时打开风眼。</p>
<p><strong>6.6.3 浇注</strong></p>
<p>（1）工作前要穿戴劳动保护品。</p>
<p>（2）开炉前要做好—切准备工作，铁水包要烘干。运铁水车要检修完好、道路要畅通、车间内要整洁。</p>
<p>（3）为保证产品质量，一定要坚持“五不浇”的原则:即没埋箱(包抹箱)不浇，没压箱不浇，没打渣不浇，温度低不浇，铁水量不够不浇。</p>
<p>（4）浇注前渣勺应预热。</p>
<p>（5）浇注前应准备好堵火窝头，跑火时严禁用手堵铁水。</p>
<p>（6）开天车人员应服从浇注人员指挥。拾包浇注时应协调一致。</p>
<p>（7）浇注时要引气，不能将头部对着冒口。</p>
<p>（8）铁水放花时，浇注人员要坚守岗位，不得慌乱。</p>
<p>（9）浇注后剩余的铁水，一定要倒在干燥合适的地方。</p>
<h2 id="铣床安全操作规程"><a href="#铣床安全操作规程" class="headerlink" title="铣床安全操作规程"></a>铣床安全操作规程</h2><p>（1）安装刀杆、支架、垫圈、分度头、虎钳、刀孔等，接触面均应擦干净。</p>
<p>（2）工件毛面不许直接压在工作台面或钳口上，必要时加垫。</p>
<p>（3）更换刀杆、刀盘、立铣头、铣刀时，均应停车。拉杆螺丝松脱后，注意避免砸手或损伤机床。</p>
<p>（4）万能铣垂直进刀时，工件装卡要与工作台有一定的距离。</p>
<p>（5）在进行顺铣时一定要清除丝杠与螺母之间的间隙，防止打坏铣刀。</p>
<p>（6）刀杆垫圈不能做其它垫用，使用前要检查平行度。</p>
<p>（7）开快速时，必须使手轮与转轴脱开，防止手轮转动伤人。</p>
<p>（8）高速铣削时，要防止铁屑伤人，并不准急刹车，防止将轴切断。</p>
<p>（9）铣床的纵向、横向、垂直移动，应与操作手柄指的方向一致，否则不能工作。铣床工作时，纵向、横向，垂直的自动走刀只能选择一个方向，不能随意拆下各方向的安全挡板。</p>
<h1 id="新工艺实习（3D打印）"><a href="#新工艺实习（3D打印）" class="headerlink" title="新工艺实习（3D打印）"></a>新工艺实习（3D打印）</h1><h2 id="3D打印的概念"><a href="#3D打印的概念" class="headerlink" title="3D打印的概念"></a>3D打印的概念</h2><p>　　3D打印(3D<br>printing)是快速成型技术的一种。它是一种以数字模型文件为基础，运用粉末状金属或塑料等可粘合材料，通过逐层打印的方式来构造物体的技术。3D打印通常是采用数字技术材料打印机来实现的。</p>
<h2 id="3D打印的步骤"><a href="#3D打印的步骤" class="headerlink" title="3D打印的步骤"></a>3D打印的步骤</h2><p><strong>（1）建模</strong></p>
<p>　　3D打印的关键在于制造的对象，也就是你所设计的模型。设计模型的过程称为建模。</p>
<p>　　建模最常见的分为两种，一种是手动建模，常用到的软件有3D-MAX，Z-Brush等。另一种方式就是3D扫描，即通过3D扫描仪将所需要的东西扫描下来生成数字文件。</p>
<p><strong>（2）切片</strong></p>
<p>有了模型之后，就要开始切片。切片，相当于将已经建好的3D数字模型转化为3D打印机可识别的行走路径以及耗材挤出量。这一步非常关键。</p>
<p>先将模型加载到软件中，点击模型切片，切片完后，将文件发送给3D打印机。</p>
<p><strong>（3）打印</strong></p>
<p>接下来，就是真正将数字文件转变为真实可触的物体了。这一步，当然少不了最为关键的工具——3D打印机。</p>
<p>找到文件，点击开始打印。屏幕上记录有打印进度，以及打印所需要的时间，耗材总量等。打印机喷头温度开始升高，打印机开始打印。</p>
<p><strong>（4）组装上色</strong></p>
<p>如果是一些比较大规模的模型，比如这个飞船，在打印的时候先将各零件分别打印，最后再用胶水将它们粘贴到一起。最后，再为组装好的模型进行上色。</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>金工实习</category>
      </categories>
      <tags>
        <tag>金工实习</tag>
      </tags>
  </entry>
  <entry>
    <title>流水灯、存储器、外部中断实验</title>
    <url>/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机原理与应用实验-流水灯、存储器、外部中断实验</p>
<span id="more"></span>
<h1 id="1-实验一-流水灯实验"><a href="#1-实验一-流水灯实验" class="headerlink" title="1 实验一 流水灯实验"></a>1 实验一 流水灯实验</h1><h2 id="1-1-实验目的"><a href="#1-1-实验目的" class="headerlink" title="1.1 实验目的"></a>1.1 实验目的</h2><ol>
<li><p>掌握ARM开发工具的使用。</p>
</li>
<li><p>掌握基本IO的使用。</p>
</li>
</ol>
<h2 id="1-2-实验原理及内容"><a href="#1-2-实验原理及内容" class="headerlink" title="1.2 实验原理及内容"></a>1.2 实验原理及内容</h2><ol>
<li><strong>电路结构图</strong></li>
</ol>
<p>实现流水灯的电路结构图如图1所示。以两条红色虚线为界，从左至右第一部分为ARM系统部分，第三部分为外围电路，第二部分是接口部分，需要自己将其连接。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707225257418.png" alt=" "></p>
<center> 图 1 流水灯的电路结构图 </center>


<p>接线方式为：GPIOF_0~GPIOF_7（P12接口）接LED1~LED8（P2接口）。</p>
<ol>
<li><strong>LED电路原理</strong></li>
</ol>
<p>LED灯的驱动原理如图2所示。当发光二极管正向导通时，LED灯点亮。    </p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707225607582.png" alt=" "></p>
<center> 图 2 LED灯正向导通</center>

<p>如图3所示，LED灯与MCU引脚连接，MCU IO额定电流为25mA，例如0603封装红色LED灯额定电流为20mA，已经接近MCU IO的额定电流，可能会损毁器件。因此图1.3微控制器驱动LED灯方案不可取。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707230556740.png" alt=" "></p>
<center> 图 3 微控制器驱动 LED 灯</center>

<p>实际微控制驱动LED灯的电路模型包括：控制器、驱动器和执行器三部分，控制器提供控制信号，再由驱动器驱动执行器，如图4所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707230939893.png" alt=" "></p>
<center> 图 4 LED 灯去驱动电路模型</center>



<p>如图5所示LED灯通过N沟道MOS管驱动，MCU IO输出高电平时MOS管漏极和源极导通LED灯被点亮，反之MCU输出低电平时MOS管漏极和源极截止，LED灯不能被点亮。假设VCC电压3.3V，MOS管导通阻值为零，通过LED灯的电流将远超额定电流出现短路现象，故此方案不可取。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707234219270.png" alt=" "></p>
<center> 图 5 MOS 管驱动 LED 灯电路</center>

<p>如图6所示，LED驱动电路中增加电阻（R），以此保证通过LED灯的电流不超过额定电流，避免损坏器件，故将电阻R称为限流电阻。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707234307889.png" alt=" "></p>
<center> 图 6 限流电阻</center>



<p>如图7所示LED电路原理图，R1位置电阻作为限流电阻，R29位置电阻作为下拉电阻，避免MOS管栅极出现亚稳态。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707234335315.png" alt=" "></p>
<center> 图 7 LED 电路原理图</center>


<ol>
<li><strong>微控制器IO输出控制原理</strong></li>
</ol>
<p>如图8所示，基本结构针对STM32F407有7组IO。分别为GPIOA~GPIOG，每组IO有16个IO口，则有112个IO口。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387143066830.png" alt=" "></p>
<center> 图 8 I/O 端口位控制基本结构</center>



<p>STM32F4的GPIO工作方式有8种，其中4种输入，4种输出，分别为：输入浮空、输入上拉、输入下拉、模拟模式、开漏输出、开漏复用输出、推挽输出、推挽复用输出。</p>
<p>（i）输入方式</p>
<p>浮空即电路既不上拉也不下拉，直接通过施密特触发器送到输入数据寄存器再送入到CPU；上拉或下拉方式间接通过上拉或下拉电阻后再通过施密特触发器送到输入数据寄存器最后送入到CPU；模拟方式是关闭施密特触发器后信号直接通过模拟通道至片上外设。</p>
<p>（ii）输出方式</p>
<p>开漏输出指CPU直接或间接地把数据输出到数据寄存器，然后通过输出控制电路来决定最后的输出信号电平。当信号为1时，N—MOS管关闭，IO电平受上下拉电路的控制；当信号为0时，N—MOS管导通，输出下拉低电平。推挽输出方式时，当信号为1时，P-MOS管导通，N-MOS管截止，输出上拉高电平；当信号为0时，P-MOS管截止，N-MOS管导通，输出下拉低电平。开漏复用和推挽复用方式与开漏和推挽的区别是信号来源不同。开漏复用和推挽复用的信号来源是片上的外设模块。</p>
<p>（iii）IO的相关寄存器</p>
<p>每个通用的IO端口都包含4个32位的配置寄存器（GPIOx_MODER、GPIOx_OTYPER、PIOx_OSPEEDR和GPIOx_PUPDR）。2个32位的数据寄存器（GPIOx_IDR和GPIOx_ODR），1个32位置位/复位寄存器（GPIOx_BSRR），1个32位锁定寄存器（GPIOx_LCKR）和2个32位复用功能选择寄存器（GPIOx_AFRL）。</p>
<p>（iv）工作方式配置</p>
<p>端口方式配置寄存器（GPIOx_MODER）用来配置端口的输入、输出、复用和模拟方式；端口输出方式配置寄存器（GPIOx_OTYPER）用来配置端口输出为推挽还是开漏；端口速度配置寄存器（PIOx_OSPEEDR）用来配置端口的信息传输速率；端口上下拉配置寄存器（GPIOx_PUPDR）用来配置端口的无上下拉、上拉、下拉和保留方式。</p>
<p>（v）数据寄存器配置</p>
<p>端口输入数据寄存器（GPIOx_IDR）用到低16位，分别对应该组IO口的一个电平状态。端口输出数据寄存器（GPIOx_ODR）用到低16位，分别对应该组IO口的一个电平状态。置位和复位寄存器（GPIOx_BSRR）与前两个不同的，置位和复位寄存器用到了32位。低16为设置为1时，用于置1对应位。高16位设置为1时，用于置0对应位。而低16位和高16位设置为0时不影响原值。</p>
<h2 id="1-3-完整的硬件接线图和软件程序流程图"><a href="#1-3-完整的硬件接线图和软件程序流程图" class="headerlink" title="1.3 完整的硬件接线图和软件程序流程图"></a>1.3 完整的硬件接线图和软件程序流程图</h2><ol>
<li><strong>硬件接线图</strong></li>
</ol>
<p>实现流水灯的电路结构图如图1所示。以两条红色虚线为界，从左至右第一部分为ARM系统部分，第三部分为外围电路，第二部分是接口部分，需要自己将其连接。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707234455340.png" alt=" "></p>
<center> 图 9 流水灯的硬件接线图</center>

<p>接线方式为：GPIOF_0~GPIOF_7（P12接口）接LED1~LED8（P2接口）。</p>
<ol>
<li><strong>软件程序流程图</strong></li>
</ol>
<p>实现流水灯的软件流程图如图10所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387142237627.png" alt=" "></p>
<center> 图 10 流水灯的软件流程图</center>


<h2 id="1-4-流水灯源程序代码"><a href="#1-4-流水灯源程序代码" class="headerlink" title="1.4 流水灯源程序代码"></a>1.4 流水灯源程序代码</h2><ol>
<li><strong>main.c</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************************************************* </span></span><br><span class="line"><span class="comment">实验名称：LED流水灯 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">硬件模块：计算机原理应用试验箱 </span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">硬件接线：P12~P2 </span></span><br><span class="line"><span class="comment">           </span></span><br><span class="line"><span class="comment">实验现象：通过数据移位操作，LED1~LED8实现流水灯效果 </span></span><br><span class="line"><span class="comment">**************************************************************/</span>  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">uint8_t</span>  cont = <span class="number">128</span>;  </span><br><span class="line">    <span class="keyword">uint16_t</span> led_data = <span class="number">0</span>;  </span><br><span class="line">    GPIO_InitTypeDef   GPIO_InitStructure;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//  开启GPIO时钟  </span></span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);     </span><br><span class="line">  </span><br><span class="line">    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;  </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出模式  </span></span><br><span class="line">    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;          </span><br><span class="line">    <span class="comment">// 设置推挽输出  </span></span><br><span class="line">        GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;           </span><br><span class="line">        <span class="comment">// 速率25MHZ  </span></span><br><span class="line">    GPIO_InitStructure.GPIO_Speed = GPIO_Medium_Speed;       </span><br><span class="line">    GPIO_Init(GPIOF, &amp;GPIO_InitStructure);  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    GPIO_Write(GPIOF, <span class="number">0x00FF</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 初始化延时  </span></span><br><span class="line">    Delay_Init();     </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        led_data = <span class="number">128</span>&lt;&lt;cont;           </span><br><span class="line">        GPIO_Write(GPIOF, led_data);   </span><br><span class="line">        Delay_Ms(<span class="number">100</span>);  </span><br><span class="line">        cont++;  </span><br><span class="line">                <span class="comment">// 大于7后清零  </span></span><br><span class="line">        cont &amp;= <span class="number">0x07</span>;    </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-5-流水灯实验结果"><a href="#1-5-流水灯实验结果" class="headerlink" title="1.5 流水灯实验结果"></a>1.5 流水灯实验结果</h2><p>流水灯实验结果如图11所示，实验现象表示为LED1~LED8依次被点亮。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387141714525.png" alt=" "></p>
<center> 图 11 流水灯实验结果</center>



<h1 id="2-实验二-双端口存储器实验"><a href="#2-实验二-双端口存储器实验" class="headerlink" title="2 实验二 双端口存储器实验"></a>2 实验二 双端口存储器实验</h1><h2 id="2-1-实验目的"><a href="#2-1-实验目的" class="headerlink" title="2.1 实验目的"></a>2.1 实验目的</h2><p>（1）熟练掌握GPIO输入输出操作。</p>
<p>（2）掌握存储器原理及应用。</p>
<p>（3）学会根据时序图编写程序。</p>
<h2 id="2-2-实验原理及内容"><a href="#2-2-实验原理及内容" class="headerlink" title="2.2 实验原理及内容"></a>2.2 实验原理及内容</h2><p><strong>（1）双端口存储器简介</strong></p>
<p>双端口存储器是指同一个存储器具有两组相互独立的读写控制线路,进行并行的独立操作，是一种高速工作的存储器。</p>
<ol>
<li><strong>双端口存储器</strong></li>
</ol>
<p>双端口存储器的结构图如图12所示。其中：</p>
<p>clock:系统时钟50Mhz，用于提供RAM读写数据；</p>
<p>wraddress:写数据地址，将数据写入该地址的RAM存储区内；</p>
<p>data:写入的数据0~7；</p>
<p>wren:写使能高电平有效；</p>
<p>rdadress:读数据地址，将内存中的数据从RAM存储区读出；</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/2021070723490282.png" alt=" "></p>
<center>图 12 双端口存储器结构图</center>



<p>此外，数据写入写出时的波形分别如图13和图14所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707234926504.png" alt=" "></p>
<center>图 13 数据写入时波形</center>

<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/2021070723495429.png" alt=" "></p>
<center>图 14 数据读取时波形</center>

<h2 id="2-3-完整的硬件接线图和程序流程图"><a href="#2-3-完整的硬件接线图和程序流程图" class="headerlink" title="2.3 完整的硬件接线图和程序流程图"></a>2.3 完整的硬件接线图和程序流程图</h2><p><strong>（1）硬件接线图</strong></p>
<p>完整的硬件接线图如图15所示。其中P2接口与P10接口相连，P1接口与P11接口相连，P12接口与P13接口相连。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387140352420.png" alt=" "></p>
<center>图 15 存储器硬件接线图</center>



<p><strong>（2）软件程序流程图</strong></p>
<p>Quartus中的程序流程图如图16所示，Keil中的软件流程图如图17所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387140046918.png" alt=" "></p>
<center>图 16 Quartus中的程序流程图</center>

<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387139831916.png" alt=" "></p>
<center>图 17 Keil中的软件流程图</center>

<h2 id="2-4-存储器源代码程序"><a href="#2-4-存储器源代码程序" class="headerlink" title="2.4 存储器源代码程序"></a>2.4 存储器源代码程序</h2><p><strong>（1）double_ram.v</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="function"><span class="keyword">module</span> <span class="title">double_ram</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">2.</span>	       clock,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">3.</span>	         data,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">4.</span>	         rdaddress,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">5.</span>	         wraddress,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">6.</span>	         wren,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">7.</span>	         q  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">8.</span>	         )</span></span>;  <span class="comment">// 定义参数  </span></span><br><span class="line"><span class="number">9.</span>	        input clock;  </span><br><span class="line"><span class="number">10.</span>	    input [<span class="number">3</span>:<span class="number">0</span>]data;  </span><br><span class="line"><span class="number">11.</span>	    input [<span class="number">2</span>:<span class="number">0</span>]rdaddress;  </span><br><span class="line"><span class="number">12.</span>	    input [<span class="number">2</span>:<span class="number">0</span>]wraddress;  </span><br><span class="line"><span class="number">13.</span>	    input wren;  </span><br><span class="line"><span class="number">14.</span>	    output [<span class="number">3</span>:<span class="number">0</span>]q;  </span><br><span class="line"><span class="number">15.</span>	      </span><br><span class="line"><span class="number">16.</span>	    wire [<span class="number">3</span>:<span class="number">0</span>]n_rdaddress = &#123;<span class="number">1&#x27;b</span>0,rdaddress&#125;;  </span><br><span class="line"><span class="number">17.</span>	    wire [<span class="number">3</span>:<span class="number">0</span>]n_wraddress = &#123;<span class="number">1&#x27;b</span>0,wraddress&#125;;  </span><br><span class="line"><span class="number">18.</span>	      </span><br><span class="line"><span class="number">19.</span>	<span class="comment">// 调用模块  </span></span><br><span class="line"><span class="number">20.</span>	ram2 ram2  </span><br><span class="line"><span class="number">21.</span>	(  </span><br><span class="line"><span class="number">22.</span>	    .clock(clock),  </span><br><span class="line"><span class="number">23.</span>	    .data(data),  </span><br><span class="line"><span class="number">24.</span>	    .rdaddress(n_rdaddress),  </span><br><span class="line"><span class="number">25.</span>	    .wraddress(n_wraddress),  </span><br><span class="line"><span class="number">26.</span>	    .wren(wren),  </span><br><span class="line"><span class="number">27.</span>	    .q(q)  </span><br><span class="line"><span class="number">28.</span>	);  </span><br><span class="line"><span class="number">29.</span>	endmodule</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>（2）ram.2v</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="comment">// megafunction wizard: %RAM: 2-PORT%  </span></span><br><span class="line"><span class="number">2.</span>	<span class="comment">// GENERATION: STANDARD  </span></span><br><span class="line"><span class="number">3.</span>	<span class="comment">// VERSION: WM1.0  </span></span><br><span class="line"><span class="number">4.</span>	<span class="comment">// MODULE: altsyncram   </span></span><br><span class="line"><span class="number">5.</span>	  </span><br><span class="line"><span class="number">6.</span>	<span class="comment">// ============================================================  </span></span><br><span class="line"><span class="number">7.</span>	<span class="comment">// File Name: ram2.v  </span></span><br><span class="line"><span class="number">8.</span>	<span class="comment">// Megafunction Name(s):  </span></span><br><span class="line"><span class="number">9.</span>	<span class="comment">//          altsyncram  </span></span><br><span class="line"><span class="number">10.</span>	<span class="comment">//  </span></span><br><span class="line"><span class="number">11.</span>	<span class="comment">// Simulation Library Files(s):  </span></span><br><span class="line"><span class="number">12.</span>	<span class="comment">//          altera_mf  </span></span><br><span class="line"><span class="number">13.</span>	<span class="comment">// ============================================================  </span></span><br><span class="line"><span class="number">14.</span>	<span class="comment">// ************************************************************  </span></span><br><span class="line"><span class="number">15.</span>	<span class="comment">// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!  </span></span><br><span class="line"><span class="number">16.</span>	<span class="comment">//  </span></span><br><span class="line"><span class="number">17.</span>	<span class="comment">// 13.1.0 Build 162 10/23/2013 SJ Full Version  </span></span><br><span class="line"><span class="number">18.</span>	<span class="comment">// ************************************************************  </span></span><br><span class="line"><span class="number">19.</span>	  </span><br><span class="line"><span class="number">20.</span>	  </span><br><span class="line"><span class="number">21.</span>	<span class="comment">//Copyright (C) 1991-2013 Altera Corporation  </span></span><br><span class="line"><span class="number">22.</span>	<span class="comment">//Your use of Altera Corporation&#x27;s design tools, logic functions   </span></span><br><span class="line"><span class="number">23.</span>	<span class="comment">//and other software and tools, and its AMPP partner logic   </span></span><br><span class="line"><span class="number">24.</span>	<span class="comment">//functions, and any output files from any of the foregoing   </span></span><br><span class="line"><span class="number">25.</span>	<span class="comment">//(including device programming or simulation files), and any   </span></span><br><span class="line"><span class="number">26.</span>	<span class="comment">//associated documentation or information are expressly subject   </span></span><br><span class="line"><span class="number">27.</span>	<span class="comment">//to the terms and conditions of the Altera Program License   </span></span><br><span class="line"><span class="number">28.</span>	<span class="comment">//Subscription Agreement, Altera MegaCore Function License   </span></span><br><span class="line"><span class="number">29.</span>	<span class="comment">//Agreement, or other applicable license agreement, including,   </span></span><br><span class="line"><span class="number">30.</span>	<span class="comment">//without limitation, that your use is for the sole purpose of   </span></span><br><span class="line"><span class="number">31.</span>	<span class="comment">//programming logic devices manufactured by Altera and sold by   </span></span><br><span class="line"><span class="number">32.</span>	<span class="comment">//Altera or its authorized distributors.  Please refer to the   </span></span><br><span class="line"><span class="number">33.</span>	<span class="comment">//applicable agreement for further details.  </span></span><br><span class="line"><span class="number">34.</span>	  </span><br><span class="line"><span class="number">35.</span>	  </span><br><span class="line"><span class="number">36.</span>	<span class="comment">// synopsys translate_off  </span></span><br><span class="line"><span class="number">37.</span>	`timescale <span class="number">1</span> ps / <span class="number">1</span> ps  </span><br><span class="line"><span class="number">38.</span>	<span class="comment">// synopsys translate_on  </span></span><br><span class="line"><span class="number">39.</span>	<span class="function"><span class="keyword">module</span> <span class="title">ram2</span> <span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">40.</span>	    clock,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">41.</span>	    data,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">42.</span>	    rdaddress,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">43.</span>	    wraddress,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">44.</span>	    wren,  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">45.</span>	    q)</span></span>;  </span><br><span class="line"><span class="number">46.</span>	  </span><br><span class="line"><span class="number">47.</span>	    input     clock;  </span><br><span class="line"><span class="number">48.</span>	    input   [<span class="number">3</span>:<span class="number">0</span>]  data;  </span><br><span class="line"><span class="number">49.</span>	    input   [<span class="number">3</span>:<span class="number">0</span>]  rdaddress;  </span><br><span class="line"><span class="number">50.</span>	    input   [<span class="number">3</span>:<span class="number">0</span>]  wraddress;  </span><br><span class="line"><span class="number">51.</span>	    input     wren;  </span><br><span class="line"><span class="number">52.</span>	    output  [<span class="number">3</span>:<span class="number">0</span>]  q;  </span><br><span class="line"><span class="number">53.</span>	`ifndef ALTERA_RESERVED_QIS  </span><br><span class="line"><span class="number">54.</span>	<span class="comment">// synopsys translate_off  </span></span><br><span class="line"><span class="number">55.</span>	`endif  </span><br><span class="line"><span class="number">56.</span>	    tri1      clock;  </span><br><span class="line"><span class="number">57.</span>	    tri0      wren;  </span><br><span class="line"><span class="number">58.</span>	`ifndef ALTERA_RESERVED_QIS  </span><br><span class="line"><span class="number">59.</span>	<span class="comment">// synopsys translate_on  </span></span><br><span class="line"><span class="number">60.</span>	`endif  </span><br><span class="line"><span class="number">61.</span>	  </span><br><span class="line"><span class="number">62.</span>	    wire [<span class="number">3</span>:<span class="number">0</span>] sub_wire0;  </span><br><span class="line"><span class="number">63.</span>	    wire [<span class="number">3</span>:<span class="number">0</span>] q = sub_wire0[<span class="number">3</span>:<span class="number">0</span>];  </span><br><span class="line"><span class="number">64.</span>	  </span><br><span class="line"><span class="number">65.</span>	    <span class="function">altsyncram  <span class="title">altsyncram_component</span> <span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">66.</span>	                .address_a (wraddress),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">67.</span>	                .clock0 (clock),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">68.</span>	                .data_a (data),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">69.</span>	                .wren_a (wren),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">70.</span>	                .address_b (rdaddress),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">71.</span>	                .q_b (sub_wire0),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">72.</span>	                .aclr0 (<span class="number">1&#x27;b</span>0),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">73.</span>	                .aclr1 (<span class="number">1&#x27;b</span>0),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">74.</span>	                .addressstall_a (<span class="number">1&#x27;b</span>0),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">75.</span>	                .addressstall_b (<span class="number">1&#x27;b</span>0),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">76.</span>	                .byteena_a (<span class="number">1&#x27;b</span>1),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">77.</span>	                .byteena_b (<span class="number">1&#x27;b</span>1),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">78.</span>	                .clock1 (<span class="number">1&#x27;b</span>1),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">79.</span>	                .clocken0 (<span class="number">1&#x27;b</span>1),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">80.</span>	                .clocken1 (<span class="number">1&#x27;b</span>1),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">81.</span>	                .clocken2 (<span class="number">1&#x27;b</span>1),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">82.</span>	                .clocken3 (<span class="number">1&#x27;b</span>1),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">83.</span>	                .data_b (&#123;<span class="number">4</span>&#123;<span class="number">1&#x27;b</span>1&#125;&#125;),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">84.</span>	                .eccstatus (),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">85.</span>	                .q_a (),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">86.</span>	                .rden_a (<span class="number">1&#x27;b</span>1),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">87.</span>	                .rden_b (<span class="number">1&#x27;b</span>1),  </span></span></span><br><span class="line"><span class="params"><span class="function"><span class="number">88.</span>	                .wren_b (<span class="number">1&#x27;b</span>0))</span></span>;  </span><br><span class="line"><span class="number">89.</span>	    defparam  </span><br><span class="line"><span class="number">90.</span>	        altsyncram_component.address_aclr_b = <span class="string">&quot;NONE&quot;</span>,  </span><br><span class="line"><span class="number">91.</span>	        altsyncram_component.address_reg_b = <span class="string">&quot;CLOCK0&quot;</span>,  </span><br><span class="line"><span class="number">92.</span>	        altsyncram_component.clock_enable_input_a = <span class="string">&quot;BYPASS&quot;</span>,  </span><br><span class="line"><span class="number">93.</span>	        altsyncram_component.clock_enable_input_b = <span class="string">&quot;BYPASS&quot;</span>,  </span><br><span class="line"><span class="number">94.</span>	        altsyncram_component.clock_enable_output_b = <span class="string">&quot;BYPASS&quot;</span>,  </span><br><span class="line"><span class="number">95.</span>	        altsyncram_component.intended_device_family = <span class="string">&quot;Cyclone IV E&quot;</span>,  </span><br><span class="line"><span class="number">96.</span>	        altsyncram_component.lpm_type = <span class="string">&quot;altsyncram&quot;</span>,  </span><br><span class="line"><span class="number">97.</span>	        altsyncram_component.numwords_a = <span class="number">16</span>,  </span><br><span class="line"><span class="number">98.</span>	        altsyncram_component.numwords_b = <span class="number">16</span>,  </span><br><span class="line"><span class="number">99.</span>	        altsyncram_component.operation_mode = <span class="string">&quot;DUAL_PORT&quot;</span>,  </span><br><span class="line"><span class="number">100.</span>	        altsyncram_component.outdata_aclr_b = <span class="string">&quot;NONE&quot;</span>,  </span><br><span class="line"><span class="number">101.</span>	        altsyncram_component.outdata_reg_b = <span class="string">&quot;CLOCK0&quot;</span>,  </span><br><span class="line"><span class="number">102.</span>	        altsyncram_component.power_up_uninitialized = <span class="string">&quot;FALSE&quot;</span>,  </span><br><span class="line"><span class="number">103.</span>	        altsyncram_component.read_during_write_mode_mixed_ports = <span class="string">&quot;DONT_CARE&quot;</span>,  </span><br><span class="line"><span class="number">104.</span>	        altsyncram_component.widthad_a = <span class="number">4</span>,  </span><br><span class="line"><span class="number">105.</span>	        altsyncram_component.widthad_b = <span class="number">4</span>,  </span><br><span class="line"><span class="number">106.</span>	        altsyncram_component.width_a = <span class="number">4</span>,  </span><br><span class="line"><span class="number">107.</span>	        altsyncram_component.width_b = <span class="number">4</span>,  </span><br><span class="line"><span class="number">108.</span>	        altsyncram_component.width_byteena_a = <span class="number">1</span>;  </span><br><span class="line"><span class="number">109.</span>	  </span><br><span class="line"><span class="number">110.</span>	  </span><br><span class="line"><span class="number">111.</span>	endmodule  </span><br><span class="line"><span class="number">112.</span>	  </span><br><span class="line"><span class="number">113.</span>	<span class="comment">// ============================================================  </span></span><br><span class="line"><span class="number">114.</span>	<span class="comment">// CNX file retrieval info  </span></span><br><span class="line"><span class="number">115.</span>	<span class="comment">// ============================================================  </span></span><br><span class="line"><span class="number">116.</span>	<span class="comment">// Retrieval info: PRIVATE: ADDRESSSTALL_A NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">117.</span>	<span class="comment">// Retrieval info: PRIVATE: ADDRESSSTALL_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">118.</span>	<span class="comment">// Retrieval info: PRIVATE: BYTEENA_ACLR_A NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">119.</span>	<span class="comment">// Retrieval info: PRIVATE: BYTEENA_ACLR_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">120.</span>	<span class="comment">// Retrieval info: PRIVATE: BYTE_ENABLE_A NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">121.</span>	<span class="comment">// Retrieval info: PRIVATE: BYTE_ENABLE_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">122.</span>	<span class="comment">// Retrieval info: PRIVATE: BYTE_SIZE NUMERIC &quot;8&quot;  </span></span><br><span class="line"><span class="number">123.</span>	<span class="comment">// Retrieval info: PRIVATE: BlankMemory NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">124.</span>	<span class="comment">// Retrieval info: PRIVATE: CLOCK_ENABLE_INPUT_A NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">125.</span>	<span class="comment">// Retrieval info: PRIVATE: CLOCK_ENABLE_INPUT_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">126.</span>	<span class="comment">// Retrieval info: PRIVATE: CLOCK_ENABLE_OUTPUT_A NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">127.</span>	<span class="comment">// Retrieval info: PRIVATE: CLOCK_ENABLE_OUTPUT_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">128.</span>	<span class="comment">// Retrieval info: PRIVATE: CLRdata NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">129.</span>	<span class="comment">// Retrieval info: PRIVATE: CLRq NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">130.</span>	<span class="comment">// Retrieval info: PRIVATE: CLRrdaddress NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">131.</span>	<span class="comment">// Retrieval info: PRIVATE: CLRrren NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">132.</span>	<span class="comment">// Retrieval info: PRIVATE: CLRwraddress NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">133.</span>	<span class="comment">// Retrieval info: PRIVATE: CLRwren NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">134.</span>	<span class="comment">// Retrieval info: PRIVATE: Clock NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">135.</span>	<span class="comment">// Retrieval info: PRIVATE: Clock_A NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">136.</span>	<span class="comment">// Retrieval info: PRIVATE: Clock_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">137.</span>	<span class="comment">// Retrieval info: PRIVATE: IMPLEMENT_IN_LES NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">138.</span>	<span class="comment">// Retrieval info: PRIVATE: INDATA_ACLR_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">139.</span>	<span class="comment">// Retrieval info: PRIVATE: INDATA_REG_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">140.</span>	<span class="comment">// Retrieval info: PRIVATE: INIT_FILE_LAYOUT STRING &quot;PORT_B&quot;  </span></span><br><span class="line"><span class="number">141.</span>	<span class="comment">// Retrieval info: PRIVATE: INIT_TO_SIM_X NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">142.</span>	<span class="comment">// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING &quot;Cyclone IV E&quot;  </span></span><br><span class="line"><span class="number">143.</span>	<span class="comment">// Retrieval info: PRIVATE: JTAG_ENABLED NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">144.</span>	<span class="comment">// Retrieval info: PRIVATE: JTAG_ID STRING &quot;NONE&quot;  </span></span><br><span class="line"><span class="number">145.</span>	<span class="comment">// Retrieval info: PRIVATE: MAXIMUM_DEPTH NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">146.</span>	<span class="comment">// Retrieval info: PRIVATE: MEMSIZE NUMERIC &quot;64&quot;  </span></span><br><span class="line"><span class="number">147.</span>	<span class="comment">// Retrieval info: PRIVATE: MEM_IN_BITS NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">148.</span>	<span class="comment">// Retrieval info: PRIVATE: MIFfilename STRING &quot;&quot;  </span></span><br><span class="line"><span class="number">149.</span>	<span class="comment">// Retrieval info: PRIVATE: OPERATION_MODE NUMERIC &quot;2&quot;  </span></span><br><span class="line"><span class="number">150.</span>	<span class="comment">// Retrieval info: PRIVATE: OUTDATA_ACLR_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">151.</span>	<span class="comment">// Retrieval info: PRIVATE: OUTDATA_REG_B NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">152.</span>	<span class="comment">// Retrieval info: PRIVATE: RAM_BLOCK_TYPE NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">153.</span>	<span class="comment">// Retrieval info: PRIVATE: READ_DURING_WRITE_MODE_MIXED_PORTS NUMERIC &quot;2&quot;  </span></span><br><span class="line"><span class="number">154.</span>	<span class="comment">// Retrieval info: PRIVATE: READ_DURING_WRITE_MODE_PORT_A NUMERIC &quot;3&quot;  </span></span><br><span class="line"><span class="number">155.</span>	<span class="comment">// Retrieval info: PRIVATE: READ_DURING_WRITE_MODE_PORT_B NUMERIC &quot;3&quot;  </span></span><br><span class="line"><span class="number">156.</span>	<span class="comment">// Retrieval info: PRIVATE: REGdata NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">157.</span>	<span class="comment">// Retrieval info: PRIVATE: REGq NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">158.</span>	<span class="comment">// Retrieval info: PRIVATE: REGrdaddress NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">159.</span>	<span class="comment">// Retrieval info: PRIVATE: REGrren NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">160.</span>	<span class="comment">// Retrieval info: PRIVATE: REGwraddress NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">161.</span>	<span class="comment">// Retrieval info: PRIVATE: REGwren NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">162.</span>	<span class="comment">// Retrieval info: PRIVATE: SYNTH_WRAPPER_GEN_POSTFIX STRING &quot;0&quot;  </span></span><br><span class="line"><span class="number">163.</span>	<span class="comment">// Retrieval info: PRIVATE: USE_DIFF_CLKEN NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">164.</span>	<span class="comment">// Retrieval info: PRIVATE: UseDPRAM NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">165.</span>	<span class="comment">// Retrieval info: PRIVATE: VarWidth NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">166.</span>	<span class="comment">// Retrieval info: PRIVATE: WIDTH_READ_A NUMERIC &quot;4&quot;  </span></span><br><span class="line"><span class="number">167.</span>	<span class="comment">// Retrieval info: PRIVATE: WIDTH_READ_B NUMERIC &quot;4&quot;  </span></span><br><span class="line"><span class="number">168.</span>	<span class="comment">// Retrieval info: PRIVATE: WIDTH_WRITE_A NUMERIC &quot;4&quot;  </span></span><br><span class="line"><span class="number">169.</span>	<span class="comment">// Retrieval info: PRIVATE: WIDTH_WRITE_B NUMERIC &quot;4&quot;  </span></span><br><span class="line"><span class="number">170.</span>	<span class="comment">// Retrieval info: PRIVATE: WRADDR_ACLR_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">171.</span>	<span class="comment">// Retrieval info: PRIVATE: WRADDR_REG_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">172.</span>	<span class="comment">// Retrieval info: PRIVATE: WRCTRL_ACLR_B NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">173.</span>	<span class="comment">// Retrieval info: PRIVATE: enable NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">174.</span>	<span class="comment">// Retrieval info: PRIVATE: rden NUMERIC &quot;0&quot;  </span></span><br><span class="line"><span class="number">175.</span>	<span class="comment">// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all  </span></span><br><span class="line"><span class="number">176.</span>	<span class="comment">// Retrieval info: CONSTANT: ADDRESS_ACLR_B STRING &quot;NONE&quot;  </span></span><br><span class="line"><span class="number">177.</span>	<span class="comment">// Retrieval info: CONSTANT: ADDRESS_REG_B STRING &quot;CLOCK0&quot;  </span></span><br><span class="line"><span class="number">178.</span>	<span class="comment">// Retrieval info: CONSTANT: CLOCK_ENABLE_INPUT_A STRING &quot;BYPASS&quot;  </span></span><br><span class="line"><span class="number">179.</span>	<span class="comment">// Retrieval info: CONSTANT: CLOCK_ENABLE_INPUT_B STRING &quot;BYPASS&quot;  </span></span><br><span class="line"><span class="number">180.</span>	<span class="comment">// Retrieval info: CONSTANT: CLOCK_ENABLE_OUTPUT_B STRING &quot;BYPASS&quot;  </span></span><br><span class="line"><span class="number">181.</span>	<span class="comment">// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING &quot;Cyclone IV E&quot;  </span></span><br><span class="line"><span class="number">182.</span>	<span class="comment">// Retrieval info: CONSTANT: LPM_TYPE STRING &quot;altsyncram&quot;  </span></span><br><span class="line"><span class="number">183.</span>	<span class="comment">// Retrieval info: CONSTANT: NUMWORDS_A NUMERIC &quot;16&quot;  </span></span><br><span class="line"><span class="number">184.</span>	<span class="comment">// Retrieval info: CONSTANT: NUMWORDS_B NUMERIC &quot;16&quot;  </span></span><br><span class="line"><span class="number">185.</span>	<span class="comment">// Retrieval info: CONSTANT: OPERATION_MODE STRING &quot;DUAL_PORT&quot;  </span></span><br><span class="line"><span class="number">186.</span>	<span class="comment">// Retrieval info: CONSTANT: OUTDATA_ACLR_B STRING &quot;NONE&quot;  </span></span><br><span class="line"><span class="number">187.</span>	<span class="comment">// Retrieval info: CONSTANT: OUTDATA_REG_B STRING &quot;CLOCK0&quot;  </span></span><br><span class="line"><span class="number">188.</span>	<span class="comment">// Retrieval info: CONSTANT: POWER_UP_UNINITIALIZED STRING &quot;FALSE&quot;  </span></span><br><span class="line"><span class="number">189.</span>	<span class="comment">// Retrieval info: CONSTANT: READ_DURING_WRITE_MODE_MIXED_PORTS STRING &quot;DONT_CARE&quot;  </span></span><br><span class="line"><span class="number">190.</span>	<span class="comment">// Retrieval info: CONSTANT: WIDTHAD_A NUMERIC &quot;4&quot;  </span></span><br><span class="line"><span class="number">191.</span>	<span class="comment">// Retrieval info: CONSTANT: WIDTHAD_B NUMERIC &quot;4&quot;  </span></span><br><span class="line"><span class="number">192.</span>	<span class="comment">// Retrieval info: CONSTANT: WIDTH_A NUMERIC &quot;4&quot;  </span></span><br><span class="line"><span class="number">193.</span>	<span class="comment">// Retrieval info: CONSTANT: WIDTH_B NUMERIC &quot;4&quot;  </span></span><br><span class="line"><span class="number">194.</span>	<span class="comment">// Retrieval info: CONSTANT: WIDTH_BYTEENA_A NUMERIC &quot;1&quot;  </span></span><br><span class="line"><span class="number">195.</span>	<span class="comment">// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT VCC &quot;clock&quot;  </span></span><br><span class="line"><span class="number">196.</span>	<span class="comment">// Retrieval info: USED_PORT: data 0 0 4 0 INPUT NODEFVAL &quot;data[3..0]&quot;  </span></span><br><span class="line"><span class="number">197.</span>	<span class="comment">// Retrieval info: USED_PORT: q 0 0 4 0 OUTPUT NODEFVAL &quot;q[3..0]&quot;  </span></span><br><span class="line"><span class="number">198.</span>	<span class="comment">// Retrieval info: USED_PORT: rdaddress 0 0 4 0 INPUT NODEFVAL &quot;rdaddress[3..0]&quot;  </span></span><br><span class="line"><span class="number">199.</span>	<span class="comment">// Retrieval info: USED_PORT: wraddress 0 0 4 0 INPUT NODEFVAL &quot;wraddress[3..0]&quot;  </span></span><br><span class="line"><span class="number">200.</span>	<span class="comment">// Retrieval info: USED_PORT: wren 0 0 0 0 INPUT GND &quot;wren&quot;  </span></span><br><span class="line"><span class="number">201.</span>	<span class="comment">// Retrieval info: CONNECT: @address_a 0 0 4 0 wraddress 0 0 4 0  </span></span><br><span class="line"><span class="number">202.</span>	<span class="comment">// Retrieval info: CONNECT: @address_b 0 0 4 0 rdaddress 0 0 4 0  </span></span><br><span class="line"><span class="number">203.</span>	<span class="comment">// Retrieval info: CONNECT: @clock0 0 0 0 0 clock 0 0 0 0  </span></span><br><span class="line"><span class="number">204.</span>	<span class="comment">// Retrieval info: CONNECT: @data_a 0 0 4 0 data 0 0 4 0  </span></span><br><span class="line"><span class="number">205.</span>	<span class="comment">// Retrieval info: CONNECT: @wren_a 0 0 0 0 wren 0 0 0 0  </span></span><br><span class="line"><span class="number">206.</span>	<span class="comment">// Retrieval info: CONNECT: q 0 0 4 0 @q_b 0 0 4 0  </span></span><br><span class="line"><span class="number">207.</span>	<span class="comment">// Retrieval info: GEN_FILE: TYPE_NORMAL ram2.v TRUE  </span></span><br><span class="line"><span class="number">208.</span>	<span class="comment">// Retrieval info: GEN_FILE: TYPE_NORMAL ram2.inc FALSE  </span></span><br><span class="line"><span class="number">209.</span>	<span class="comment">// Retrieval info: GEN_FILE: TYPE_NORMAL ram2.cmp FALSE  </span></span><br><span class="line"><span class="number">210.</span>	<span class="comment">// Retrieval info: GEN_FILE: TYPE_NORMAL ram2.bsf FALSE  </span></span><br><span class="line"><span class="number">211.</span>	<span class="comment">// Retrieval info: GEN_FILE: TYPE_NORMAL ram2_inst.v FALSE  </span></span><br><span class="line"><span class="number">212.</span>	<span class="comment">// Retrieval info: GEN_FILE: TYPE_NORMAL ram2_bb.v TRUE  </span></span><br><span class="line"><span class="number">213.</span>	<span class="comment">// Retrieval info: LIB_FILE: altera_mf  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>（3）main.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="comment">/******************************************************************* </span></span><br><span class="line"><span class="comment">2.	实验名称：第2次试验.拨档开关输入实验 </span></span><br><span class="line"><span class="comment">3.	 </span></span><br><span class="line"><span class="comment">4.	硬件模块：计算机原理应用实验箱 </span></span><br><span class="line"><span class="comment">5.	 </span></span><br><span class="line"><span class="comment">6.	硬件接线：P12-P13,P11-P1,P10-P2 </span></span><br><span class="line"><span class="comment">7.	实验现象：拨码开关状态映射到LED灯上。 </span></span><br><span class="line"><span class="comment">8.	             </span></span><br><span class="line"><span class="comment">9.	key 1 读 Key 2 写 </span></span><br><span class="line"><span class="comment">10.	********************************************************************/</span>  </span><br><span class="line"><span class="number">11.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span>  </span></span><br><span class="line"><span class="number">12.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span>  </span></span><br><span class="line"><span class="number">13.</span>	  </span><br><span class="line"><span class="number">14.</span>	<span class="comment">/******************************* </span></span><br><span class="line"><span class="comment">15.	功  能：LED端口初始化 </span></span><br><span class="line"><span class="comment">16.	参  数：无 </span></span><br><span class="line"><span class="comment">17.	返回值：无 </span></span><br><span class="line"><span class="comment">18.	*******************************/</span>  </span><br><span class="line"><span class="number">19.</span>	  </span><br><span class="line"><span class="number">20.</span>	  </span><br><span class="line"><span class="number">21.</span>	<span class="meta">#<span class="meta-keyword">define</span> KEY_READ()       GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_8)              <span class="comment">// 上按键检测  </span></span></span><br><span class="line"><span class="number">22.</span>	<span class="meta">#<span class="meta-keyword">define</span> KEY_WRITE()       GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_11)            <span class="comment">// 下按键检测  </span></span></span><br><span class="line"><span class="number">23.</span>	  </span><br><span class="line"><span class="number">24.</span>	  </span><br><span class="line"><span class="number">25.</span>	<span class="meta">#<span class="meta-keyword">define</span> CLK(val)     GPIO_WriteBit(GPIOF, GPIO_Pin_6, (BitAction)val)          <span class="comment">// FPGA 时钟信号  </span></span></span><br><span class="line"><span class="number">26.</span>	<span class="meta">#<span class="meta-keyword">define</span> WREN(val)    GPIO_WriteBit(GPIOF, GPIO_Pin_7, (BitAction)val)          <span class="comment">// FPGA 读写信号  </span></span></span><br><span class="line"><span class="number">27.</span>	  </span><br><span class="line"><span class="number">28.</span>	  </span><br><span class="line"><span class="number">29.</span>	<span class="comment">/******************************* </span></span><br><span class="line"><span class="comment">30.	功  能：LED灯读写数据显示 </span></span><br><span class="line"><span class="comment">31.	参  数：无 </span></span><br><span class="line"><span class="comment">32.	返回值：无 </span></span><br><span class="line"><span class="comment">33.	*******************************/</span>  </span><br><span class="line"><span class="number">34.</span>	  </span><br><span class="line"><span class="number">35.</span>	<span class="function"><span class="keyword">void</span> <span class="title">Led_Init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">36.	</span>&#123;  </span><br><span class="line"><span class="number">37.</span>	    GPIO_InitTypeDef   GPIO_InitStructure;  </span><br><span class="line"><span class="number">38.</span>	  </span><br><span class="line"><span class="number">39.</span>	    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);   <span class="comment">//开启GPIOB的时钟  </span></span><br><span class="line"><span class="number">40.</span>	      </span><br><span class="line"><span class="number">41.</span>	    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 \  </span><br><span class="line"><span class="number">42.</span>	                                | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;  </span><br><span class="line"><span class="number">43.</span>	      </span><br><span class="line"><span class="number">44.</span>	    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;          <span class="comment">//输出模式  </span></span><br><span class="line"><span class="number">45.</span>	    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;         <span class="comment">//推挽输出   </span></span><br><span class="line"><span class="number">46.</span>	    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;      <span class="comment">//速度50MHz  </span></span><br><span class="line"><span class="number">47.</span>	    GPIO_Init(GPIOB, &amp;GPIO_InitStructure);  </span><br><span class="line"><span class="number">48.</span>	    GPIO_Write(GPIOB, <span class="number">0x0000</span>);        </span><br><span class="line"><span class="number">49.</span>	&#125;  </span><br><span class="line"><span class="number">50.</span>	  </span><br><span class="line"><span class="number">51.</span>	<span class="comment">/******************************* </span></span><br><span class="line"><span class="comment">52.	功  能：拨码开关端口初始化 </span></span><br><span class="line"><span class="comment">53.	参  数：无 </span></span><br><span class="line"><span class="comment">54.	返回值：无 </span></span><br><span class="line"><span class="comment">55.	*******************************/</span>  </span><br><span class="line"><span class="number">56.</span>	<span class="function"><span class="keyword">void</span> <span class="title">Sw_Init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">57.	</span>&#123;  </span><br><span class="line"><span class="number">58.</span>	    GPIO_InitTypeDef   GPIO_InitStructure;  </span><br><span class="line"><span class="number">59.</span>	  </span><br><span class="line"><span class="number">60.</span>	    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);   <span class="comment">//开启GPIOC的时钟  </span></span><br><span class="line"><span class="number">61.</span>	  </span><br><span class="line"><span class="number">62.</span>	    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3   </span><br><span class="line"><span class="number">63.</span>	                                | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7  | GPIO_Pin_8 | GPIO_Pin_11;  </span><br><span class="line"><span class="number">64.</span>	  </span><br><span class="line"><span class="number">65.</span>	    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;           <span class="comment">//输入模式  </span></span><br><span class="line"><span class="number">66.</span>	    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;           <span class="comment">//上拉   </span></span><br><span class="line"><span class="number">67.</span>	    GPIO_Init(GPIOC, &amp;GPIO_InitStructure);  </span><br><span class="line"><span class="number">68.</span>	&#125;  </span><br><span class="line"><span class="number">69.</span>	  </span><br><span class="line"><span class="number">70.</span>	<span class="comment">/******************************* </span></span><br><span class="line"><span class="comment">71.	功  能：GPIOF与FPGA连接初始化 </span></span><br><span class="line"><span class="comment">72.	参  数：无 </span></span><br><span class="line"><span class="comment">73.	返回值：无 </span></span><br><span class="line"><span class="comment">74.	*******************************/</span>  </span><br><span class="line"><span class="number">75.</span>	<span class="function"><span class="keyword">void</span> <span class="title">GPIO_FPGA_Init</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">76.	</span>&#123;  </span><br><span class="line"><span class="number">77.</span>	  GPIO_InitTypeDef   GPIO_InitStructure;  </span><br><span class="line"><span class="number">78.</span>	          </span><br><span class="line"><span class="number">79.</span>	    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);   <span class="comment">//开启GPIOF的时钟  </span></span><br><span class="line"><span class="number">80.</span>	      </span><br><span class="line"><span class="number">81.</span>	    GPIO_InitStructure.GPIO_Pin = <span class="number">0x0fff</span>;  </span><br><span class="line"><span class="number">82.</span>	      </span><br><span class="line"><span class="number">83.</span>	    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;        <span class="comment">//输出模式  </span></span><br><span class="line"><span class="number">84.</span>	    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;       <span class="comment">//推挽输出   </span></span><br><span class="line"><span class="number">85.</span>	    GPIO_InitStructure.GPIO_Speed = GPIO_High_Speed;     <span class="comment">//输出速率25MHz   </span></span><br><span class="line"><span class="number">86.</span>	    GPIO_Init(GPIOF, &amp;GPIO_InitStructure);  </span><br><span class="line"><span class="number">87.</span>	      </span><br><span class="line"><span class="number">88.</span>	      </span><br><span class="line"><span class="number">89.</span>	  GPIO_InitStructure.GPIO_Pin = <span class="number">0xf000</span>;  </span><br><span class="line"><span class="number">90.</span>	    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;          <span class="comment">//输出模式  </span></span><br><span class="line"><span class="number">91.</span>	  GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;  </span><br><span class="line"><span class="number">92.</span>	    GPIO_Init(GPIOF, &amp;GPIO_InitStructure);  </span><br><span class="line"><span class="number">93.</span>	&#125;  </span><br><span class="line"><span class="number">94.</span>	  </span><br><span class="line"><span class="number">95.</span>	  </span><br><span class="line"><span class="number">96.</span>	  </span><br><span class="line"><span class="number">97.</span>	  </span><br><span class="line"><span class="number">98.</span>	<span class="comment">/************读取数据***************/</span>  </span><br><span class="line"><span class="number">99.</span>	<span class="function"><span class="keyword">void</span> <span class="title">Read_Data</span><span class="params">(<span class="keyword">uint8_t</span> read_addr, <span class="keyword">uint8_t</span> *read_date)</span>  </span></span><br><span class="line"><span class="function">100.	</span>&#123;  </span><br><span class="line"><span class="number">101.</span>	    <span class="keyword">uint16_t</span> buf = <span class="number">0</span>;                                           <span class="comment">// GPIOF 数据变量  </span></span><br><span class="line"><span class="number">102.</span>	    WREN(<span class="number">0</span>);                                                    <span class="comment">// 读数据  </span></span><br><span class="line"><span class="number">103.</span>	  CLK(<span class="number">0</span>);                                                     <span class="comment">// 时钟信号  </span></span><br><span class="line"><span class="number">104.</span>	    buf =  GPIO_ReadOutputData(GPIOF) &amp; <span class="number">0x00C0</span>;                 <span class="comment">// 保留第6、7位,即时钟信号和读写信号不变  </span></span><br><span class="line"><span class="number">105.</span>	    buf |= read_addr;                                           <span class="comment">// 将读取地址放入GPIOF, 读地址 0-2位  </span></span><br><span class="line"><span class="number">106.</span>	    GPIO_Write(GPIOF, buf);                                     <span class="comment">// GPIOF输出数据  </span></span><br><span class="line"><span class="number">107.</span>	    CLK(<span class="number">1</span>);                                                     <span class="comment">// 时钟周期发送读数据地址  </span></span><br><span class="line"><span class="number">108.</span>	  CLK(<span class="number">0</span>);  </span><br><span class="line"><span class="number">109.</span>	    CLK(<span class="number">1</span>);                                                     <span class="comment">// 时钟信号获取内存数据  </span></span><br><span class="line"><span class="number">110.</span>	    *read_date =  ((GPIO_ReadInputData(GPIOF) &amp; <span class="number">0xf000</span>) &gt;&gt; <span class="number">12</span> );<span class="comment">// 获得FPGA返回数据q, 数据pin在12-15位          </span></span><br><span class="line"><span class="number">111.</span>	    WREN(<span class="number">0</span>);  </span><br><span class="line"><span class="number">112.</span>	&#125;  </span><br><span class="line"><span class="number">113.</span>	  </span><br><span class="line"><span class="number">114.</span>	<span class="comment">/***********写入数据***************/</span>  </span><br><span class="line"><span class="number">115.</span>	<span class="function"><span class="keyword">void</span> <span class="title">Write_Data</span><span class="params">(<span class="keyword">uint8_t</span> write_addr, <span class="keyword">uint8_t</span> write_date)</span>  </span></span><br><span class="line"><span class="function">116.	</span>&#123;  </span><br><span class="line"><span class="number">117.</span>	  <span class="keyword">uint16_t</span> buf = <span class="number">0</span>;                                            <span class="comment">// GPIOF 数据变量  </span></span><br><span class="line"><span class="number">118.</span>	    WREN(<span class="number">1</span>);                                                     <span class="comment">// 写数据  </span></span><br><span class="line"><span class="number">119.</span>	  CLK(<span class="number">0</span>);                                                      <span class="comment">// 时钟信号  </span></span><br><span class="line"><span class="number">120.</span>	    buf =  GPIO_ReadOutputData(GPIOF) &amp; <span class="number">0x00C0</span>;                  <span class="comment">// 保留第6、7位,即时钟信号和读写信号不变  </span></span><br><span class="line"><span class="number">121.</span>	    buf |= ((write_addr &amp; <span class="number">0x7</span>) &lt;&lt; <span class="number">3</span>) | (write_date &lt;&lt; <span class="number">8</span>) ;       <span class="comment">// 将读取地址放入GPIOF, 写地址在3-5位，写数据在8-11位  </span></span><br><span class="line"><span class="number">122.</span>	    GPIO_Write(GPIOF, buf);                                      <span class="comment">// GPIOF输出数据  </span></span><br><span class="line"><span class="number">123.</span>	    CLK(<span class="number">1</span>);  </span><br><span class="line"><span class="number">124.</span>	    WREN(<span class="number">0</span>);  </span><br><span class="line"><span class="number">125.</span>	&#125;  </span><br><span class="line"><span class="number">126.</span>	  </span><br><span class="line"><span class="number">127.</span>	<span class="function"><span class="keyword">void</span> <span class="title">Key_Scan</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">128.	</span>&#123;  </span><br><span class="line"><span class="number">129.</span>	       <span class="keyword">uint8_t</span> gpioc_data;  <span class="comment">// GPIOC数据读取变量  </span></span><br><span class="line"><span class="number">130.</span>	       <span class="keyword">uint8_t</span> read_addr;   <span class="comment">// 拨码开关 0-2    </span></span><br><span class="line"><span class="number">131.</span>	       <span class="keyword">uint8_t</span> write_addr;  <span class="comment">// 写入地址  </span></span><br><span class="line"><span class="number">132.</span>	       <span class="keyword">uint8_t</span> read_date;   <span class="comment">// 拨码开关 4-7  </span></span><br><span class="line"><span class="number">133.</span>	         <span class="keyword">uint8_t</span> write_date;  <span class="comment">// 写入数据  </span></span><br><span class="line"><span class="number">134.</span>	       <span class="keyword">if</span>(KEY_READ() == <span class="number">0</span>)  <span class="comment">// 读按键检测  </span></span><br><span class="line"><span class="number">135.</span>	         &#123;  </span><br><span class="line"><span class="number">136.</span>	              Delay_Ms(<span class="number">5</span>);      <span class="comment">// 防抖  </span></span><br><span class="line"><span class="number">137.</span>	              <span class="keyword">if</span>(KEY_READ() == <span class="number">0</span>)  </span><br><span class="line"><span class="number">138.</span>	                &#123;  </span><br><span class="line"><span class="number">139.</span>	                    <span class="keyword">while</span>(KEY_READ() == <span class="number">0</span>)&#123;&#125;;  </span><br><span class="line"><span class="number">140.</span>	                        gpioc_data = ~(GPIO_ReadInputData(GPIOC) &amp; <span class="number">0x00FF</span>);  <span class="comment">// 获取拨码开关数据,上0，下1  </span></span><br><span class="line"><span class="number">141.</span>	                        read_addr = gpioc_data &amp; <span class="number">0x07</span>;                       <span class="comment">// 获得读地址  </span></span><br><span class="line"><span class="number">142.</span>	                        read_date = (gpioc_data &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>;                <span class="comment">// 读数据，这个没用，调试用  </span></span><br><span class="line"><span class="number">143.</span>	                        Read_Data(read_addr, &amp;read_date);                    <span class="comment">// 传入指针读取FPGA内存数据  </span></span><br><span class="line"><span class="number">144.</span>	                        GPIO_Write(GPIOB, read_date);                        <span class="comment">// 获得的数据从GPIOB发送到LED  </span></span><br><span class="line"><span class="number">145.</span>	                            <span class="comment">//LED1(!LED1_DATA());  </span></span><br><span class="line"><span class="number">146.</span>	                &#125;  </span><br><span class="line"><span class="number">147.</span>	         &#125;  </span><br><span class="line"><span class="number">148.</span>	         <span class="keyword">if</span>(KEY_WRITE() == <span class="number">0</span>)  <span class="comment">// 写按键检测  </span></span><br><span class="line"><span class="number">149.</span>	         &#123;  </span><br><span class="line"><span class="number">150.</span>	              Delay_Ms(<span class="number">5</span>);       <span class="comment">// 防抖  </span></span><br><span class="line"><span class="number">151.</span>	              <span class="keyword">if</span>(KEY_WRITE() == <span class="number">0</span>)  </span><br><span class="line"><span class="number">152.</span>	                &#123;  </span><br><span class="line"><span class="number">153.</span>	                          </span><br><span class="line"><span class="number">154.</span>	                        <span class="keyword">while</span>(KEY_WRITE() == <span class="number">0</span>)&#123;&#125;;  </span><br><span class="line"><span class="number">155.</span>	                        gpioc_data = ~(GPIO_ReadInputData(GPIOC) &amp; <span class="number">0x00FF</span>);  <span class="comment">// 获取拨码开关数据,上0，下1  </span></span><br><span class="line"><span class="number">156.</span>	                        write_addr = gpioc_data &amp; <span class="number">0x07</span>;                      <span class="comment">// 获得写地址  </span></span><br><span class="line"><span class="number">157.</span>	                        write_date = (gpioc_data &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>;               <span class="comment">// 写数据保存  </span></span><br><span class="line"><span class="number">158.</span>	                        Write_Data(write_addr, write_date);                  <span class="comment">// 向FPGA内存写入数据  </span></span><br><span class="line"><span class="number">159.</span>	                        GPIO_Write(GPIOB, write_date);                       <span class="comment">// 把向FPGA写入的数据显示出来  </span></span><br><span class="line"><span class="number">160.</span>	                            <span class="comment">//LED2(!LED2_DATA());  </span></span><br><span class="line"><span class="number">161.</span>	                &#125;  </span><br><span class="line"><span class="number">162.</span>	         &#125;  </span><br><span class="line"><span class="number">163.</span>	 &#125;  </span><br><span class="line"><span class="number">164.</span>	   </span><br><span class="line"><span class="number">165.</span>	   </span><br><span class="line"><span class="number">166.</span>	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">167.	</span>&#123;  </span><br><span class="line"><span class="number">168.</span>	    Delay_Init();  </span><br><span class="line"><span class="number">169.</span>	    Led_Init();      <span class="comment">//LED灯初始化  </span></span><br><span class="line"><span class="number">170.</span>	    Sw_Init();       <span class="comment">//拨码开关初始化 按键初始化  </span></span><br><span class="line"><span class="number">171.</span>	    GPIO_FPGA_Init(); <span class="comment">// GPIOF初始化  </span></span><br><span class="line"><span class="number">172.</span>	    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line"><span class="number">173.</span>	  &#123;  </span><br><span class="line"><span class="number">174.</span>	    Key_Scan();  </span><br><span class="line"><span class="number">175.</span>	    &#125;  </span><br><span class="line"><span class="number">176.</span>	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-5-存储器实验结果"><a href="#2-5-存储器实验结果" class="headerlink" title="2.5 存储器实验结果"></a>2.5 存储器实验结果</h2><p>存储器实验的实验步骤如下所示：</p>
<p>（1） 在地址101写入数据1001，如图18所示；</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707235448662.png" alt=" "></p>
<center>图 18 在地址101写入数据1001</center>



<p>（2）在地址111写入数据0111，如图19所示；</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707235538431.png" alt=" "></p>
<center>图 19 在地址111写入数据0111</center>



<p>（3）在地址101读出数据1001，如图20所示；</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707235601804.png" alt=" "></p>
<center>图 20 在地址101读出数据1001</center>



<p>（4） 在地址111读出数据0111，如图21所示；</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210707235638270.png" alt=" "></p>
<center>图 21 在地址111读出数据0111</center>


<h1 id="3-实验三-外部中断实验"><a href="#3-实验三-外部中断实验" class="headerlink" title="3 实验三 外部中断实验"></a>3 实验三 外部中断实验</h1><h2 id="3-1-实验目的"><a href="#3-1-实验目的" class="headerlink" title="3.1 实验目的"></a>3.1 实验目的</h2><p>（1）掌握 NVIC 中断优先级配置。</p>
<p>（2）学会外部中断配置</p>
<h2 id="3-2-实验原理及内容"><a href="#3-2-实验原理及内容" class="headerlink" title="3.2 实验原理及内容"></a>3.2 实验原理及内容</h2><p><strong>（1）NVIC中断优先级</strong></p>
<p>NVIC 是嵌套向量中断控制器，控制着整个芯片中断相关的功能，它跟内核紧密耦合，是内核里面的一个外设。但是各个芯片厂商在设计芯片的时候会对紧密耦合，是内核里面的一个外设。但是各个芯片厂商在设计芯片的时候会对 Cortex-M4 内核里面的 NVIC 进行裁剪，把不需要的部分去掉，所以说进行裁剪，把不需要的部分去掉，所以说 STM32 的 NVIC 是 Cortex-M4 的 NVIC 的一个子集。</p>
<p>CM4 内核可以支持 256 个中断，包括 16 个内核中断和 240 个外部中断，256 级的可编程中断设置。对于 STM32F4 没有用到 CM4 内核的所有东西，只是用到了一部分，对于 STM32F40 和 41 系列共有 92 个中断，其中有 10 个内核中断和 82 个可屏蔽中断，常用的为 82 个可屏蔽中断。</p>
<p>ISER[8] 中断使能寄存器组，用来使能中断，每一位控制一个中断，由于上面已经说明了控制 82 个可屏蔽的中断，因此利用 ISER[0~2] 这三个 32 位寄存器就够了。以下的几个寄存器同理。</p>
<p>ICER[8]——中断除能寄存器组，用来消除中断。</p>
<p>ISPR[8]——中断挂起控制寄存器组，用来挂起中断。</p>
<p>ICPR[8]——中断解挂控制寄存器组，用来解除挂起。</p>
<p>IABR[8]——中断激活标志寄存器组，对应位如果为 1 则表示中断正在被执行。</p>
<p>IP[240]——中断优先级控制寄存器组，它是用来设置中断优先级的。我们只用到了 IP[0]~IP[81]，每个寄存器只用到了高 4 位，这 4 位又用来设置抢占优先级和响应优先级（有关抢占优先级和响应优先级后面会介绍到），而对于抢占优先级和响应优先级各占多少位则由 AIRCR 寄存器控制，相关设置如表1所示。</p>
<center> 表 1 中断分组</center>

<div class="table-container">
<table>
<thead>
<tr>
<th>组</th>
<th>AIRCR[10:8]</th>
<th>bit[7:4]分配情况</th>
<th>分配结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>111</td>
<td>0：4</td>
<td>0 位抢占优先级，4 位响应优先级</td>
</tr>
<tr>
<td>1</td>
<td>110</td>
<td>1：3</td>
<td>1 位抢占优先级，3 位响应优先级</td>
</tr>
<tr>
<td>2</td>
<td>101</td>
<td>2：2</td>
<td>2 位抢占优先级，2 位响应优先级</td>
</tr>
<tr>
<td>3</td>
<td>100</td>
<td>3：1</td>
<td>3 位抢占优先级，1 位响应优先级</td>
</tr>
<tr>
<td>4</td>
<td>011</td>
<td>4：0</td>
<td>4 位抢占优先级，0 位响应优先级</td>
</tr>
</tbody>
</table>
</div>
<p>关于抢占优先级和响应优先级的理解，可以将它们简单地理解为两个级别，抢占优先级的级别要比响应优先级的级别高，简单地理解为一个为长辈的一个为晚辈的，晚辈要让着长辈，因此抢占优先级的中断可以打断响应优先级的中断，而同级别的中断就得有个先来后到的了，先来的先执行。抢占优先级与相应优先级示例，如表2所示。</p>
<center>表 2 抢占优先级与响应优先级示例</center>

<div class="table-container">
<table>
<thead>
<tr>
<th>中断向量</th>
<th>抢占优先级</th>
<th>响应优先级</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>0</td>
<td>1</td>
<td>抢占优先级相同，响应优先级数值小的优先级高</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>1</td>
<td>2</td>
<td>响应优先级相同，抢占优先级数值小的优先级高</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>1</td>
<td>0</td>
<td>抢占优先级比响应优先级高</td>
</tr>
<tr>
<td>B</td>
<td>0</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>1</td>
<td>1</td>
<td>抢占优先级和响应优先级均相同，则中断向量编号小的先执行</td>
</tr>
<tr>
<td>B</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p><strong>（2）外部中断</strong></p>
<p>外部中断事件控制器（EXTI）管理了控制器的 23 个中断事件线。每个中断事件线都对应有一个边沿检测器，可以实现输入信号的上升沿检测和下降沿的检测。EXTI可以实现对每个中断事件线进行单独配置，可以单独配置为中断或者事件，以及触发事件的属性。</p>
<p>EXTI功能框图如图22所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164387137281210.png" alt=" "></p>
<center>图 22 EXTI 功能框图</center>



<p>图 22 中，在信号线上打一个斜杠并标注 23 字样表示在控制器内部类似的信号线路有 23 个，这与 EXTI 总共有 23 个中断事件线是吻合的。</p>
<p>EXTI 可分为两大部分功能，一个是产生中断，另一个是产生事件。图 22 中，线路 ①②③④⑤ 指示的电路流程是一个产生中断的线路，最终信号流入到 NVIC 控制器内。</p>
<p>编号 1 是输入线，EXTI 控制器有 23 个中断事件输入线，这些输入线可以通过寄存器设置为任意一个 GPIO，也可以是一些外设的事件，输入线一般是存在电平变化的信号。</p>
<p>编号2 是一个边沿检测电路，它会根据上升沿触发选择寄存器(EXTI_RTSR）和下降沿触发选择寄存器 (EXTI_FTSR)对应位的设置来控制信号触发。边沿检测电路以输入线作为信号输入端，如果检测到有边沿跳变就输出有效信号 1 给编号 3 电路，否则输出无效信号 0 。而 EXTI_RTSR 和 EXTI_FTSR<br>两个寄存器可以控制器需要检测哪些类型的电平跳变过程，可以是只有上升沿触发、只有下降沿触发或者上升沿和下降沿都触发。</p>
<p>编号3 电路实际就是一个或门电路，它一个输入来自编号 2 电路，另外一输入来自软件中断事件寄存器 (EXIT_SWIER) 。 EXTI_SWIER 允许我们通过程序控制就可以启动中断 事件线，这在某些地方非常有用。</p>
<p>编号 4 电路是一个与门电路，它一个输入编号 3 电路，另外一个输入来自中断屏蔽寄存器(EXTI_IMR)。与门电路要求输入都为 1 才输出 1，导致的结果如果EXTI_IMR 设置为 0 时，那不管编号 3 电路的输出信号是 1 还是 0，最终编号 4 电路输出的信号都为 0；如果 EXTI_IMR 设置为 1 时，最终编号 4 电路输出的信号才由编号 3 电路的输出信号决定，这样我们可以简单地控制 EXTI_IMR 来实现是否产生中断的目的。编号 4 电路输出的信号会被保存到挂起寄存器(EXTI_PR)内，如果确定编号 4 电路输出为 1 就会把 EXTI_PR 对应位置 1。</p>
<p>编号 5 是将 EXTI_PR 寄存器内容输出到 NVIC 内，从而实现系统中断事件控制。它是一个产生事件的线路，最终输出一个脉冲信号。</p>
<p>编号 6 电路是一个与门，它一个输入编号 3 电路，另外一个输入来自事件屏蔽寄存器(EXTI_EMR)。如果 EXTI_EMR 设置为 0 时，那不管编号 3 电路的输出信号是 1 还是 0，最终编号 6 电路输出的信号都为 0；如果 EXTI_EMR 设置为 1时，最终编号 6 电路输出的信号才由编号 3 电路的输出信号决定，这样我们可以简单的控制、EXTI_EMR 来实现是否产生事件的目的。</p>
<p>编号 7 是一个脉冲发生器电路，当它的输入端，即编号 6 电路的输出端，是一个有效信号 1 时就会产生一个脉冲；如果输入端是无效信号就不会输出脉冲。</p>
<p>编号 8 是一个脉冲信号，就是产生事件的线路最终的产物，这个脉冲信号可以给其他外设电路使用，比如定时器 TIM、模拟数字转换器 ADC 等等。产生中断线路目的是把输入信号输入到 NVIC，进一步会运行中断服务函数，实现功能，这样是软件级的。而产生事件线路目的就是传输一个脉冲信号给其他外设使用，并且是电路级别的信号传输，属于硬件级的。</p>
<p>EXTI 有 23 个中断/事件线，每个 GPIO 都可以被设置为外部中断的中断输入口，这点也是 STM32F4 的强大之处。STM32F407 的中断控制器支持 23 个外部中断/事件请求。每个中断设有状态位，每个中断/事件都有独立的触发和屏蔽设置。</p>
<p>STM32F407 的 23 个外部中断为：</p>
<ul>
<li><p>EXTI 线 0~15：对应外部 IO 口的输入中断。</p>
</li>
<li><p>EXTI 线 16：连接到 PVD 输出。</p>
</li>
<li><p>EXTI 线 17：连接到 RTC 闹钟事件。</p>
</li>
<li><p>EXTI 线 18：连接到 USB OTG FS 唤醒事件。</p>
</li>
<li><p>EXTI 线 19：连接到以太网唤醒事件。</p>
</li>
<li><p>EXTI 线 20：连接到 USB OTG HS(在 FS 中配置)唤醒事件。</p>
</li>
<li><p>EXTI 线 21：连接到 RTC 入侵和时间戳事件。</p>
</li>
<li><p>EXTI 线 22：连接到 RTC 唤醒事件。</p>
</li>
</ul>
<p>STM32F4 供 IO 口使用的中断线只有 16 个，但是 STM32F4 的 IO 口却远远不止 16 个，那么 STM32F4 是怎么把 16 个中断线和 IO 口一一对应起来的呢？于是STM32 就这样设计，GPIO 的管脚 GPIOx.0~GPIOx.15(x=A,B,C,D,E，F,G,H,I)分别对应中断线 0~15。这样每个中断线对应了最多 9 个 IO 口，以线 0 为例：它对应了 GPIOA.0、GPIOB.0、GPIOC.0、GPIOD.0、GPIOE.0、GPIOF.0、GPIOG.0、GPIOH.0、GPIOI.0。而中断线每次只能连接到 1 个 IO 口上，这样就需要通过配置来决定对应的中断线配置到哪个 GPIO 上了。GPIO 跟中断线的映射关系如图23所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210708000216511.png" alt=" "></p>
<center>图 23 GPIO 中断线映射</center>



<h2 id="3-3-完整的硬件接线图和程序流程图"><a href="#3-3-完整的硬件接线图和程序流程图" class="headerlink" title="3.3 完整的硬件接线图和程序流程图"></a>3.3 完整的硬件接线图和程序流程图</h2><p><strong>（1）硬件接线图</strong></p>
<p>完整的硬件接线图如图24所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/20210708000241500.png" alt=" "></p>
<center>图 24 外部中断实验硬件接线图</center>



<p><strong>（2）程序流程图</strong></p>
<p>程序流程图如图25所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438713605706.png" alt=" "></p>
<center>图 25 外部中断实验程序流程图</center>



<h2 id="3-4-外部中断实验源代码程序"><a href="#3-4-外部中断实验源代码程序" class="headerlink" title="3.4 外部中断实验源代码程序"></a>3.4 外部中断实验源代码程序</h2><p><strong>（1）main.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="comment">/******************************************************************** </span></span><br><span class="line"><span class="comment">2.	实验名称：数码管动态扫描实验 </span></span><br><span class="line"><span class="comment">3.	 </span></span><br><span class="line"><span class="comment">4.	硬件模块：计算机原理应用实验箱 </span></span><br><span class="line"><span class="comment">5.	 </span></span><br><span class="line"><span class="comment">6.	硬件接线：ARM P11接口---------数码管 P4接口  </span></span><br><span class="line"><span class="comment">7.	            PC0--------SI </span></span><br><span class="line"><span class="comment">8.	            PC1--------RCK </span></span><br><span class="line"><span class="comment">9.	            PC2--------SCK </span></span><br><span class="line"><span class="comment">10.	            PC3--------A </span></span><br><span class="line"><span class="comment">11.	            PC4--------B </span></span><br><span class="line"><span class="comment">12.	            PC5--------C </span></span><br><span class="line"><span class="comment">13.	         ARM P10接口----------按键 P1接口 </span></span><br><span class="line"><span class="comment">14.	             PB8--------KEY1_N </span></span><br><span class="line"><span class="comment">15.	             PB11-------KEY2_N   </span></span><br><span class="line"><span class="comment">16.	          ARM P12接口-----------LED P2接口 </span></span><br><span class="line"><span class="comment">17.	             PF0~PF7------LED1~LED8       </span></span><br><span class="line"><span class="comment">18.	         注：可用20P排线直连P11、P4接口，直连P10、P1接口，直连P12、P2接口。 </span></span><br><span class="line"><span class="comment">19.	                     </span></span><br><span class="line"><span class="comment">20.	实验现象：数码管上显示数字0~7，可通过按键检测或者外部中断触发流水灯。 </span></span><br><span class="line"><span class="comment">21.	************************************************************************/</span>  </span><br><span class="line"><span class="number">22.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stm32f4xx.h&quot;</span>  </span></span><br><span class="line"><span class="number">23.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span>  </span></span><br><span class="line"><span class="number">24.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;smg.h&quot;</span>  </span></span><br><span class="line"><span class="number">25.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span>  </span></span><br><span class="line"><span class="number">26.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exti.h&quot;</span>  </span></span><br><span class="line"><span class="number">27.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_timer.h&quot;</span>  </span></span><br><span class="line"><span class="number">28.</span>	  </span><br><span class="line"><span class="number">29.</span>	<span class="meta">#<span class="meta-keyword">define</span> KEY  GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11)  </span></span><br><span class="line"><span class="number">30.</span>	   </span><br><span class="line"><span class="number">31.</span>	<span class="function"><span class="keyword">void</span> <span class="title">Key_Hardware_Init</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">32.	</span>&#123;  </span><br><span class="line"><span class="number">33.</span>	    GPIO_InitTypeDef GPIO_TypeDefStructure;  </span><br><span class="line"><span class="number">34.</span>	  </span><br><span class="line"><span class="number">35.</span>	    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);   <span class="comment">//开启中断输入端口时钟  </span></span><br><span class="line"><span class="number">36.</span>	  </span><br><span class="line"><span class="number">37.</span>	    GPIO_TypeDefStructure.GPIO_Pin = GPIO_Pin_11;  </span><br><span class="line"><span class="number">38.</span>	    GPIO_TypeDefStructure.GPIO_Mode = GPIO_Mode_IN;    <span class="comment">//通用输入模式  </span></span><br><span class="line"><span class="number">39.</span>	    GPIO_TypeDefStructure.GPIO_PuPd = GPIO_PuPd_UP;      <span class="comment">//上拉  </span></span><br><span class="line"><span class="number">40.</span>	    GPIO_Init(GPIOB, &amp;GPIO_TypeDefStructure);  </span><br><span class="line"><span class="number">41.</span>	&#125;  </span><br><span class="line"><span class="number">42.</span>	  </span><br><span class="line"><span class="number">43.</span>	  </span><br><span class="line"><span class="number">44.</span>	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">45.	</span>&#123;  </span><br><span class="line"><span class="number">46.</span>	    <span class="keyword">uint8_t</span> i;  </span><br><span class="line"><span class="number">47.</span>	    <span class="keyword">uint16_t</span> cont = <span class="number">0</span>;  </span><br><span class="line"><span class="number">48.</span>	    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  </span><br><span class="line"><span class="number">49.</span>	    Delay_Init();             <span class="comment">//延时初始化  </span></span><br><span class="line"><span class="number">50.</span>	    EXTI_Configure();         <span class="comment">//外部中断初始化   </span></span><br><span class="line"><span class="number">51.</span>	    TIM1_Configure(<span class="number">999</span>, <span class="number">167</span>);  <span class="comment">//定时器初始化  1ms  </span></span><br><span class="line"><span class="number">52.</span>	    SMG_Init();               <span class="comment">//数码管初始化  </span></span><br><span class="line"><span class="number">53.</span>	    LED_Hardware_Init();       <span class="comment">//LED灯初始化   </span></span><br><span class="line"><span class="number">54.</span>	    Key_Hardware_Init();       <span class="comment">//按键检测初始化  </span></span><br><span class="line"><span class="number">55.</span>	       </span><br><span class="line"><span class="number">56.</span>	    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line"><span class="number">57.</span>	    &#123;  </span><br><span class="line"><span class="number">58.</span>	        cont++;  </span><br><span class="line"><span class="number">59.</span>	        <span class="keyword">if</span>(cont &gt;= <span class="number">500</span>)  </span><br><span class="line"><span class="number">60.</span>	        &#123;  </span><br><span class="line"><span class="number">61.</span>	            cont = <span class="number">0</span>;  </span><br><span class="line"><span class="number">62.</span>	            SMG_Sele(i);  <span class="comment">//数码管显示数据  </span></span><br><span class="line"><span class="number">63.</span>	            <span class="keyword">if</span>(i == <span class="number">5</span>)    <span class="comment">//数码管数据显示到第五位时按键检测  </span></span><br><span class="line"><span class="number">64.</span>	            &#123;  </span><br><span class="line"><span class="number">65.</span>	                <span class="keyword">if</span>(!KEY)  </span><br><span class="line"><span class="number">66.</span>	                &#123;  </span><br><span class="line"><span class="number">67.</span>	                    Delay_Ms(<span class="number">10</span>);  </span><br><span class="line"><span class="number">68.</span>	                    <span class="keyword">if</span>(!KEY)  </span><br><span class="line"><span class="number">69.</span>	                    &#123;  </span><br><span class="line"><span class="number">70.</span>	                        <span class="keyword">while</span>(!KEY)&#123;&#125;;  </span><br><span class="line"><span class="number">71.</span>	                        led_flow_flag = <span class="number">1</span>;   <span class="comment">//开启流水灯  </span></span><br><span class="line"><span class="number">72.</span>	                    &#125;  </span><br><span class="line"><span class="number">73.</span>	                &#125;  </span><br><span class="line"><span class="number">74.</span>	            &#125;  </span><br><span class="line"><span class="number">75.</span>	            i++;  </span><br><span class="line"><span class="number">76.</span>	            i &amp;= <span class="number">0x07</span>;  </span><br><span class="line"><span class="number">77.</span>	      </span><br><span class="line"><span class="number">78.</span>	        &#125;  </span><br><span class="line"><span class="number">79.</span>	        Delay_Ms(<span class="number">1</span>);   <span class="comment">//需要明显效果时打开延时   </span></span><br><span class="line"><span class="number">80.</span>	        LED_Flow();     </span><br><span class="line"><span class="number">81.</span>	    &#125;  </span><br><span class="line"><span class="number">82.</span>	&#125;  </span><br><span class="line"><span class="number">83.</span>	  </span><br><span class="line"><span class="number">84.</span>	<span class="comment">//end file  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>（2）led.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span>  </span></span><br><span class="line"><span class="number">2.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span>  </span></span><br><span class="line"><span class="number">3.</span>	  </span><br><span class="line"><span class="number">4.</span>	<span class="keyword">uint8_t</span> led_flow_flag = <span class="number">0</span>;    <span class="comment">//流水灯开启标志  </span></span><br><span class="line"><span class="number">5.</span>	  </span><br><span class="line"><span class="number">6.</span>	<span class="comment">/********************************************************** </span></span><br><span class="line"><span class="comment">7.	*功  能：LED初始化 </span></span><br><span class="line"><span class="comment">8.	*参  数：无 </span></span><br><span class="line"><span class="comment">9.	*返回值：无 </span></span><br><span class="line"><span class="comment">10.	**********************************************************/</span>  </span><br><span class="line"><span class="number">11.</span>	<span class="function"><span class="keyword">void</span> <span class="title">LED_Hardware_Init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">12.	</span>&#123;  </span><br><span class="line"><span class="number">13.</span>	    GPIO_InitTypeDef   GPIO_InitStructure;  </span><br><span class="line"><span class="number">14.</span>	  </span><br><span class="line"><span class="number">15.</span>	    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);   <span class="comment">//开启GPIOF的时钟  </span></span><br><span class="line"><span class="number">16.</span>	  </span><br><span class="line"><span class="number">17.</span>	    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;  </span><br><span class="line"><span class="number">18.</span>	  </span><br><span class="line"><span class="number">19.</span>	    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;          <span class="comment">//输出模式  </span></span><br><span class="line"><span class="number">20.</span>	    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;         <span class="comment">//推挽输出   </span></span><br><span class="line"><span class="number">21.</span>	    GPIO_InitStructure.GPIO_Speed = GPIO_Medium_Speed;     <span class="comment">//速率25MHz  </span></span><br><span class="line"><span class="number">22.</span>	    GPIO_Init(GPIOF, &amp;GPIO_InitStructure);  </span><br><span class="line"><span class="number">23.</span>	  </span><br><span class="line"><span class="number">24.</span>	    GPIO_Write(GPIOF, <span class="number">0x0000</span>);  </span><br><span class="line"><span class="number">25.</span>	&#125;  </span><br><span class="line"><span class="number">26.</span>	  </span><br><span class="line"><span class="number">27.</span>	  </span><br><span class="line"><span class="number">28.</span>	<span class="function"><span class="keyword">void</span> <span class="title">LED_Flow</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">29.	</span>&#123;  </span><br><span class="line"><span class="number">30.</span>	    <span class="keyword">static</span> <span class="keyword">uint8_t</span> cont;  </span><br><span class="line"><span class="number">31.</span>	    <span class="keyword">static</span> <span class="keyword">uint16_t</span> led_data;  </span><br><span class="line"><span class="number">32.</span>	    <span class="keyword">if</span>(led_flow_flag == <span class="number">1</span>)  </span><br><span class="line"><span class="number">33.</span>	    &#123;  </span><br><span class="line"><span class="number">34.</span>	        led_data = <span class="number">1</span>&lt;&lt;cont;           </span><br><span class="line"><span class="number">35.</span>	        LED_SET(led_data);   </span><br><span class="line"><span class="number">36.</span>	        Delay_Ms(<span class="number">100</span>);  </span><br><span class="line"><span class="number">37.</span>	        cont++;  </span><br><span class="line"><span class="number">38.</span>	        cont &amp;= <span class="number">0x07</span>;    <span class="comment">//大于7后清零  </span></span><br><span class="line"><span class="number">39.</span>	    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(led_flow_flag == <span class="number">2</span>)  </span><br><span class="line"><span class="number">40.</span>	    &#123;  </span><br><span class="line"><span class="number">41.</span>	        LED_SET(<span class="number">0xff00</span>);  </span><br><span class="line"><span class="number">42.</span>	        Delay_Ms(<span class="number">300</span>);  </span><br><span class="line"><span class="number">43.</span>	        LED_SET(<span class="number">0x0000</span>);  </span><br><span class="line"><span class="number">44.</span>	        Delay_Ms(<span class="number">300</span>);  </span><br><span class="line"><span class="number">45.</span>	    &#125;  </span><br><span class="line"><span class="number">46.</span>	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>（3）exti.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;exti.h&quot;</span>  </span></span><br><span class="line"><span class="number">2.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span>  </span></span><br><span class="line"><span class="number">3.</span>	  </span><br><span class="line"><span class="number">4.</span>	<span class="comment">/******************************* </span></span><br><span class="line"><span class="comment">5.	功  能：外部中断配置 </span></span><br><span class="line"><span class="comment">6.	参  数：无 </span></span><br><span class="line"><span class="comment">7.	返回值：无 </span></span><br><span class="line"><span class="comment">8.	*******************************/</span>  </span><br><span class="line"><span class="number">9.</span>	<span class="function"><span class="keyword">void</span> <span class="title">EXTI_Configure</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">10.	</span>&#123;  </span><br><span class="line"><span class="number">11.</span>	        GPIO_InitTypeDef GPIO_TypeDefStructure;  </span><br><span class="line"><span class="number">12.</span>	        EXTI_InitTypeDef EXTI_TypeDefStructure;  </span><br><span class="line"><span class="number">13.</span>	        NVIC_InitTypeDef NVIC_TypeDefStructure;  </span><br><span class="line"><span class="number">14.</span>	          </span><br><span class="line"><span class="number">15.</span>	        <span class="comment">//开启中断输入端口时钟  </span></span><br><span class="line"><span class="number">16.</span>	        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);  </span><br><span class="line"><span class="number">17.</span>	          </span><br><span class="line"><span class="number">18.</span>	        <span class="comment">//开启外部中断时钟  </span></span><br><span class="line"><span class="number">19.</span>	        RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);  </span><br><span class="line"><span class="number">20.</span>	          </span><br><span class="line"><span class="number">21.</span>	        GPIO_TypeDefStructure.GPIO_Pin = GPIO_Pin_8;  </span><br><span class="line"><span class="number">22.</span>	        GPIO_TypeDefStructure.GPIO_Mode = GPIO_Mode_IN;     <span class="comment">//通用输入模式  </span></span><br><span class="line"><span class="number">23.</span>	        GPIO_TypeDefStructure.GPIO_PuPd = GPIO_PuPd_UP;       <span class="comment">//上拉  </span></span><br><span class="line"><span class="number">24.</span>	        GPIO_Init(GPIOB, &amp;GPIO_TypeDefStructure);  </span><br><span class="line"><span class="number">25.</span>	  </span><br><span class="line"><span class="number">26.</span>	        <span class="comment">//中断线关联  </span></span><br><span class="line"><span class="number">27.</span>	        SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource8);  </span><br><span class="line"><span class="number">28.</span>	          </span><br><span class="line"><span class="number">29.</span>	        EXTI_TypeDefStructure.EXTI_Line = EXTI_Line8;  </span><br><span class="line"><span class="number">30.</span>	        EXTI_TypeDefStructure.EXTI_Mode = EXTI_Mode_Interrupt;  </span><br><span class="line"><span class="number">31.</span>	        EXTI_TypeDefStructure.EXTI_Trigger = EXTI_Trigger_Falling;<span class="comment">//下降沿触发  </span></span><br><span class="line"><span class="number">32.</span>	        EXTI_TypeDefStructure.EXTI_LineCmd = ENABLE;  </span><br><span class="line"><span class="number">33.</span>	        EXTI_Init(&amp;EXTI_TypeDefStructure);  </span><br><span class="line"><span class="number">34.</span>	          </span><br><span class="line"><span class="number">35.</span>	        <span class="comment">//EXT9_5_IRQn中断向量优先级设置  </span></span><br><span class="line"><span class="number">36.</span>	        NVIC_TypeDefStructure.NVIC_IRQChannel = EXTI9_5_IRQn;  </span><br><span class="line"><span class="number">37.</span>	        NVIC_TypeDefStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;  </span><br><span class="line"><span class="number">38.</span>	        NVIC_TypeDefStructure.NVIC_IRQChannelSubPriority = <span class="number">7</span>;  </span><br><span class="line"><span class="number">39.</span>	        NVIC_TypeDefStructure.NVIC_IRQChannelCmd = ENABLE;  </span><br><span class="line"><span class="number">40.</span>	        NVIC_Init(&amp;NVIC_TypeDefStructure);  </span><br><span class="line"><span class="number">41.</span>	&#125;  </span><br><span class="line"><span class="number">42.</span>	  </span><br><span class="line"><span class="number">43.</span>	  </span><br><span class="line"><span class="number">44.</span>	  </span><br><span class="line"><span class="number">45.</span>	<span class="comment">/******************************* </span></span><br><span class="line"><span class="comment">46.	功  能：外部中断服务函数 </span></span><br><span class="line"><span class="comment">47.	参  数：无 </span></span><br><span class="line"><span class="comment">48.	返回值：无 </span></span><br><span class="line"><span class="comment">49.	*******************************/</span>  </span><br><span class="line"><span class="number">50.</span>	<span class="function"><span class="keyword">void</span> <span class="title">EXTI9_5_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">51.	</span>&#123;  </span><br><span class="line"><span class="number">52.</span>	    <span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line8))  </span><br><span class="line"><span class="number">53.</span>	    &#123;  </span><br><span class="line"><span class="number">54.</span>	        <span class="keyword">if</span>(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_8) == <span class="number">0</span>)  </span><br><span class="line"><span class="number">55.</span>	        &#123;  </span><br><span class="line"><span class="number">56.</span>	            led_flow_flag = <span class="number">2</span>;  </span><br><span class="line"><span class="number">57.</span>	            EXTI_ClearITPendingBit(EXTI_Line8);  </span><br><span class="line"><span class="number">58.</span>	        &#125;  </span><br><span class="line"><span class="number">59.</span>	    &#125;  </span><br><span class="line"><span class="number">60.</span>	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>（4）smg.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;smg.h&quot;</span>  </span></span><br><span class="line"><span class="number">2.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span>  </span></span><br><span class="line"><span class="number">3.</span>	  </span><br><span class="line"><span class="number">4.</span>	<span class="comment">/******************************* </span></span><br><span class="line"><span class="comment">5.	功  能：数码管端口初始化 </span></span><br><span class="line"><span class="comment">6.	参  数：无 </span></span><br><span class="line"><span class="comment">7.	返回值：无 </span></span><br><span class="line"><span class="comment">8.	*******************************/</span>  </span><br><span class="line"><span class="number">9.</span>	<span class="function"><span class="keyword">void</span> <span class="title">SMG_Init</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">10.	</span>&#123;  </span><br><span class="line"><span class="number">11.</span>	    GPIO_InitTypeDef   GPIO_InitStructure;  </span><br><span class="line"><span class="number">12.</span>	  </span><br><span class="line"><span class="number">13.</span>	    RCC_AHB1PeriphClockCmd(SMG_RCC_GPIO, ENABLE);       <span class="comment">//开启GPIOC的时钟  </span></span><br><span class="line"><span class="number">14.</span>	  </span><br><span class="line"><span class="number">15.</span>	    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2   </span><br><span class="line"><span class="number">16.</span>	                                                | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;  </span><br><span class="line"><span class="number">17.</span>	    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;       <span class="comment">//输出模式  </span></span><br><span class="line"><span class="number">18.</span>	    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;      <span class="comment">//推挽输出   </span></span><br><span class="line"><span class="number">19.</span>	    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;   <span class="comment">//速度50MHz  </span></span><br><span class="line"><span class="number">20.</span>	    GPIO_Init(SMG_GPIO, &amp;GPIO_InitStructure);  </span><br><span class="line"><span class="number">21.</span>	&#125;  </span><br><span class="line"><span class="number">22.</span>	  </span><br><span class="line"><span class="number">23.</span>	<span class="comment">/******************************* </span></span><br><span class="line"><span class="comment">24.	功  能：HC595发送数据 </span></span><br><span class="line"><span class="comment">25.	参  数：dat    数据 </span></span><br><span class="line"><span class="comment">26.	返回值：无 </span></span><br><span class="line"><span class="comment">27.	*******************************/</span>  </span><br><span class="line"><span class="number">28.</span>	<span class="function"><span class="keyword">void</span> <span class="title">HC595_Send</span><span class="params">(<span class="keyword">uint8_t</span> dat)</span>  </span></span><br><span class="line"><span class="function">29.	</span>&#123;  </span><br><span class="line"><span class="number">30.</span>	    <span class="keyword">uint8_t</span> dat_buf = <span class="number">0</span>, i;  </span><br><span class="line"><span class="number">31.</span>	    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)  </span><br><span class="line"><span class="number">32.</span>	    &#123;  </span><br><span class="line"><span class="number">33.</span>	        dat_buf = dat &amp; <span class="number">0x80</span>;  </span><br><span class="line"><span class="number">34.</span>	        <span class="keyword">if</span> (dat_buf)      <span class="comment">//输出1bit数据  </span></span><br><span class="line"><span class="number">35.</span>	        &#123;  </span><br><span class="line"><span class="number">36.</span>	          HC595_SI(<span class="number">1</span>);    <span class="comment">//将74HC595串行数据输入引脚设置为高电平  </span></span><br><span class="line"><span class="number">37.</span>	        &#125;  </span><br><span class="line"><span class="number">38.</span>	        <span class="keyword">else</span>  </span><br><span class="line"><span class="number">39.</span>	        &#123;  </span><br><span class="line"><span class="number">40.</span>	          HC595_SI(<span class="number">0</span>);    <span class="comment">//将74HC595串行数据输入引脚设置为低电平  </span></span><br><span class="line"><span class="number">41.</span>	        &#125;  </span><br><span class="line"><span class="number">42.</span>	        HC595_SCK(<span class="number">0</span>);  </span><br><span class="line"><span class="number">43.</span>	        Delay_Us(<span class="number">1</span>);  </span><br><span class="line"><span class="number">44.</span>	        HC595_SCK(<span class="number">1</span>);  </span><br><span class="line"><span class="number">45.</span>	        Delay_Us(<span class="number">1</span>);  </span><br><span class="line"><span class="number">46.</span>	        dat &lt;&lt;= <span class="number">1</span>;  </span><br><span class="line"><span class="number">47.</span>	    &#125;  </span><br><span class="line"><span class="number">48.</span>	    HC595_RCK(<span class="number">0</span>);  </span><br><span class="line"><span class="number">49.</span>	    Delay_Us(<span class="number">3</span>);  </span><br><span class="line"><span class="number">50.</span>	    HC595_RCK(<span class="number">1</span>);  </span><br><span class="line"><span class="number">51.</span>	&#125;  </span><br><span class="line"><span class="number">52.</span>	  </span><br><span class="line"><span class="number">53.</span>	  </span><br><span class="line"><span class="number">54.</span>	  </span><br><span class="line"><span class="number">55.</span>	<span class="comment">//显示的数字数组，依次为0,1,..,7  </span></span><br><span class="line"><span class="number">56.</span>	<span class="keyword">uint8_t</span> digivalue[] = &#123;<span class="number">0x3F</span>, <span class="number">0x06</span>, <span class="number">0x5B</span>, <span class="number">0x4F</span>, <span class="number">0x66</span>, <span class="number">0x6D</span>, <span class="number">0x7D</span>,  <span class="number">0x07</span>&#125;;   </span><br><span class="line"><span class="number">57.</span>	  </span><br><span class="line"><span class="number">58.</span>	<span class="comment">/******************************* </span></span><br><span class="line"><span class="comment">59.	功  能：数码管位段控制 </span></span><br><span class="line"><span class="comment">60.	参  数：index   对应的数码管 </span></span><br><span class="line"><span class="comment">61.	返回值：无 </span></span><br><span class="line"><span class="comment">62.	*******************************/</span>  </span><br><span class="line"><span class="number">63.</span>	<span class="function"><span class="keyword">void</span> <span class="title">SMG_Sele</span><span class="params">(<span class="keyword">uint8_t</span> index)</span>  </span></span><br><span class="line"><span class="function">64.	</span>&#123;  </span><br><span class="line"><span class="number">65.</span>	   HC595_Send(digivalue[index]);       </span><br><span class="line"><span class="number">66.</span>	&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>（5）my_timer.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;my_timer.h&quot;</span>  </span></span><br><span class="line"><span class="number">2.</span>	<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span>  </span></span><br><span class="line"><span class="number">3.</span>	  </span><br><span class="line"><span class="number">4.</span>	<span class="comment">/****************************************** </span></span><br><span class="line"><span class="comment">5.	功  能：定时器1初始化 </span></span><br><span class="line"><span class="comment">6.	参  数：arr  定时器初值  psc  预分频系数 </span></span><br><span class="line"><span class="comment">7.	返回值：无 </span></span><br><span class="line"><span class="comment">8.	******************************************/</span>  </span><br><span class="line"><span class="number">9.</span>	<span class="function"><span class="keyword">void</span> <span class="title">TIM1_Configure</span><span class="params">(<span class="keyword">uint32_t</span> arr,<span class="keyword">uint16_t</span> psc)</span>  </span></span><br><span class="line"><span class="function">10.	</span>&#123;  </span><br><span class="line"><span class="number">11.</span>	    TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;  </span><br><span class="line"><span class="number">12.</span>	    NVIC_InitTypeDef NVIC_InitStructure;  </span><br><span class="line"><span class="number">13.</span>	      </span><br><span class="line"><span class="number">14.</span>	    RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);  </span><br><span class="line"><span class="number">15.</span>	      </span><br><span class="line"><span class="number">16.</span>	    <span class="comment">//定时器初值  </span></span><br><span class="line"><span class="number">17.</span>	    TIM_TimeBaseStructure.TIM_Period = arr;  </span><br><span class="line"><span class="number">18.</span>	    <span class="comment">//预分配系数  </span></span><br><span class="line"><span class="number">19.</span>	    TIM_TimeBaseStructure.TIM_Prescaler = psc;  </span><br><span class="line"><span class="number">20.</span>	    <span class="comment">//向上计数  </span></span><br><span class="line"><span class="number">21.</span>	    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  </span><br><span class="line"><span class="number">22.</span>	    <span class="comment">//时钟分频因子  </span></span><br><span class="line"><span class="number">23.</span>	    TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;  </span><br><span class="line"><span class="number">24.</span>	    <span class="comment">//重复计数次数  </span></span><br><span class="line"><span class="number">25.</span>	    TIM_TimeBaseStructure.TIM_RepetitionCounter = <span class="number">0</span>;  </span><br><span class="line"><span class="number">26.</span>	      </span><br><span class="line"><span class="number">27.</span>	    TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseStructure);  </span><br><span class="line"><span class="number">28.</span>	      </span><br><span class="line"><span class="number">29.</span>	    <span class="comment">//选择中断向量  </span></span><br><span class="line"><span class="number">30.</span>	    NVIC_InitStructure.NVIC_IRQChannel = TIM1_UP_TIM10_IRQn;  </span><br><span class="line"><span class="number">31.</span>	    <span class="comment">//抢占优先级  </span></span><br><span class="line"><span class="number">32.</span>	    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;  </span><br><span class="line"><span class="number">33.</span>	    <span class="comment">//响应优先级  </span></span><br><span class="line"><span class="number">34.</span>	    NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">6</span>;  </span><br><span class="line"><span class="number">35.</span>	    <span class="comment">//使能中断向量  </span></span><br><span class="line"><span class="number">36.</span>	    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;  </span><br><span class="line"><span class="number">37.</span>	    NVIC_Init(&amp;NVIC_InitStructure);  </span><br><span class="line"><span class="number">38.</span>	      </span><br><span class="line"><span class="number">39.</span>	    <span class="comment">//TIM1中断使能  </span></span><br><span class="line"><span class="number">40.</span>	    TIM_ITConfig(TIM1,TIM_IT_Update,ENABLE);  </span><br><span class="line"><span class="number">41.</span>	    <span class="comment">//TIM1使能  </span></span><br><span class="line"><span class="number">42.</span>	    TIM_Cmd(TIM1,ENABLE);  </span><br><span class="line"><span class="number">43.</span>	&#125;  </span><br><span class="line"><span class="number">44.</span>	  </span><br><span class="line"><span class="number">45.</span>	<span class="comment">/****************************************** </span></span><br><span class="line"><span class="comment">46.	功  能：定时器1中断服务函数 </span></span><br><span class="line"><span class="comment">47.	参  数：无 </span></span><br><span class="line"><span class="comment">48.	返回值：无 </span></span><br><span class="line"><span class="comment">49.	******************************************/</span>  </span><br><span class="line"><span class="number">50.</span>	<span class="function"><span class="keyword">void</span> <span class="title">TIM1_UP_TIM10_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function">51.	</span>&#123;  </span><br><span class="line"><span class="number">52.</span>	    <span class="keyword">static</span> <span class="keyword">uint16_t</span> cont_time = <span class="number">0</span>;  </span><br><span class="line"><span class="number">53.</span>	    <span class="keyword">if</span>(TIM_GetITStatus(TIM1, TIM_IT_Update) == SET)  </span><br><span class="line"><span class="number">54.</span>	    &#123;  </span><br><span class="line"><span class="number">55.</span>	       <span class="keyword">if</span>(led_flow_flag)  </span><br><span class="line"><span class="number">56.</span>	       &#123;  </span><br><span class="line"><span class="number">57.</span>	          cont_time++;  </span><br><span class="line"><span class="number">58.</span>	          <span class="keyword">if</span>(cont_time &gt;= <span class="number">5000</span>)  <span class="comment">// 闪烁时间  </span></span><br><span class="line"><span class="number">59.</span>	          &#123;  </span><br><span class="line"><span class="number">60.</span>	             cont_time = <span class="number">0</span>;  </span><br><span class="line"><span class="number">61.</span>	             led_flow_flag = <span class="number">0</span>;  </span><br><span class="line"><span class="number">62.</span>	          &#125;  </span><br><span class="line"><span class="number">63.</span>	       &#125;  </span><br><span class="line"><span class="number">64.</span>	       TIM_ClearITPendingBit(TIM1,TIM_IT_Update);  </span><br><span class="line"><span class="number">65.</span>	    &#125;  </span><br><span class="line"><span class="number">66.</span>	&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-5-外部中断实验结果"><a href="#3-5-外部中断实验结果" class="headerlink" title="3.5 外部中断实验结果"></a>3.5 外部中断实验结果</h2><p>外部中断实验的实验步骤如下所示：</p>
<p>(1) 正常状态下，数码管由0到7不断循环显示数字，如图26所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438713524454.png" alt=" "></p>
<center>图 26 数码管由0到7不断循环显示数字</center>



<p>(2) 按下按键1后，数码管保持当前显示不动，交通灯闪烁，如图27所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-16438713495682.png" alt=" "></p>
<center>图 27 数码管保持当前显示不动，交通灯闪烁</center>


<p>(3) 当数码管显示5时，按下按键2后，数码管保持当前显示不动，流水灯启动，如图28所示。</p>
<p><img src="/2021/07/08/%E9%A1%B9%E7%9B%AE-%E6%B1%87%E7%BC%96:Verilog:C-%E6%B0%B4%E7%81%AF%E3%80%81%E5%AD%98%E5%82%A8%E5%99%A8%E3%80%81%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png" alt=" "></p>
<center>图 28 数码管保持当前显示不动，流水灯启动</center>


<h1 id="4-实验总结"><a href="#4-实验总结" class="headerlink" title="4 实验总结"></a>4 实验总结</h1><h2 id="4-1-ARM相关驱动程序的安装"><a href="#4-1-ARM相关驱动程序的安装" class="headerlink" title="4.1 ARM相关驱动程序的安装"></a>4.1 ARM相关驱动程序的安装</h2><p>由于授课教师提供的FTP服务器中只含有ST-LINK的驱动安装包，而本次实验需要使用的是J-LINK驱动安装，因此需要自行在网络上下载J-LINK的驱动安装包，Keil才可以读取到硬件。</p>
<h2 id="4-2-Keil注册机的下载"><a href="#4-2-Keil注册机的下载" class="headerlink" title="4.2 Keil注册机的下载"></a>4.2 Keil注册机的下载</h2><p>由于FTP服务器中的Keil注册机已经在2021年的今天不再适用，故需要通过网络自行搜索下载最新版破解到2032年的Keil注册机。此外，Keil注册机可能会被杀毒软件误杀，且无法在QQ群中进行共享，因此最好的方式还是从网络上下载。</p>
<h2 id="4-3-USB-Blaster驱动的安装"><a href="#4-3-USB-Blaster驱动的安装" class="headerlink" title="4.3 USB-Blaster驱动的安装"></a>4.3 USB-Blaster驱动的安装</h2><p>由于版本的变化，在先前数电实验中使用的Quartus 20.1版本所对应的USB Blaster驱动无法与课程要求的Quartus 13.1版本相适应，且电脑无法自动安装驱动。故需要打开设备管理器手动在Quartus 13.1安装文件中的drivers文件夹添加USB Blaster驱动。</p>
<h2 id="4-4-Keil软件的烧录问题"><a href="#4-4-Keil软件的烧录问题" class="headerlink" title="4.4 Keil软件的烧录问题"></a>4.4 Keil软件的烧录问题</h2><p>在编程过程中遇到了点击烧录但开发板的效果没有变化的情况。这是因为在烧录之前没有进行ranslate再进行build操作，然后再进行烧录。</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>Verilog</category>
        <category>汇编</category>
        <category>C</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>汇编</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>INET 中加入自定义协议的方法</title>
    <url>/2022/08/30/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++:INET-INET%20%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当 INET 原生不具备所需实验环境时，我们可能需要自己编写一些网络协议以实现预期功能。基于此，本文将对 INET 中加入自定义协议的方法进行调研和记录。</p>
<span id="more"></span>
<h3 id="1-INET-基础架构"><a href="#1-INET-基础架构" class="headerlink" title="1 INET 基础架构"></a>1 INET 基础架构</h3><p>在 INET 环境中添加一个协议之前，首先需要对 INET 的基本框架有所了解。这样，我们才能知道自定义的协议应该放置在 INET 中的哪个位置。INET 的源码模块的组织依然遵循了 OSI 层次结构，即：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">路径</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>src/inet/applications/</code></td>
<td>流量生成器和应用模型</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/transportlayer/</code></td>
<td>传输层协议</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/networklayer/</code></td>
<td>网络层协议</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/linklayer/</code></td>
<td>链路层协议</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/physicallayer/</code></td>
<td>物理层模型</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/routing/</code></td>
<td>路由协议</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/mobility/</code></td>
<td>移动模型</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/power/</code></td>
<td>能耗模型</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/environment/</code></td>
<td>物理环境模型</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/node/</code></td>
<td>预安装的网络节点模型</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/visualizer/</code></td>
<td>可视化组件（2D/3D）</td>
</tr>
<tr>
<td style="text-align:left"><code>src/inet/common/</code></td>
<td>杂项实用组件</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，上表中的第一行 <strong><code>src/inet/applications/</code> 不是指七层协议中的应用层，只是定义了发包行为的实例</strong>。 </p>
<h3 id="2-添加自定义协议"><a href="#2-添加自定义协议" class="headerlink" title="2 添加自定义协议"></a>2 添加自定义协议</h3><h4 id="2-1-实验中的添加方式"><a href="#2-1-实验中的添加方式" class="headerlink" title="2.1 实验中的添加方式"></a>2.1 实验中的添加方式</h4><p>以实验中的 PFRP（Probabilistic forwarding routing protocol）协议为例，我们可以借助现有的网络协议快速便捷地将自定义协议添加到 INET 环境。</p>
<p>首先，在 <code>src/inet/applications/</code> 中编写用于控制收发包的应用模型 <code>UdpPfrpApp</code>，该模型由 3 个文件组成：</p>
<ul>
<li><p><code>UdpPfrpApp.h</code>：包含 <code>UdpPfrpApp</code> 类的声明 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">INET_API</span> <span class="title">UdpPfrpApp</span> :</span> <span class="keyword">public</span> ApplicationBase, <span class="keyword">public</span> UdpSocket::ICallback &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>UdpPfrpApp.cc</code>：包含 <code>UdpPfrpApp</code> 类的具体实现</p>
</li>
<li><p><code>UdpPfrpApp.ned</code>：定义 <code>UdpPfrpApp</code> 模块</p>
</li>
</ul>
<p>在 <code>UdpPfrpApp.cc</code> 文件中，我们需要先将所使用的路由协议名（PFRP）添加到控制发包的 <code>sendPacket()</code> 函数中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UdpPfrpApp::sendPacket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    string endlr = <span class="string">&quot;-&quot;</span> + dn + <span class="string">&quot;-&quot;</span> + routingProtocol + <span class="string">&quot;-&quot;</span> + <span class="built_in">to_string</span>(sendPacketId) + <span class="string">&quot;-&quot;</span> + <span class="built_in">to_string</span>(stepNum);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* endlre = endlr.<span class="built_in">c_str</span>();</span><br><span class="line">    Packet *packet = <span class="keyword">new</span> <span class="built_in">Packet</span>(<span class="built_in">strcat</span>(sender,endlre));</span><br><span class="line">    ...</span><br><span class="line">    socket.<span class="built_in">sendTo</span>(packet, destAddr, destPort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>routingProtocol</code> 为我们定义的路由协议名。将 <code>routingProtocol</code> 添加到字符串 <code>endlr</code> 后，再将其转换为 <code>packet</code> 发送到网络层。</p>
<p>发送到网络层后，我们就可以修改网络层协议 <code>src/inet/networklayer/ipv4/Ipv4.cc</code> 来进行下一步处理。对 <code>Ipv4.cc</code> 文件的 <code>routeUnicastPacket()</code> 函数进行修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ipv4::routeUnicastPacket</span><span class="params">(Packet *packet)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (destIE) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 若是 pfrp</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(packet-&gt;<span class="built_in">getFullName</span>(), <span class="string">&quot;pfrp&quot;</span>)) &#123;</span><br><span class="line">            ... <span class="comment">// 调用 pfrpTable 进行相应的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ... <span class="comment">// 若不是 pfrp，则按原有设定操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上述代码可知，当判断使用的路由协议是 PFRP 后，该部分还引入了自定义的 <code>pfrpTable</code> 辅助操作。<code>pfrpTable</code> 包含 <code>pfrpTable.h</code> 、<code>pfrpTable.cc</code>两个文件，和 <code>Ipv4.cc</code> 位于同一目录。<code>pfrpTable</code> 实现了概率路由表的生成、处理工作，并承担与 Python 端的通信任务。需要注意的是，在之前所提到的 <code>UdpPfrpApp</code> 中也存在着大量对 <code>pfrpTable</code> 的调用，<code>pfrpTable</code> 是概率路由协议实现的基石。</p>
<h4 id="2-2-OMNet-教程的添加方式"><a href="#2-2-OMNet-教程的添加方式" class="headerlink" title="2.2 OMNet 教程的添加方式"></a>2.2 OMNet 教程的添加方式</h4><p>以网络层协议 ISIS 为例，首先，由于 ISIS 是网络层协议，需要将其源代码的实现放在 <code>networkplayer</code> 目录下。在该目录下创建一个 <code>isis</code> 文件夹来保存具体实现代码。</p>
<p>对于一个新的协议，至少需要包含以下 3 个文件：</p>
<ul>
<li><p><code>ISIS.ned</code> 文件</p>
<p>NED 文件用来定义 ISIS 模块，使得其他的 NED 文件可以调用 ISIS 模块</p>
</li>
<li><p><code>ISIS.cc</code></p>
<p>包含有 ISIS 类的具体实现</p>
</li>
<li><p><code>ISIS.h</code></p>
<p>包含有 ISIS 类的声明</p>
</li>
</ul>
<p>从 INET for Omnet++ 4 开始，完成上述工作后直接在 INET 根目录下执行 <code>make</code> 命令即可使用。</p>
<p>值得注意的是，在使用 ISIS 模块时需要在 NED 文件中加入声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">package inet.networklayer.isis;</span><br></pre></td></tr></table></figure>
<p>同时，编写代码的时候要注意模块中的结构体不要和已有协议中的名称一样，否则会无法链接。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>OMNeT++</category>
        <category>INET</category>
      </categories>
      <tags>
        <tag>INET</tag>
        <tag>OMNeT++</tag>
      </tags>
  </entry>
  <entry>
    <title>INET ospfv2 simpleTest 示例</title>
    <url>/2022/08/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++:INET-%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%BC%80%E6%BA%90%E5%BA%93%20INET%20ospfv2%20simpletest%20%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h2><p>OSPF（开放最短路径优先）是一种用于 IP 网络的路由协议。它使用链路状态路由 (LSR) 算法，属于内部网关协议 (IGP) 组，在单个自治系统 (AS) 内运行。</p>
<span id="more"></span>
<p><a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.node.ospfv2.OspfRouter.html">OspfRouter</a> 是启用了 OSPF 协议路由器的实例化。</p>
<p><code>Ospfv2</code> 模块实现了 OSPF 协议的第 2 代版本。在该模块中，用户可以使用 <code>ospfConfig</code> 参数指定的 XML 文件配置区域和路由器。网络接口的各种参数也可以在 XML 文件中指定或作为 <code>Ospfv2</code> 模块的参数进行定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">**.ospf.ospfConfig = <span class="built_in">xmldoc</span>(<span class="string">&quot;ASConfig.xml&quot;</span>)</span><br><span class="line">**.ospf.helloInterval = <span class="number">12</span>s</span><br><span class="line">**.ospf.retransmissionInterval = <span class="number">6</span>s</span><br></pre></td></tr></table></figure>
<p>下方是 XML 文件所包含的信息。<code>&lt;OSPFASConfig&gt;</code> 根元素可以包含 <code>&lt;Area&gt;</code> 和 <code>&lt;Router&gt;</code> 元素，这些元素具有各种属性，并指定了网络接口的参数。其中，最重要的是 <code>&lt;Area&gt;</code> 包含的 <code>&lt;AddressRange&gt;</code> 元素，该元素列举了应该被协议提示的网络地址。此外，<code>&lt;Router&gt;</code> 元素可能包含用于配置各种点对点或广播接口的数据。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">OSPFASConfig</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;OSPF.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Areas --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Area</span> <span class="attr">id</span>=<span class="string">&quot;0.0.0.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AddressRange</span> <span class="attr">address</span>=<span class="string">&quot;H1&quot;</span> <span class="attr">mask</span>=<span class="string">&quot;H1&quot;</span> <span class="attr">status</span>=<span class="string">&quot;Advertise&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AddressRange</span> <span class="attr">address</span>=<span class="string">&quot;H2&quot;</span> <span class="attr">mask</span>=<span class="string">&quot;H2&quot;</span> <span class="attr">status</span>=<span class="string">&quot;Advertise&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AddressRange</span> <span class="attr">address</span>=<span class="string">&quot;R1&gt;R2&quot;</span> <span class="attr">mask</span>=<span class="string">&quot;R1&gt;R2&quot;</span> <span class="attr">status</span>=<span class="string">&quot;Advertise&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">AddressRange</span> <span class="attr">address</span>=<span class="string">&quot;R2&gt;R1&quot;</span> <span class="attr">mask</span>=<span class="string">&quot;R2&gt;R1&quot;</span> <span class="attr">status</span>=<span class="string">&quot;Advertise&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Area</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Routers --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Router</span> <span class="attr">name</span>=<span class="string">&quot;R1&quot;</span> <span class="attr">RFC1583Compatible</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BroadcastInterface</span> <span class="attr">ifName</span>=<span class="string">&quot;eth0&quot;</span> <span class="attr">areaID</span>=<span class="string">&quot;0.0.0.0&quot;</span> <span class="attr">interfaceOutputCost</span>=<span class="string">&quot;1&quot;</span> <span class="attr">routerPriority</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PointToPointInterface</span> <span class="attr">ifName</span>=<span class="string">&quot;eth1&quot;</span> <span class="attr">areaID</span>=<span class="string">&quot;0.0.0.0&quot;</span> <span class="attr">interfaceOutputCost</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Router</span> <span class="attr">name</span>=<span class="string">&quot;R2&quot;</span> <span class="attr">RFC1583Compatible</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PointToPointInterface</span> <span class="attr">ifName</span>=<span class="string">&quot;eth0&quot;</span> <span class="attr">areaID</span>=<span class="string">&quot;0.0.0.0&quot;</span> <span class="attr">interfaceOutputCost</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">BroadcastInterface</span> <span class="attr">ifName</span>=<span class="string">&quot;eth1&quot;</span> <span class="attr">areaID</span>=<span class="string">&quot;0.0.0.0&quot;</span> <span class="attr">interfaceOutputCost</span>=<span class="string">&quot;1&quot;</span> <span class="attr">routerPriority</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">OSPFASConfig</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="实验内容记录"><a href="#实验内容记录" class="headerlink" title="实验内容记录"></a>实验内容记录</h2><p>涉及文件：</p>
<ul>
<li><code>/inet4/examples/ospfv2/simpletest/omnetpp.ini</code></li>
<li><code>/inet4/examples/ospfv2/simpletest/SimpleTest.ned</code></li>
<li><code>/inet4/src/inet/applications/udpapp/UdpBasicApp.cc</code></li>
</ul>
<p>INET 将节点细分为Host、Router 和 Switch 三种类型，即主机、路由器和交换机。这里的 Host 与设备的概念更加类似，Router 主要负责转发包，Switch 就是 Ethernet 接口。</p>
<p>在本实验中，涉及到了 <code>udpapp</code> 下的 <code>UdpBasicApp</code> 和 <code>UdpEchoApp</code> 两个 Application。其中：</p>
<ul>
<li><code>UdpBasicApp</code> 以给定的时间间隔将 UDP 数据包发送到给定的 IP 地址</li>
<li><code>UdpEchoApp</code>类似于 <code>UdpBasicApp</code>，但它在接收到数据包后发回</li>
</ul>
<p><code>UdpBasicApp</code> 将 UDP 数据包发送到 <code>destAddresses</code> 参数中给定的 IP 地址。应用程序在每个时间间隔内向其中一个目标发送消息 <code>sendInterval</code>。消息之间的间隔和消息长度可以作为随机变量给出。</p>
<p><code>UdpEchoApp</code> 类似于 <code>UdpBasicApp</code>，但它在接收到数据包后发回数据包。它只接受带有 <code>UdpHeader</code> 的数据包，即由另一个 <code>UdpEchoApp</code> 生成的数据包。</p>
<p>该实验的操作方式为：先到 <code>omnetpp</code> 和 <code>inet4</code> 根目录下使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. setenv</span><br></pre></td></tr></table></figure>
<p>激活环境，然后回到 <code>inet4</code> 根目录下输入 <code>opp_makemake -f</code> 和 <code>make</code> 命令，最后再到程序目录下执行 <code>inet</code> 命令即可。</p>
<p><strong>需要注意的是，每次对 INET 中的程序进行修改后，都需要重新 <code>make</code>。</strong></p>
<p><strong>参考资料：</strong></p>
<ul>
<li><code>UdpBasicApp</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.applications.udpapp.UdpBasicApp.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.applications.udpapp.UdpBasicApp.html</a></li>
<li><code>UdpEchoApp</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.applications.udpapp.UdpEchoApp.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.applications.udpapp.UdpEchoApp.html</a></li>
<li><code>UdpHeader</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/src-inet-transportlayer-udp-UdpHeader.html">https://doc.omnetpp.org/inet/api-current/neddoc/src-inet-transportlayer-udp-UdpHeader.html</a>)</li>
</ul>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="/2022/08/08/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++:INET-%E8%BF%9B%E9%98%B6%EF%BC%9A%E5%BC%80%E6%BA%90%E5%BA%93%20INET%20ospfv2%20simpletest%20%E7%A4%BA%E4%BE%8B/image-20220808215705070.png" alt="实验结果"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>OMNeT++</category>
        <category>INET</category>
      </categories>
      <tags>
        <tag>INET</tag>
        <tag>OMNeT++</tag>
      </tags>
  </entry>
  <entry>
    <title>开源库 INET wireless 示例</title>
    <url>/2022/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++:INET-%E6%95%B2%E9%97%A8%E7%A0%96%EF%BC%9A%E5%BC%80%E6%BA%90%E5%BA%93%20INET%20wireless%20%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="示例-1-两台主机无线通信"><a href="#示例-1-两台主机无线通信" class="headerlink" title="示例 1 两台主机无线通信"></a>示例 1 两台主机无线通信</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>创建一个包含 2 个主机的网络，其中一台主机向另一台主机发送 UDP 数据流。在实验过程尽量简化底层协议模型。官方示例保存在 <code>inet4/tutorials/wireless/</code> 路径中。</p>
<span id="more"></span>
<h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><h4 id="网络模型文件"><a href="#网络模型文件" class="headerlink" title="网络模型文件"></a>网络模型文件</h4><p>本次实验的网络是一个包含 2 个主机的网络，对应的 NED 文件如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">network WirelessA</span><br><span class="line">&#123;</span><br><span class="line">    parameters:</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;bgb=650,500;bgg=100,1,grey95&quot;</span>);</span><br><span class="line">        @figure[title](type=label; pos=<span class="number">0</span>,<span class="number">-1</span>; anchor=sw; color=darkblue);</span><br><span class="line">        @figure[rcvdPkText](type=indicatorText; pos=<span class="number">380</span>,<span class="number">20</span>; anchor=w; font=,<span class="number">18</span>; textFormat=<span class="string">&quot;packets received: %g&quot;</span>; initialValue=<span class="number">0</span>);</span><br><span class="line">        @statistic[packetReceived](source=hostB.app[<span class="number">0</span>].packetReceived; record=<span class="built_in">figure</span>(count); targetFigure=rcvdPkText);</span><br><span class="line"></span><br><span class="line">    submodules:</span><br><span class="line">        visualizer: &lt;<span class="built_in"><span class="keyword">default</span></span>(<span class="built_in">firstAvailableOrEmpty</span>(<span class="string">&quot;IntegratedCanvasVisualizer&quot;</span>))&gt; like IIntegratedVisualizer <span class="keyword">if</span> <span class="keyword">typename</span> != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=580,125&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        configurator: Ipv4NetworkConfigurator &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=580,200&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        radioMedium: &lt;<span class="built_in"><span class="keyword">default</span></span>(<span class="string">&quot;UnitDiskRadioMedium&quot;</span>)&gt; like IRadioMedium &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=580,275&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hostA: &lt;<span class="built_in"><span class="keyword">default</span></span>(<span class="string">&quot;WirelessHost&quot;</span>)&gt; like INetworkNode &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=50,325&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hostB: &lt;<span class="built_in"><span class="keyword">default</span></span>(<span class="string">&quot;WirelessHost&quot;</span>)&gt; like INetworkNode &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=450,325&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述 NED 文件通过 <code>@display()</code> 方法定义了一个 $500 \times 600$ 米的仿真场景，两个主机的距离为 $450 - 50 = 400$ 米。除了主机之外，NED 文件还定义了可视化、配置 IP 层和对物理无线电信道建模等对象。</p>
<p><code>omnetpp.ini</code> 文件如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[Config Wireless01]</span><br><span class="line">description = Two hosts communicating wirelessly</span><br><span class="line">network = WirelessA</span><br><span class="line">sim-time-limit = <span class="number">20</span>s</span><br><span class="line"></span><br><span class="line">*.host*.ipv4.arp.<span class="keyword">typename</span> = <span class="string">&quot;GlobalArp&quot;</span></span><br><span class="line"></span><br><span class="line">*.hostA.numApps = <span class="number">1</span></span><br><span class="line">*.hostA.app[<span class="number">0</span>].<span class="keyword">typename</span> = <span class="string">&quot;UdpBasicApp&quot;</span></span><br><span class="line">*.hostA.app[<span class="number">0</span>].destAddresses = <span class="string">&quot;hostB&quot;</span></span><br><span class="line">*.hostA.app[<span class="number">0</span>].destPort = <span class="number">5000</span></span><br><span class="line">*.hostA.app[<span class="number">0</span>].messageLength = <span class="number">1000B</span></span><br><span class="line">*.hostA.app[<span class="number">0</span>].sendInterval = <span class="built_in">exponential</span>(<span class="number">12</span>ms)</span><br><span class="line">*.hostA.app[<span class="number">0</span>].packetName = <span class="string">&quot;UDPData&quot;</span></span><br><span class="line"></span><br><span class="line">*.hostB.numApps = <span class="number">1</span></span><br><span class="line">*.hostB.app[<span class="number">0</span>].<span class="keyword">typename</span> = <span class="string">&quot;UdpSink&quot;</span></span><br><span class="line">*.hostB.app[<span class="number">0</span>].localPort = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].<span class="keyword">typename</span> = <span class="string">&quot;AckingWirelessInterface&quot;</span></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].mac.useAck = <span class="literal">false</span></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].mac.fullDuplex = <span class="literal">false</span></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.transmitter.communicationRange = <span class="number">500</span>m</span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.receiver.ignoreInterference = <span class="literal">true</span></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].mac.headerLength = <span class="number">23B</span></span><br><span class="line"></span><br><span class="line">*.host*.**.bitrate = <span class="number">1</span>Mbps</span><br></pre></td></tr></table></figure>
<h4 id="主机"><a href="#主机" class="headerlink" title="主机"></a>主机</h4><p>在 INET 中，主机通常定义为 <code>StandardHost</code> NED 类型，这是 TCP/IP 主机的通用模板，包含 TCP、UDP 和 IP 等协议组件、用于插入应用程序模型的插槽以及各种网络接口 (NIC)。<code>StandardHost</code> 在实际应用中存在一些变体，例如上述 NED 文件中提到的 <code>WirelessHost</code>，它是为无线场景预配置的 <code>StandardHost</code>。</p>
<p>主机的类型在上述 NED 文件中是通过 <code>hostType</code> 参数和 <code>INetworkNode</code> 网络模块接口定义的。这使得接下来的实验中可以用不同的 NED 类型替换主机。这里的 NED 实际类型是 <code>WirelessHost</code>，在后面的实验中将使用 <code>omnetpp.ini</code> 配置进行替代。</p>
<p><strong>参考链接：</strong></p>
<p><code>StandardHost</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.node.inet.StandardHost.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.node.inet.StandardHost.html</a></p>
<p><code>WirelessHost</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.node.inet.WirelessHost.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.node.inet.WirelessHost.html</a></p>
<p><code>INetworkNode</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.node.contract.INetworkNode.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.node.contract.INetworkNode.html</a></p>
<h4 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h4><p>IP 地址通过 <code>Ipv4NetworkConfigurator</code> 模块分配给主机，该模块在 NED 中的实例化对象为 <code>configurator</code>。此外，主机之间还需要知道彼此的 MAC 地址才能进行通信，在仿真模型中主要通过每个主机的 <code>GlobalArp</code> 模块代替现实中的 ARP 进行处理。</p>
<h4 id="流量模型"><a href="#流量模型" class="headerlink" title="流量模型"></a>流量模型</h4><p>在模型中，主机 B 需要接收主机 A 生成的 UDP 数据包。为此，在主机 A 内部配置一个 <code>UdpBasicApp</code> 模块，模块以指数分布的平均 12 秒随机间隔生成 1000 字节的 UDP 信息。也就是说，应用程序将为主机 A 生成一个 100 <code>kbyte/s</code> 的 UDP 流量。在 NED 文件中，主机 B 还包含了一个 <code>UdpSink</code> 应用程序丢弃接收到的数据包。</p>
<p><strong>参考链接：</strong></p>
<p>UdpSink：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.applications.udpapp.UdpSink.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.applications.udpapp.UdpSink.html</a></p>
<h4 id="物理层建模"><a href="#物理层建模" class="headerlink" title="物理层建模"></a>物理层建模</h4><p>INET 中所有无线仿真都需要一个 <code>radioMedium</code> 模块。该模块代表进行通信的物理介质，负责考虑信号传播、衰减、干扰和其他物理现象。</p>
<p>INET 可以在各种细节层次上对无线物理层进行建模，通过不同的无线电介质模块实现。在该示例中使用最简单的模型 <code>UnitDiskRadioMedium</code>。该模型忽略了信号衰减等物理现象，通信范围以米为单位。</p>
<p>在此模型中，实验选择的物理层模型（<code>UnitDiskRadioMedium</code> 和 <code>UnitDiskRadio</code> 设置如下：通信范围为 $500 m$ ，忽略干扰导致的数据包丢失问题；无线电数据速率设置为 $1 Mbps$。上述这些值都可以通过相应模块在 <code>omnetpp.ini</code> 文件中的 <code>communicationRange</code>、<code>ignoreInterference</code> 和 <code>bitrate</code> 参数进行设置。</p>
<p><strong>参考链接：</strong></p>
<p><code>UnitDiskRadioMedium</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.unitdisk.UnitDiskRadioMedium.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.unitdisk.UnitDiskRadioMedium.html</a></p>
<p><code>UnitDiskRadio</code> (<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.unitdisk.UnitDiskRadio.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.unitdisk.UnitDiskRadio.html</a>)</p>
<h4 id="MAC-层"><a href="#MAC-层" class="headerlink" title="MAC 层"></a>MAC 层</h4><p>NIC 模块还包含 L2 层（数据链路层）协议。其中涉及 MAC 协议的接口 <code>AckingWirelessInterface</code> 是可配置的，默认值为 <code>MultipleAccessMac</code>.。<code>MultipleAccessMac</code> 实现了一个简单的 MAC 层协议，只提供封装/解封装功能而没有真正的媒体访问协议，即一旦前一个数据包传输完成，下一个数据包就会立刻开始传输。<code>MultipleAccessMac</code> 还包含一个可选的确认机制，在该实验中已被关闭。</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>完成配置后进入 <code>/inet4/</code> 文件夹。与 <code>omnetpp</code> 的操作类似，先使用命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. setenv</span><br></pre></td></tr></table></figure>
<p>启动环境，再输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opp_makemake</span><br></pre></td></tr></table></figure>
<p>编译产生 <code>Makefile</code> 文件，接着输入命令 <code>make</code> 即可产生可执行文件 <code>inet4</code>。</p>
<p>完成构建后，前往示例所在文件夹 <code>/inet4/tutorials/wireless</code>，输入命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inet</span><br></pre></td></tr></table></figure>
<p>即可开始仿真。得到的仿真结果如下所示：</p>
<p><img src="/2022/08/07/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-OMNeT++:INET-%E6%95%B2%E9%97%A8%E7%A0%96%EF%BC%9A%E5%BC%80%E6%BA%90%E5%BA%93%20INET%20wireless%20%E7%A4%BA%E4%BE%8B/image-20220808141635382.png" alt="wireless1仿真结果" style="zoom:67%;"></p>
<p>多个网络时，可以通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inet -c wireless01</span><br></pre></td></tr></table></figure>
<p>指定对应的配置进行编译。    </p>
<h2 id="示例-2-增加动画"><a href="#示例-2-增加动画" class="headerlink" title="示例 2 增加动画"></a>示例 2 增加动画</h2><p>可视化示例，略过。</p>
<h2 id="示例-3-缩短通信范围，增加主机"><a href="#示例-3-缩短通信范围，增加主机" class="headerlink" title="示例 3 缩短通信范围，增加主机"></a>示例 3 缩短通信范围，增加主机</h2><p>增加了三个无线节点，并缩小了通信范围，使我们原来的两台主机无法直接相互联系。配置文件的修改如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*.host*.wlan[<span class="number">0</span>].radio.transmitter.communicationRange = <span class="number">250</span>m</span><br><span class="line">*.hostR1.wlan[<span class="number">0</span>].radio.displayCommunicationRange = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>此外，NED 文件使用了继承方式继承了第一步的网络结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">network WirelessB extends WirelessA</span><br><span class="line">&#123;</span><br><span class="line">    submodules:</span><br><span class="line">        hostR1: &lt;<span class="built_in"><span class="keyword">default</span></span>(<span class="string">&quot;WirelessHost&quot;</span>)&gt; like INetworkNode &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=250,300&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hostR2: &lt;<span class="built_in"><span class="keyword">default</span></span>(<span class="string">&quot;WirelessHost&quot;</span>)&gt; like INetworkNode &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=150,450&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        hostR3: &lt;<span class="built_in"><span class="keyword">default</span></span>(<span class="string">&quot;WirelessHost&quot;</span>)&gt; like INetworkNode &#123;</span><br><span class="line">            @<span class="built_in">display</span>(<span class="string">&quot;p=350,450&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="示例-4-静态路由"><a href="#示例-4-静态路由" class="headerlink" title="示例 4 静态路由"></a>示例 4 静态路由</h2><p>INET 框架中的静态配置通常由 <code>configurator</code> 模块完成。静态 IPv4 的配置包括地址分配和添加路由，通常使用 <code>Ipv4NetworkConfigurator</code> 模块完成。该实验中已经有这个模块的一个实例，即 <code>configurator</code> 子模块。可以使用 XML 规范和一些附加参数来配置配置器。XML 规范在 <code>.ini</code> 文件中作为字符串常量提供：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*.configurator.config = <span class="built_in">xml</span>(<span class="string">&quot;&lt;config&gt;&lt;interface hosts=&#x27;**&#x27; address=&#x27;10.0.0.x&#x27; netmask=&#x27;255.255.255.0&#x27;/&gt;&lt;autoroute metric=&#x27;errorRate&#x27;/&gt;&lt;/config&gt;&quot;</span>)</span><br><span class="line">*.configurator.optimizeRoutes = <span class="literal">false</span></span><br><span class="line">*.host*.ipv4.routingTable.netmaskRoutes = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>在本实验中通过 XML 让配置器分配 10.0.0.x 范围内的 IP 地址，并根据估计的节点之间链路的数据包错误率创建路由.。配置器将无线网络视为一个完整的图模型，错误率高的链路成本高，错误率低的链路成本低。形成的路由以使其错误成本最小化。</p>
<p><strong>参考资料：</strong></p>
<p><code>Ipv4NetworkConfigurator</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.networklayer.configurator.ipv4.Ipv4NetworkConfigurator.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.networklayer.configurator.ipv4.Ipv4NetworkConfigurator.html</a></p>
<h2 id="示例-5-8-物理层问题"><a href="#示例-5-8-物理层问题" class="headerlink" title="示例 5-8 物理层问题"></a>示例 5-8 物理层问题</h2><p>暂时忽略</p>
<h2 id="示例-9-节点移动"><a href="#示例-9-节点移动" class="headerlink" title="示例 9 节点移动"></a>示例 9 节点移动</h2><p>在 INET 框架中，节点移动性由<code>mobility</code> 模块的子模块处理。INET 定义了几种可以插入主机的移动模块类型:运动轨迹可以是确定性的（例如直线、矩形或圆形）、概率性的（例如随机航路点）、脚本化的（例如 LOGO 脚本）或轨迹驱动的，以及个人和团体流动模型。</p>
<p>在这里，我们将 <code>LinearMobility</code> 安装到中间节点中。 <code>LinearMobility</code> 实现沿线的运动，其中方向和速度是待定参数。将节点配置为以 12 m/s 的速度向北移动，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[Config Wireless09]</span><br><span class="line">description = Configuring node movements</span><br><span class="line">extends = Wireless08</span><br><span class="line"></span><br><span class="line">*.hostR*.mobility.<span class="keyword">typename</span> = <span class="string">&quot;LinearMobility&quot;</span></span><br><span class="line">*.hostR*.mobility.speed = <span class="number">12</span>mps</span><br><span class="line">*.hostR*.mobility.initialMovementHeading = <span class="number">270</span>deg</span><br><span class="line"></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].queue.packetCapacity = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>此外，实验将队列长度限制为 10 个数据包。这使得网络可以对节点移动引起的拓扑变化做出更快的反应，因为队列不会被旧数据包堵塞。然而，由于丢包，我们预计主机 B 收到的数据包的序列号将不再是连续的。</p>
<p><strong>参考资料：</strong></p>
<p><code>LinearMobility</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.mobility.single.LinearMobility.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.mobility.single.LinearMobility.html</a> </p>
<h2 id="示例-10-AD-HOC-路由"><a href="#示例-10-AD-HOC-路由" class="headerlink" title="示例 10 AD-HOC 路由"></a>示例 10 AD-HOC 路由</h2><p>在该实验中，将主机更改为 <code>AodvRouter</code> 的实例。<code>AodvRouter</code> 类似于 <code>WirelessHost</code>，但在其基础上添加了一个 <code>AodvRouting</code> 子模块，将每个节点变成一个 AODV 路由器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">description = Configuring ad-hoc <span class="built_in">routing</span> (AODV)</span><br><span class="line">extends = Wireless09</span><br><span class="line">*.configurator.addStaticRoutes = <span class="literal">false</span></span><br><span class="line">*.host*.<span class="keyword">typename</span> = <span class="string">&quot;AodvRouter&quot;</span></span><br><span class="line">*.hostB.wlan[<span class="number">0</span>].radio.displayCommunicationRange = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>AODV 代表 Ad hoc On-Demand Distance Vector。在 AODV 中，路线根据需求建立。一旦建立，只要存在需求就会一直保持路由。</p>
<p>AODV 定义的消息类型有路由请求 (RREQ)、路由回复 (RREP) 和路由错误 (RERR)。在 AODV 中，网络静默直到需要连接。此时，需要连接的网络节点会广播连接请求。其他 AODV 节点转发此消息并记录他们从哪个节点听到该消息，从而创建大量返回需要节点的临时路由。当一个节点接收到这样的消息并且已经有到所需节点的路由时，它会通过临时路由将消息向后发送到请求节点。然后，有需要的节点开始使用通过其他节点的跳数最少的路由。路由表中未使用的条目在一段时间后被回收。</p>
<p><strong>参考资料：</strong></p>
<p><code>AodvRouter</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.node.aodv.AodvRouter.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.node.aodv.AodvRouter.html</a></p>
<h2 id="示例-11-给环境添加障碍"><a href="#示例-11-给环境添加障碍" class="headerlink" title="示例 11 给环境添加障碍"></a>示例 11 给环境添加障碍</h2><p>在 INET 中，障碍物作为 <code>PhysicalEnvironment</code> 模块的一部分进行管理，因此需要在网络添加一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">submodules:</span><br><span class="line">    physicalEnvironment: PhysicalEnvironment &#123;</span><br><span class="line">        @<span class="built_in">display</span>(<span class="string">&quot;p=580,425&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>障碍在 <code>walls.xml</code>  XML 文件中描述。障碍物由其形状、位置、方向和材料定义。它也可以有一个名称，并且可以定义它应该如何呈现（颜色、线宽、不透明度等）。XML 格式允许人们使用预定义的形状，如长方体、棱柱、多面体或球体，还可以定义新的可以重复用于任何数量的障碍的形状。材料也是类似的：有预定义的材料，如混凝土、砖、木头、玻璃、森林，还可以定义新材料。材料由其物理特性定义，例如电阻率、相对介电常数和相对磁导率。这些属性用于计算介电损耗角正切、折射率和信号传播速度，并最终用于计算信号损耗。</p>
<p><strong>参考资料：</strong></p>
<p><code>PhysicalEnvironment</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.environment.common.PhysicalEnvironment.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.environment.common.PhysicalEnvironment.html</a></p>
<h2 id="示例-12-增加调制和信道建模"><a href="#示例-12-增加调制和信道建模" class="headerlink" title="示例 12 增加调制和信道建模"></a>示例 12 增加调制和信道建模</h2><p>该示例中使用 <code>ApskScalarRadio</code> ：APSK（幅度和相移键控）调制方案对无线电进行建模。默认情况下，它使用 BPSK，但也可以配置 QPSK、QAM-16、QAM-64、QAM-256 和其他几种调制方式。（调制是无线电发射器组件的参数。）此外，在无线信道方面，<code>ApskScalarRadio</code> 还具有插入各种传播模型、路径损耗模型、障碍物损耗模型、模拟模型和背景噪声模型的“插槽”。</p>
<p>接收器的物理参数也很重要。实验需要配置以下接收器参数： </p>
<ul>
<li>灵敏度 [dBm]：如果信号功率低于此阈值，则无法接收（即接收器无法从<em>信道忙</em>状态进入<em>接收</em>状态） </li>
<li>能量检测阈值 [dBm]：如果接收功率低于此阈值，未检测到信号并且检测到信道为空（这对于 CSMA 的“载波侦听”部分很重要） </li>
<li>SNIR 阈值 [dB]：如果 SNIR 低于此阈值，则接收不成功</li>
</ul>
<p>配置文件如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[Config Wireless12]</span><br><span class="line">description = Changing to a more realistic radio model</span><br><span class="line">extends = Wireless11</span><br><span class="line"></span><br><span class="line">*.radioMedium.<span class="keyword">typename</span> = <span class="string">&quot;ApskScalarRadioMedium&quot;</span></span><br><span class="line">*.radioMedium.backgroundNoise.power = <span class="number">-90</span>dBm</span><br><span class="line">*.radioMedium.mediumLimitCache.centerFrequency = <span class="number">2</span>GHz</span><br><span class="line"></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.<span class="keyword">typename</span> = <span class="string">&quot;ApskScalarRadio&quot;</span></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.centerFrequency = <span class="number">2</span>GHz</span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.bandwidth = <span class="number">2</span>MHz</span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.transmitter.power = <span class="number">1.4</span>mW</span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.transmitter.preambleDuration = <span class="number">10u</span>s</span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.transmitter.headerLength = <span class="number">8B</span></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.receiver.sensitivity = <span class="number">-85</span>dBm</span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.receiver.energyDetection = <span class="number">-85</span>dBm</span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.receiver.snirThreshold = <span class="number">4</span>dB</span><br><span class="line"></span><br><span class="line">*.hostR1.wlan[*].radio.bitErrorRate.result-recording-modes = <span class="keyword">default</span>,+vector</span><br></pre></td></tr></table></figure>
<p><strong>参考资料：</strong></p>
<p><code>ApskScalarRadio</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.apsk.packetlevel.ApskScalarRadio.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.apsk.packetlevel.ApskScalarRadio.html</a></p>
<h2 id="示例-13-路径损耗模型"><a href="#示例-13-路径损耗模型" class="headerlink" title="示例 13 路径损耗模型"></a>示例 13 路径损耗模型</h2><p>与地面反射、障碍物反射衍射模型有关。安装两射线地面反射模型只需将 <code>ApskScalarRadio</code> 的 <code>pathLossType</code> 参数从默认的 <code>FreeSpacePathLoss</code> 更改为 <code>TwoRayGroundReflection</code> 即可。（其他选项包括 <code>RayleighFading</code>、<code>RicianFading</code>、<code>LogNormalShadowing</code> 等。）</p>
<p><strong>参考资料：</strong></p>
<p> <code>TwoRayGroundReflection</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.pathloss.TwoRayGroundReflection.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.pathloss.TwoRayGroundReflection.html</a></p>
<p><code>RayleighFading</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.pathloss.RayleighFading.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.pathloss.RayleighFading.html</a></p>
<p><code>RicianFading</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.pathloss.RicianFading.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.pathloss.RicianFading.html</a></p>
<p><code>LogNormalShadowing</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.pathloss.LogNormalShadowing.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.pathloss.LogNormalShadowing.html</a></p>
<h2 id="示例-14-天线增益"><a href="#示例-14-天线增益" class="headerlink" title="示例 14 天线增益"></a>示例 14 天线增益</h2><p>在前面的示例中，假设天线为各向同性天线，增益为 1 (0dB)。可通过下述方式修改天线增益：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*.host*.wlan[<span class="number">0</span>].radio.antenna.<span class="keyword">typename</span> = <span class="string">&quot;ConstantGainAntenna&quot;</span></span><br><span class="line">*.host*.wlan[<span class="number">0</span>].radio.antenna.gain = <span class="number">3</span>dB</span><br></pre></td></tr></table></figure>
<p>其中，<code>ConstantGainAntenna</code> 是一种对在与仿真相关的方向上具有恒定增益的天线进行建模，而不管这种天线在现实生活中如何实现的抽象。</p>
<p><strong>参考资料：</strong></p>
<p><code>ConstantGainAntenna</code>：<a href="https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.antenna.ConstantGainAntenna.html">https://doc.omnetpp.org/inet/api-current/neddoc/inet.physicallayer.wireless.common.antenna.ConstantGainAntenna.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>OMNeT++</category>
        <category>INET</category>
      </categories>
      <tags>
        <tag>INET</tag>
        <tag>OMNeT++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++-throw抛出异常</title>
    <url>/2020/03/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_throw/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在学习C++数据结构的过程中，常常会见到如下的代码块：</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T LinkList&lt;T&gt;::<span class="built_in">Get</span>( <span class="keyword">int</span> i)</span><br><span class="line">&#123; <span class="comment">//初始化</span></span><br><span class="line">	Node&lt;T&gt; *p=first-&gt;next;</span><br><span class="line">	<span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (j!=i) &amp;&amp; (p!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">throw</span> “位置非法”;</span><br><span class="line">	<span class="keyword">return</span> p-&gt;data; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 其中老师对于throw的解释是：如果满足条件，抛出异常。但在依样画葫芦后，却出现了以下的错误信息：</p>
<p><img src="/2020/03/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_throw/1.jpeg" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 于是便对throw的具体用法产生了好奇，故作此文以记。</p>
<h2 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++异常处理"></a>C++异常处理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在C++语言中，通常使用try,throw和catch语句去实现异常处理，示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThrowError</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	cin &gt;&gt; a;</span><br><span class="line">	<span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="keyword">throw</span><span class="string">&quot;字符串：输入的为1&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;throw后面的语句&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ThrowError</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">int</span> e)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in"><span class="keyword">switch</span></span> (e)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入的为0&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;输入的既不是0也不是1&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* e)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;catch后的语句&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 运行效果：<br><img src="/2020/03/31/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_throw/2.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 接下来逐一解释各部分代码块</p>
<p> <strong>1. try{}</strong><br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try后面跟着的括号内的语句是代码的保护段，如果程序按照正常的顺讯执行到try语句，则执行try语句的内容。 <strong>如果try语句正常执行，则跟在try语句后面的catch不被执行。转而执行try语句后跟着的最后一个catch语句之后执行程序。</strong> 相反，如果try语句不正常执行，则执行catch内的语句。</p>
<p> <strong>2. throw</strong><br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw的基本语法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> 表达式;<span class="comment">//表达式可以是基本数据类型，也可以是类</span></span><br></pre></td></tr></table></figure>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过该语句抛出异常。通过运行示例可以发现，在try语句块中，<strong>若成功抛出一个异常，则throw之后的语句都将不再被执行。</strong></p>
<p>  <strong>3. catch</strong><br>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果 try 块执行的过程中拋出了异常，<strong>那么拋出异常后立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行</strong>，执行完后再跳转到最后一个 catch 块后面继续执行。<br>      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果抛出的异常没有被捕获，那么程序会立刻终止，出现前言所述的情况。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw抛出异常的做法在遇到需要动态申请和释放内存、涉及指针操作的时候，可以比较有效地发现如野指针，指针悬挂等问题。故此记录。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记-顺序表vector</title>
    <url>/2020/04/05/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_vector/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与string类一样 vector 类是随标准 C++引入的标准库的一部分 ，为了使用vector 我们必须包含相关的头文件  ：</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector在实例化时不需要申明长度。标准库负责管理和储存元素相关的内存，用户不用担心长度不够，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec<span class="comment">//定义向量对象ivec，向量中每一个元素都是int类型</span></span><br></pre></td></tr></table></figure>
<h2 id="一-vector的初始化"><a href="#一-vector的初始化" class="headerlink" title="一.vector的初始化"></a>一.vector的初始化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector有两种不同的使用形式，分别为数组习惯和 STL习惯。</p>
<ol>
<li><strong>数组习惯用法</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">5</span>)</span></span>;  <span class="comment">//类似数组定义int ivec[5];</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过ivec[索引号] 来访问元素</p>
<ol>
<li><strong>STL习惯</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在定义vector的元素时，可以为每个元素提供一个显式的初始值来完成初始化，例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">2</span>,<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义了ivec，包含2个int类型的元素，每个元素初始化为1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于数组，我们同样可以进行初始化，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">2</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是我们不能用同样的方式初始化vector，但是可以通过数组来对vector进行初始化，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(ia,ia+<span class="number">2</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;或者：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(&amp;ia[<span class="number">0</span>],&amp;ia[<span class="number">1</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示将a[0],a[1]的元素拷贝到ivec内</p>
<ol>
<li><strong>vector可以被另一个vector初始化，或被赋值给另一个vector</strong>，例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>;</span><br><span class="line">ivec2 = ivec;</span><br></pre></td></tr></table></figure>
<h2 id="二-定义在vector类中的方法"><a href="#二-定义在vector类中的方法" class="headerlink" title="二.定义在vector类中的方法"></a>二.定义在vector类中的方法</h2><div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>back()</td>
<td>返回最后一个向量的值</td>
</tr>
<tr>
<td>begin()</td>
<td>返回指向第一个元素的迭代器</td>
</tr>
<tr>
<td>capacity()</td>
<td>返回容量</td>
</tr>
<tr>
<td>clear()</td>
<td>将容器清空</td>
</tr>
<tr>
<td>empty()</td>
<td>若大小为0，则返回true；否则，返回false</td>
</tr>
<tr>
<td>end()</td>
<td>返回指向最后一个元素的迭代器</td>
</tr>
<tr>
<td>erase()</td>
<td>在向量的任意位置删除元素</td>
</tr>
<tr>
<td>insert()</td>
<td>在向量的任意位置插入元素</td>
</tr>
<tr>
<td>pop_back()</td>
<td>删除最后一个元素</td>
</tr>
<tr>
<td>push_back()</td>
<td>在向量尾部添加元素</td>
</tr>
<tr>
<td>resize()</td>
<td>改变容量</td>
</tr>
<tr>
<td>size()</td>
<td>返回向量中的元素个数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="三-vector使用实例"><a href="#三-vector使用实例" class="headerlink" title="三.vector使用实例"></a>三.vector使用实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;PHONEBOOK&gt; vec;</span><br><span class="line">	PHONEBOOK pbook[<span class="number">4</span>] = &#123;</span><br><span class="line">							&#123; <span class="number">20181208</span>, <span class="string">&quot;Mary&quot;</span> ,<span class="string">&quot; 13011221827&quot;</span>，<span class="string">&quot;classmates&quot;</span> &#125;,</span><br><span class="line">							&#123; <span class="number">20181127</span>,<span class="string">&quot;Tom&quot;</span> ,<span class="string">&quot;13934621123”,&quot;</span> <span class="string">&quot;family&quot;</span> &#125;,</span><br><span class="line">							&#123; <span class="number">20181156</span>, <span class="string">&quot;John&quot;</span> ,<span class="string">&quot;1324579880&quot;</span> ,<span class="string">&quot;classmates&quot;</span> &#125;,</span><br><span class="line">							&#123; <span class="number">20181133</span>, <span class="string">&quot;Lisa&quot;</span> ,<span class="string">&quot; 1378001822”,&#x27; classmates&quot;</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">		vec.<span class="built_in">push_back</span>(pbook[i]); <span class="comment">//尾部添加4条通信录</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通信录内容列表:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); i++)</span><br><span class="line">		vec[i].<span class="built_in">print</span>();<span class="comment">//使用数组方式访问每个元素</span></span><br><span class="line">	<span class="function">PHONEBOOK <span class="title">record</span><span class="params">(<span class="number">20181209</span>,<span class="string">&quot;phoenix&quot;</span>,<span class="string">&quot;15930209020&quot;</span>,<span class="string">&quot;teacher&quot;</span>)</span></span>;</span><br><span class="line">	vec.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>(), record); <span class="comment">//在 vec头添加元素record,该操作时间复杂度为0(n)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通信录内容列表:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;PHONEBOOK&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">		(*it).<span class="built_in">print</span>();<span class="comment">//使用迭代器访问每个元素</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;删除元素:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	vec.<span class="built_in">erase</span>((++ ++vec.<span class="built_in">begin</span>()))-&gt;<span class="built_in">print</span>(); <span class="comment">//删除第3位置的元素</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;通信录内容列表:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (vector &lt; PHONEBOOK&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it++)</span><br><span class="line">		(*it).<span class="built_in">print</span>();<span class="comment">//使用迭代器访问每个元素</span></span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里要重点说明的是，上例第一个循环采用下标方式访问向量对象vec中的每个元素,操作与数组相同,但需要注意在使用下标操作符“[]”时要防止地址越界，否则这类错误很难被捕捉到,会导致程序运行结果不确定。为了避免这种错误，一般使用迭代器，如上例中的第二个循环。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义迭代器的方法如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector &lt;PHONEBOOK&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>迭代器类似于指针</strong>,可以使用*it访问相应元素。如it= vec.begin()表示迭代器it指向vec的第一个元素;it=vec.end()表示迭代器it指向vec最后一个元素的下一个元素位置。若向量对象vec为空,vec.begin()与vec. end()指向同一个位置。容器的begin() 和end()函数都是常用接口,在程序设计时注意灵活使用。上例中还调用了push_back() 、size( )、insert()、erase()这4个接口函数,具体功能见上文函数表。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记-树</title>
    <url>/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前言：<strong>树型结构是</strong>一类重要的<strong>非线性结构</strong>,其特点是结点之间有分支,并具有层次关系。</p>
<span id="more"></span>
<h1 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h1><h2 id="1-1-1-树"><a href="#1-1-1-树" class="headerlink" title="1.1.1 树"></a>1.1.1 树</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树是由n(n≥１)个有限结点组成的一个具有层次关系的集合, 把它叫作“树”是因为它看起来像一棵倒挂的树,也就是说树是根朝上,而叶朝下的。如图所示：<br><img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200423091058696.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它具有以下的特点：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 每个结点有零个或多个子结点;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② <strong>每个子结点只有一个父结点</strong>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ <strong>没有前驱的结点为根结点</strong>;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④ 除了根结点外,每个子结点可以分为许多个不相交的子树。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为方便描述树的特点，先列出将会涉及到的<strong>树的基本概念</strong>：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①<strong>结点的度</strong>：一个结点含有的子树个数；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<strong>树的度</strong>：一棵树中，最大的结点的度；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③<strong>叶结点</strong>（终端结点）：度为0的结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④<strong>分支结点</strong>（非终端结点）：度不为0的结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑤<strong>孩子结点</strong>：一个结点的子树的根结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑥<strong>双亲结点</strong>（父结点）：在含有孩子的结点中，该结点称为孩子结点的双亲结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑦<strong>兄弟结点</strong>：具有相同双亲的结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑧<strong>祖先节点</strong>：从根到该结点所经分支上的所有结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑨<strong>子孙结点</strong>：以某结点为根的子树中任意结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑩<strong>节点的层次</strong>：从根开始定义，根为第一层，根的孩子为第二层，以此类推。如下图所示：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑪<strong>树的高度（深度</strong>）：树中结点的最大层次；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑫<strong>路径</strong>：从根结点到某一结点的一条通道；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;⑬<strong>路径长度</strong>：路径经过的边的个数。如下图所示：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200423092220707-16438689651564.png" alt=" "></p>
<h2 id="1-1-2-二叉树"><a href="#1-1-2-二叉树" class="headerlink" title="1.1.2 二叉树"></a>1.1.2 二叉树</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.综述：二叉树是每个结点最多有两个子树的有序树，通常<strong>子树的根被称为“左子树”和“右子树”</strong>。如下图所示。二叉树是一种最简单的树结构，任何树都可以简单转换为二叉树。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200423092422559.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.树和二叉树的区别<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①树的结点个数至少为1，而二叉树的结点个数可以为0；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②树中结点的最大度数没有限制，而<strong>二叉树结点最大度数为2</strong>；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.两种特殊的而二叉树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）<strong>满二叉树</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;满二叉树中<strong>所有的叶节点都在最后一层</strong>，而其他<strong>分支结点的度数都为2</strong>。示例如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200423092743663.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）<strong>完全二叉树</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若一个二叉树<strong>扣除其最后一层后变成</strong>一个满二叉树，且<strong>最后一层的所有结点都向左靠齐</strong>，则称该二叉树为完全二叉树。示例如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200423092948715.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;★<strong>满二叉树一定为完全二叉树，完全二叉树不一定为满二叉树</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.二叉树常见的性质<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>性质1</strong>&nbsp;&nbsp;&nbsp;&nbsp;一颗非空二叉树的第i层上最多有2^i-1^个结点（i≥1）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>性质2</strong>&nbsp;&nbsp;&nbsp;&nbsp;深度为h的二叉树最多有2^h^-1个结点（h＞1）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>性质3</strong>&nbsp;&nbsp;&nbsp;&nbsp;对于任何一棵二叉树T，如果其终端结点数为n~0~，度为2的结点数为n~2~，则n~0~=n~2~+1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>性质4</strong>&nbsp;&nbsp;&nbsp;&nbsp;若一个正则二叉树（只有度为0和2结点的二叉树）中有n个叶子结点，则该二叉树结点总数为log~2~n（由 性质2 推导）<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>性质5</strong>&nbsp;&nbsp;&nbsp;&nbsp;对于具有n个结点的完全二叉树，如果如果按照从上到下、同一层次上的结点按从左 到右的顺序对二叉树中的所有结点从1开始顺序编号,则对于序号为i的结点,有<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;① 如果i＞1,则序号为i的结点其双亲结点的序号为[i/2] ([i/2] 表示对i/2的值取整); 如果i＝1,则结点i为根结点,没有双亲<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 如果2i＞n,则结点i无左孩子(此时结点i为终端结点);否则其左孩子为结点2i<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③ 如果2i＋1＞n,则结点i无右孩子;否则其右孩子为结点2i＋1</p>
<h2 id="1-1-3-森林"><a href="#1-1-3-森林" class="headerlink" title="1.1.3 森林"></a>1.1.3 森林</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由m（m≥0）棵互不相交的树构成的集合称为森林。如下图所示，该森林由三棵树所构成：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200423094158844.png" alt=" "></p>
<h1 id="1-2-基本操作"><a href="#1-2-基本操作" class="headerlink" title="1.2 基本操作"></a>1.2 基本操作</h1><h2 id="1-2-1-树的遍历"><a href="#1-2-1-树的遍历" class="headerlink" title="1.2.1 树的遍历"></a>1.2.1 树的遍历</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<strong>前序遍历</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①访问根结点；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②按照从左到右的顺序前序遍历根结点的每一棵子树。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<strong>后序遍历</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①按照从左到右的顺序后序遍历根结点的每一棵子树；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②访问根结点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.<strong>层序遍历（广度遍历）</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从树的第一层（也就是根结点）开始自上而下逐层遍历，每一层按照从左到右的顺序逐个访问结点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;下图展示了按照这三种遍历方式所对应的遍历结果：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/2020042309454245.png" alt=" "></p>
<h2 id="1-2-2-二叉树的遍历"><a href="#1-2-2-二叉树的遍历" class="headerlink" title="1.2.2 二叉树的遍历"></a>1.2.2 二叉树的遍历</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<strong>前序遍历</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①访问根结点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②前序遍历访问根结点的左子树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③前序遍历访问根结点的右子树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<strong>中序遍历</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①中序遍历访问根结点的左子树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②访问根结点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③中序遍历访问根结点的右子树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.<strong>后序遍历</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①后序遍历访问根结点的左子树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②后序遍历访问根结点的右子树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③访问根结点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.<strong>层序遍历</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照从上到下，同一层次从左到右的顺序访问二叉树</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图展示了一棵二叉树四种遍历方式的结果：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200423095108960.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;★由二叉树的<strong>前序（后序）序列和中序序列</strong>可以唯一<strong>确定一棵二叉树</strong>，但是<strong>只由前序序列和后序序列不能确定一棵二叉树</strong>。</p>
<h2 id="1-2-3-森林的遍历"><a href="#1-2-3-森林的遍历" class="headerlink" title="1.2.3 森林的遍历"></a>1.2.3 森林的遍历</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<strong>前序遍历</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若森林非空，则：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①访问森林中第一棵树的根结点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②前序遍历第一棵树中根结点的每一棵子树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③前序遍历除第一棵树外的其他树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<strong>后序遍历</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若森林非空，则：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①后序遍历第一棵树的根结点的各个子树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②访问第一棵树的根结点<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③后序遍历除第一棵树外的其他树</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图给出了一个三棵树的森林的两种遍历结果：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200423095629544.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;★根据森林，树和二叉树的关系，可以得知：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①<strong>前序遍历森林</strong>＝<strong>前序遍历</strong>该森林对应的<strong>二叉树</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②<strong>后序遍历<strong>**</strong></strong>森林<strong>＝</strong>中序遍历<strong>该森林所对应的</strong>二叉树<strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③</strong>前序遍历树<strong>＝</strong>前序遍历<strong>该树所对应的</strong>二叉树<strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;④</strong>后序遍历树<strong>＝</strong>中序遍历<strong>该树所对应的</strong>二叉树**</p>
<h2 id="1-2-4-树、森林和二叉树的转换"><a href="#1-2-4-树、森林和二叉树的转换" class="headerlink" title="1.2.4 树、森林和二叉树的转换"></a>1.2.4 树、森林和二叉树的转换</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.<strong>树、森林转换成二叉树</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①在所有兄弟之间加一条线<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②对每个结点，去掉该结点和除长子外与其他孩子的连线<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;树转换为二叉树如下图所示：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200423100103177.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;森林转换成二叉树如下图所示：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386900806714.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.<strong>二叉树转换成树、森林</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;若结点x是双亲y的左孩子，则把x的右孩子、右孩子的右孩子都与y连起来，最后去掉双亲到右孩子的连线。如图所示：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386901068116.png" alt=" "></p>
<h1 id="1-3-存储结构"><a href="#1-3-存储结构" class="headerlink" title="1.3 存储结构"></a>1.3 存储结构</h1><h2 id="1-3-1-数的存储结构"><a href="#1-3-1-数的存储结构" class="headerlink" title="1.3.1 数的存储结构"></a>1.3.1 数的存储结构</h2><p>基本要求：<br>&nbsp;&nbsp;&nbsp;&nbsp;①能够存储各结点信息；<br>&nbsp;&nbsp;&nbsp;&nbsp;②唯一的表示各结点之间的逻辑结构——父子关系</p>
<p>1.双亲表示法<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）原理：利用一维数组来表示树,一维数组的每个元素表示树的结点,其中包括结点的数据和该结点 的双亲在数组中的下标；数组中的第一个元 素表示根结点,该结点无双亲,因此parent域用-1表示,其他结点按照层序存储.如结点B、 C、D 的双亲结点是下标为0的根结点,其parent域用0表示。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386901279318.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（2）C++描述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">pNode</span> //结点的<span class="title">C</span>++描述</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T data;</span><br><span class="line">	<span class="keyword">int</span> parent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1000</span></span><br><span class="line">pNode&lt; T &gt; Tree[MAXSIZE]; <span class="comment">//树的C++描述</span></span><br><span class="line"><span class="keyword">int</span> size; <span class="comment">//树的总结点数</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（3）结点结构：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/2020042420032552.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;（4） 优点：结构简单,查找结点的双亲或者祖先非常方便</p>
<p>2.孩子表示法<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）应用时需要查找当前结点的孩子,双亲表示法就会比较复杂。此时为了适应查找孩子结点的需求，可以使用孩子表示法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386901887121.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;（2）C++描述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CNode</span> //孩子链表结点结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> child; <span class="comment">//孩子结点在表头数组中的下标</span></span><br><span class="line">	CNode* next; <span class="comment">//指向下一个孩子结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">CBNode</span> //表头结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T data;</span><br><span class="line">	CNode* firstchild; <span class="comment">//指向第一个孩子结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（3）孩子表示法与双亲表示法正好相反,查找孩子结点很方便,但是查找双亲结点较为复杂</p>
<p>3.多重链表法<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）原理：多重链表法指每个结点包括一个结点信息域和多个指针域,每个指针域指向该结点的 一个孩子结点,通过各个指针域的值反映出树中各结点之间的逻辑关系。这种表示法中,树中每个结点有多个指针域,从而形成了多条链表。由于每个结点的孩子个数没有限制,各结点的度数又各异,可能会造成存储空间的浪费。例如,一棵度为k的 树,若其结点总数为n,则至少要浪费nk－n＋１个空指针域<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386902152923.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;（2）缺点：<strong>不适合存储度数较大的树</strong></p>
<p>4.孩子兄弟表示法<br>&nbsp;&nbsp;&nbsp;&nbsp;（1）原理：孩子兄弟表示法又称二叉链表表示法,链表中的每个结点包含一个数据域和两个指针域, 其中,数据域用来存储结点数据;第１个指针域指向该结点的第一个孩子结点;第２个指针域指向该结点的第一个右兄弟。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386902366625.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;（2）C++描述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T data;</span><br><span class="line">	TNode&lt;T&gt;* firstchild;</span><br><span class="line">	TNode&lt;T&gt;* rightsib;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（3） 优点：可以将任意复杂的树结构转换成二叉树,这样对树的研究就可以转化为对二叉树的研究,降低了问题的复杂程度</p>
<h2 id="1-3-2-二叉树的存储结构"><a href="#1-3-2-二叉树的存储结构" class="headerlink" title="1.3.2 二叉树的存储结构"></a>1.3.2 二叉树的存储结构</h2><p>1.顺序存储结构：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉树的顺序存储结构使用一维数组存储二叉树的结点,利用结点的存储位置来表示结点之间的关系。具体如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）将二叉树按照完全二叉树编号;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）其中无结点的位置使用NULL表示,结点则存储在一维数组相应的位置上。如下图所示：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386902633027.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种存储数据的方法逻辑简单但会造成空间的浪费,因此,该方法最适合存储完全二叉树</p>
<p>2.二叉链表<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）基本思想如下图所示：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386902825029.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）结点结构：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200424201901424.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）C++描述：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T data;</span><br><span class="line">	BiNode&lt;T&gt;* lchild;</span><br><span class="line">	BiNode&lt;T&gt;* rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二叉链表的存储方式和树的孩子兄弟表示法的存储结构完全相同,任何一棵复杂的树都可以容易地使用二叉链表的方式进行存储</p>
<p>3.三叉链表<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在二叉链表的存储方式下,从某结点出发可以直接访问到它的孩子结点,但要找到它的双亲,则必须从根结点开始搜索,最坏情况下,可能需要遍历整个二叉链表。所以, 在这种情况下,可以采用三叉链表来存储二叉树,以避免该问题的发生<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）结构：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386903221032.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）结点结构：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200424202300239.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）C++描述：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span> &gt;</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	T data;</span><br><span class="line">	BiNode&lt;T&gt;* parent;</span><br><span class="line">	BiNode&lt;T&gt;* lchild;</span><br><span class="line">	BiNode&lt;T&gt;* rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="1-4-二叉树的实现"><a href="#1-4-二叉树的实现" class="headerlink" title="1.4 二叉树的实现"></a>1.4 二叉树的实现</h1><h2 id="1-4-1-二叉树的声明"><a href="#1-4-1-二叉树的声明" class="headerlink" title="1.4.1 二叉树的声明"></a>1.4.1 二叉树的声明</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用二叉链表作为存储结构的二叉树其简单的 C＋＋ 描述如下:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">BiTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Create</span><span class="params">(BiNode&lt;T&gt;* &amp;R, T data[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>; <span class="comment">//创建二叉树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">(BiNode&lt;T&gt;* R)</span></span>; <span class="comment">//释放二叉树</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BiNode&lt;T&gt;* root; <span class="comment">//根结点</span></span><br><span class="line">	<span class="built_in">BiTree</span>(T data[], <span class="keyword">int</span> n); <span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiNode&lt;T&gt;* R)</span></span>; <span class="comment">//前序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiNode&lt;T&gt;* R)</span></span>; <span class="comment">//中序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiNode&lt;T&gt;* R)</span></span>; <span class="comment">//后序遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiNode&lt;T&gt;* R)</span></span>; <span class="comment">//层序遍历</span></span><br><span class="line">	~<span class="built_in">BiTree</span>(); <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-4-2-二叉树的关键算法"><a href="#1-4-2-二叉树的关键算法" class="headerlink" title="1.4.2 二叉树的关键算法"></a>1.4.2 二叉树的关键算法</h2><p>1.二叉树的创建<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建立二叉树有很多种方法,其中较为简单的就是使用顺序存储结构来建立二叉链表。以顺序存储结构为输入创建二叉树时,采用先建立根结点,再建立左右孩子的方法递归地建立用二叉链表表示的二叉树,其 C＋＋描述如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BiTree&lt;T&gt;::<span class="built_in">Create</span>(BiNode &lt;T&gt;*&amp; R, T data[], <span class="keyword">int</span> i, <span class="keyword">int</span> n) <span class="comment">//i表示位置，从1开始</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt;= n &amp;&amp; data[i - <span class="number">1</span>] != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		R = <span class="keyword">new</span> BiNode&lt;T&gt;; <span class="comment">//创建根结点</span></span><br><span class="line">		R-&gt;data = data[i - <span class="number">1</span>];</span><br><span class="line">		R-&gt;lchild = R-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="built_in">Create</span>(R-&gt;lchild, data, <span class="number">2</span> * i); <span class="comment">//创建左子树</span></span><br><span class="line">		<span class="built_in">Create</span>(R-&gt;rchild, data, <span class="number">2</span> * i + <span class="number">1</span>); <span class="comment">//创建右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> BiTree&lt;T&gt;::<span class="built_in">BiTree</span>(T data[], <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Create</span>(root, data, <span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述递归程序分解步骤如下,假设输入为下图所示的顺序存储结构表示的二叉树,则递归地建立用二叉链表表示的二叉树示意图如下图所示<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386903745135.png" alt=" "><br>２．二叉树前序、中序、后序遍历的实现<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由二叉树的前序遍历定义,结合递归,前序遍历的结果如下图所示。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200424204249786.png" alt=" "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C＋＋算法描述如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BiTree&lt;T&gt;::<span class="built_in">PreOrder</span>(BiNode&lt;T&gt;* R)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (R != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; R-&gt;data; <span class="comment">//访问结点</span></span><br><span class="line">		<span class="built_in">PreOrder</span>(R-&gt;lchild); <span class="comment">//遍历左子树</span></span><br><span class="line">		<span class="built_in">PreOrder</span>(R-&gt;rchild); <span class="comment">//遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于中序遍历,只需要把语句 cout &lt;&lt; R-&gt;data; 移到语句 PreOrder(R-&gt;lchild); 之后即可;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于后续遍历,只需要把语句 cout &lt;&lt; R-&gt;data; 移到语句 PreOrder(R-&gt;rchild); 之后即可。</p>
<p>3.层序遍历的实现<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 二叉链表的层序遍历基本思想如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386904121038.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 具体描述如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 【1】若根结点非空，入队。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 【2】如果队列不空：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 【2.1】队头元素出队；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 【2.2】访问该元素；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 【2.3】若该结点的左孩子非空，则左孩子入队；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 【2.4】若该结点的右孩子非空，则右孩子入队。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C++描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BiTree&lt;T&gt;::<span class="built_in">LevelOrder</span>(BiNode&lt;T&gt;* R)</span><br><span class="line">&#123;</span><br><span class="line">	BiNode&lt;T&gt;* queue[MAXSIZE];</span><br><span class="line">	<span class="keyword">int</span> f = <span class="number">0</span>; r = <span class="number">0</span>; <span class="comment">//初始化空队列</span></span><br><span class="line">	<span class="keyword">if</span> (R != <span class="literal">NULL</span>) queue[++r] = R; <span class="comment">//根结点入队</span></span><br><span class="line">	<span class="keyword">while</span> (f != r)</span><br><span class="line">	&#123;</span><br><span class="line">		BiNode&lt;T&gt;* p = queue[++f]; <span class="comment">//表头元素出队</span></span><br><span class="line">		cout &lt;&lt; p-&gt;data; <span class="comment">//出队打印</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) queue[++r] = p-&gt;lchild; <span class="comment">//左孩子入队</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) queue[++r] = p-&gt;rchild; <span class="comment">//右孩子入队</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.析构函数的实现<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 二叉链表属于动态存储分配,因此,需要在析构函数中释放二叉链表的所有结点.为了防止内存泄漏,释放结点时应先释放该结点的左右子树,左右子树全部释放完毕后再释放该结点。采用后序遍历的方法，具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> BiTree&lt;T&gt;::<span class="built_in">Release</span>(BiNode&lt;T&gt;* R) <span class="comment">//释放二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (R != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">Release</span>(R-&gt;lchild); <span class="comment">//释放左子树</span></span><br><span class="line">		<span class="built_in">Release</span>(R-&gt;rchild); <span class="comment">//释放右子树</span></span><br><span class="line">		<span class="keyword">delete</span> R; <span class="comment">//释放根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> BiTree&lt;T&gt;::~<span class="built_in">BiTree</span>() <span class="comment">//释放二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">Release</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-5-Huffman树"><a href="#1-5-Huffman树" class="headerlink" title="1.5 Huffman树"></a>1.5 Huffman树</h1><h2 id="1-5-1-Huffman树的定义与存储结构"><a href="#1-5-1-Huffman树的定义与存储结构" class="headerlink" title="1.5.1 Huffman树的定义与存储结构"></a>1.5.1 Huffman树的定义与存储结构</h2><p>1.Huffman树的定义<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈夫曼树又称<strong>最优二叉树</strong>,是一种<strong>带权路径长度最短的二叉树</strong>。<strong>树的带权路径长度</strong>, 就<strong>是树中所有叶结点的权值乘上其到根结点的路径长度</strong>(若根结点为０层,叶结点到根结点的路径长度为叶结点的层数)<strong>之和</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386904403440.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图（C）所示的二叉树其带权路径长度最短,而且再也找不出比此二叉树带权路径长度更短的二叉树了,因此图（C）所示是一棵哈夫曼树</p>
<p>2.Huffman编码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）<strong>Huffman编码根据字符出现的概率来构造平均长度最短的编码，是一种变长的编码</strong>。它的基本原理是频繁使用的数据用较小的代码代替，较少使用的数据用较大的编码代替，每个数据的代码不相同，但最终编码的平均长度最小。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）变长的编码：<strong>Huffman编码得到的字符编码，其长度因符号出现的概率而有所不同</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（3）Huffman编码的规则：从根结点到叶结点（包含原信息）的路径，向左孩子前进编码为0，向右孩子前进编码为1.也可以反过来规定<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200426093035934.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到字符A、B、C、Z的编码分别为0、11、100、101.显然<strong>Huffman编码</strong>是前缀编码，即<strong>任何一个字符的编码都不是另一个字符编码的前缀</strong>。</p>
<p>3.Huffman树的存储结构<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以静态散链表来存储结点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> weight; <span class="comment">//结点权值</span></span><br><span class="line">	<span class="keyword">int</span> parent; <span class="comment">//双亲数组下标</span></span><br><span class="line">	<span class="keyword">int</span> LChild; <span class="comment">//左孩子数组下标</span></span><br><span class="line">	<span class="keyword">int</span> RChild; <span class="comment">//右孩子数组下标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Huffman树是一棵正则二叉树（只有度为0或2的结点的二叉树）。根据二叉树的性质，一棵n个叶子的Huffman树共有2n-1个结点，可以用一个大小为2n-1的一维数组存放Huffman树的各个节点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图（a）所示的Huffman树有4个叶子结点，因此可以定义存储结构为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HNode* HTree = <span class="keyword">new</span> HNode[<span class="number">7</span>];</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其存储内容如下图（b）所示，-1表示无孩子结点或双亲结点<br><img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386904901043.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还需要设计Huffman编码表对每个结点进行存储。编码表中各元素的C++描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HCode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	string code;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，data存储结点的内存（这里假设其数据类型为char）。code数组存储结点对应的编码（这里采用string存储）。使用HCode类型定义一个一维数组，就可以存储所有结点的编码了。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就可以设计Huffman编码的相关算法了，如构造、编码、解码算法。其C++类描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Huffman</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	HNode* HTree; <span class="comment">//Huffman树</span></span><br><span class="line">	HCode* HCodeTable; <span class="comment">//存储编码表</span></span><br><span class="line">	<span class="keyword">int</span> N; <span class="comment">//叶子结点数量</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">code</span><span class="params">(<span class="keyword">int</span> i, string newcode)</span></span>; <span class="comment">//递归函数，对第i个结点编码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreateHTree</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">char</span> name[])</span></span>; <span class="comment">//创建Huffman树</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">CreateCodeTable</span><span class="params">()</span></span>; <span class="comment">//创建编码表</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Encode</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* d)</span></span>; <span class="comment">//编码</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Decode</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* d)</span></span>; <span class="comment">//解码</span></span><br><span class="line">	~<span class="built_in">Huffman</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，HTree存储Huffman树的结构，HCodeTable存储每个结点的编码内容。（假设要编码的数据和编码结果均为字符串类型）</p>
<h2 id="1-5-2-Huffman树的构造"><a href="#1-5-2-Huffman树的构造" class="headerlink" title="1.5.2 Huffman树的构造"></a>1.5.2 Huffman树的构造</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构造Huffman树的方法就是Huffman算法，描述如下：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将n个带权值的结点构成n棵二叉树的集合T，每棵二叉树只有一个根结点，其左右子树都为空：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;①在T中选取两个根结点权值最小的二叉树作为左右子树，构成一棵新二叉树。其根结点的权值为左右子树根结点权值之和；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;②在T中删除这两棵树，将新树加入T；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;③重复①②操作，直到T中仅存一棵树，该树即Huffman树<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图示如下：<br><img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTgxNzMwOQ==,size_16,color_FFFFFF,t_70-164386905149945.png" alt=" "><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成这样的Huffman树的C++描述：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入参数a[]存储每种字符的权值，n为字符的种类，name为各个字符的内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Huffman::CreateHTree</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n, <span class="keyword">char</span> name[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	N = n;</span><br><span class="line">	HCodeTable = <span class="keyword">new</span> HCode[N];</span><br><span class="line">	HTree = <span class="keyword">new</span> HNode[<span class="number">2</span> * n - <span class="number">1</span>]; <span class="comment">//根据权重数组a[0..n-1]初始化Huffman树</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		HTree[i].weight = a[i];</span><br><span class="line">		HTree[i].LChild = HTree[i].RChild = HTree[i].parent = <span class="number">-1</span>;</span><br><span class="line">		HCodeTable[i].data = name[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; <span class="number">2</span> * N - <span class="number">1</span>; i++) <span class="comment">//开始建立Huffman树</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">SelectMin</span>(x, y, <span class="number">0</span>, i); <span class="comment">//从1~i中选出两个权值最小的结点的函数</span></span><br><span class="line">		HTree[x].parent = HTree[y].parent = i;</span><br><span class="line">		HTree[i].weight = HTree[x].weight + HTree[y].weight;</span><br><span class="line">		HTree[i].LChild = x;</span><br><span class="line">		HTree[i].RChild = y;</span><br><span class="line">		HTree[i].parent = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5-3-Huffman编码表的构建"><a href="#1-5-3-Huffman编码表的构建" class="headerlink" title="1.5.3 Huffman编码表的构建"></a>1.5.3 Huffman编码表的构建</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文采用向上而下递归的处理方式，对每一个结点进行编码。若子树的根结点是其父结点的左分支则编码“0”，若是右分支则编码“1”，递归处理直到叶子结点。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成编码表的C++描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Huffman::code</span><span class="params">(<span class="keyword">int</span> i, string newcode)</span> <span class="comment">//递归函数，对第i个结点编码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (HTree[i].LChild == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		HCodeTable[i].code = newcode;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">code</span>(HTree[i].LChild, newcode + <span class="string">&quot;0&quot;</span>);</span><br><span class="line">	<span class="built_in">code</span>(HTree[i].RChild, newcode + <span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Huffman::CreateCodeTable</span><span class="params">()</span> <span class="comment">//生成编码表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">code</span>(<span class="number">2</span> * N - <span class="number">2</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图（a）所示的Huffman树，其对应编码表可以是下图（b）的结构<br><img src="/2020/04/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Cpp-C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_%E6%A0%91/20200426102848593.png" alt=" "></p>
<h2 id="1-5-4-Huffman编、解码的实现"><a href="#1-5-4-Huffman编、解码的实现" class="headerlink" title="1.5.4 Huffman编、解码的实现"></a>1.5.4 Huffman编、解码的实现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常,对一段信息进行哈夫曼编码时,<strong>需要对编码的数据进行两遍扫描</strong>.<br>（1）第一遍用来统计原数据中各字符出现的频率,利用得到的频率值创建哈夫曼树,并要把树的信息及编码表保存起来,以便解压时创建同样的哈夫曼树进行解压;<br>（2）第二遍根据第一遍扫描得到的哈夫曼编码表对原始数据进行编码,并把编码后得到的码字存储起来</p>
<p>1.编码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成编码表后，对于要编码的字符串，每读出一个字符，只要在编码表中找出对应编码即可；</p>
<p>2.解码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其基本思想是将编码串从左到右逐位判别，直到确定一个字符。即从Huffman根节点开始，根据每一位是0或者1选择左分支或右分支，直到到达叶子结点，至此每一个字符解码结束。然后，再从根结点开始下一个字符的解码<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解码算法的C++描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Huffman::Decode</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* d)</span> <span class="comment">//s为编码串，d为解码后的字符串</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (*s != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> parent = <span class="number">2</span> * N - <span class="number">2</span>; <span class="comment">//根结点在HTree中的下标</span></span><br><span class="line">		<span class="keyword">while</span> (HTree[parent].LChild != <span class="number">-1</span>) <span class="comment">//如果不是叶子结点</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (*s == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">				parent = HTree[parent].LChild;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				parent = HTree[parent].RChild;</span><br><span class="line">			s++;</span><br><span class="line">		&#125;</span><br><span class="line">		*d = HCodeTable[parent].data;</span><br><span class="line">		d++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 EasyX 库的大鱼吃小鱼游戏</title>
    <url>/2020/03/29/%E9%A1%B9%E7%9B%AE-Cpp-%E5%A4%A7%E9%B1%BC%E5%90%83%E5%B0%8F%E9%B1%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是进入大学本科之后完成的第一个比较完整的程序，通过EasyX库使用CPP实现一个大鱼吃小鱼的游戏。<br>&nbsp;<br><strong>工程文件下载：</strong> <a href="https://github.com/lgc0208/BigFishEatSmallFish">https://github.com/lgc0208/BigFishEatSmallFish</a><br>&nbsp;</p>
<span id="more"></span>
<h2 id="一-使用的库和IDE"><a href="#一-使用的库和IDE" class="headerlink" title="一.使用的库和IDE"></a>一.使用的库和IDE</h2><h4 id="EasyX库"><a href="#EasyX库" class="headerlink" title="EasyX库"></a>EasyX库</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EasyX 是针对 C++ 的图形库，可以帮助 C 语言初学者快速上手图形和游戏编程。</p>
<ol>
<li><p><strong>EasyX库地址</strong> ：<a href="https://easyx.cn/">https://easyx.cn/</a></p>
</li>
<li><p><strong>使用版本</strong> 2018春分版；</p>
</li>
</ol>
<h5 id="IDE：Visual-Studio-2019"><a href="#IDE：Visual-Studio-2019" class="headerlink" title="IDE：Visual Studio 2019"></a>IDE：Visual Studio 2019</h5><h2 id="二-源代码"><a href="#二-源代码" class="headerlink" title="二.源代码"></a>二.源代码</h2><h3 id="1-Struct-h"><a href="#1-Struct-h" class="headerlink" title="1.Struct.h"></a>1.Struct.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Struct.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">player</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">bool</span> live = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fish</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> size;</span><br><span class="line">	<span class="keyword">bool</span> live = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-Functions-h"><a href="#2-Functions-h" class="headerlink" title="2.Functions.h"></a>2.Functions.h</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Functions.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Functions_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Functions_H</span></span><br><span class="line">	</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;easyx.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>                <span class="comment">//头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>  comment(lib,<span class="meta-string">&quot;winmm.lib&quot;</span>)        <span class="comment">//引用静态库</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Struct.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*************************************全局变量****************************************************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">short</span> ScreenWidth = <span class="number">480</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">short</span> ScreenHeight = <span class="number">640</span>;</span><br><span class="line"><span class="keyword">short</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ToBig = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/**************NPC鱼的数量****************/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> numB = <span class="number">1</span>;<span class="comment">//大鱼数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> numL = <span class="number">2</span>;<span class="comment">//小鱼数量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> numS = <span class="number">3</span>;<span class="comment">//虾米数量</span></span><br><span class="line">IMAGE Fish[<span class="number">3</span>];<span class="comment">//鱼的图片</span></span><br><span class="line">IMAGE lplayerfish[<span class="number">2</span>];<span class="comment">//玩家鱼的图片</span></span><br><span class="line">IMAGE rplayerfish[<span class="number">2</span>];<span class="comment">//玩家鱼的图片</span></span><br><span class="line">IMAGE background;<span class="comment">//背景</span></span><br><span class="line"><span class="keyword">short</span> Formerx = <span class="number">0</span>;<span class="comment">//用于转身</span></span><br><span class="line"><span class="keyword">short</span> Formery = <span class="number">0</span>;<span class="comment">//用于转身</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50</span>;<span class="comment">//图片大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//加载图片</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">loadImages</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;Fish[<span class="number">2</span>], <span class="string">L&quot;bigfish.jpg&quot;</span>, <span class="number">2</span> * N, <span class="number">2</span> * N);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;Fish[<span class="number">1</span>], <span class="string">L&quot;littlefish.jpg&quot;</span>, N, N);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;Fish[<span class="number">0</span>], <span class="string">L&quot;shrimp.jpg&quot;</span>, N, N);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;background, <span class="string">L&quot;background.jpg&quot;</span>, ScreenHeight, ScreenWidth);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;lplayerfish[<span class="number">0</span>], <span class="string">L&quot;lplayerlittlefish.jpg&quot;</span>, N, N);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;lplayerfish[<span class="number">1</span>], <span class="string">L&quot;lplayerbigfish.jpg&quot;</span>, <span class="number">2</span> * N, <span class="number">2</span> * N);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;rplayerfish[<span class="number">0</span>], <span class="string">L&quot;rplayerlittlefish.jpg&quot;</span>, N, N);</span><br><span class="line">	<span class="built_in">loadimage</span>(&amp;rplayerfish[<span class="number">1</span>], <span class="string">L&quot;rplayerbigfish.jpg&quot;</span>, <span class="number">2</span> * N, <span class="number">2</span> * N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作掩码图</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">changeImage</span><span class="params">(IMAGE imagePut, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">IMAGE <span class="title">image</span><span class="params">(N, N)</span></span>; <span class="comment">//存储掩码</span></span><br><span class="line">	DWORD* pmemflower = <span class="built_in">GetImageBuffer</span>(&amp;imagePut);</span><br><span class="line">	DWORD* image1 = <span class="built_in">GetImageBuffer</span>(&amp;image);</span><br><span class="line">	DWORD* fish1 = <span class="built_in">GetImageBuffer</span>(&amp;imagePut);</span><br><span class="line">	COLORREF backcolor = pmemflower[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N * N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pmemflower[i] &gt;= backcolor)</span><br><span class="line">			image1[i] = WHITE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			image1[i] = BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N * N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pmemflower[i] &gt;= backcolor)</span><br><span class="line">			fish1[i] = BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putimage</span>(x, y, &amp;image, SRCAND);</span><br><span class="line">	<span class="built_in">putimage</span>(x, y, &amp;imagePut, SRCPAINT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作特定规格掩码图</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">changeImage2</span><span class="params">(IMAGE imagePut, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">IMAGE <span class="title">image</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>; <span class="comment">//存储掩码</span></span><br><span class="line">	DWORD* pmemflower = <span class="built_in">GetImageBuffer</span>(&amp;imagePut);</span><br><span class="line">	DWORD* image1 = <span class="built_in">GetImageBuffer</span>(&amp;image);</span><br><span class="line">	DWORD* fish1 = <span class="built_in">GetImageBuffer</span>(&amp;imagePut);</span><br><span class="line">	COLORREF backcolor = pmemflower[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> * <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pmemflower[i] &gt;= backcolor)</span><br><span class="line">			image1[i] = WHITE;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			image1[i] = BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span> * <span class="number">100</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pmemflower[i] &gt;= backcolor)</span><br><span class="line">			fish1[i] = BLACK;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putimage</span>(x, y, &amp;image, SRCAND);</span><br><span class="line">	<span class="built_in">putimage</span>(x, y, &amp;imagePut, SRCPAINT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//玩家移动</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(player* player2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(<span class="number">65</span>) &amp; <span class="number">0x8000</span>)  player2-&gt;x -= <span class="number">10</span>;	<span class="comment">// 左边</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(<span class="number">87</span>) &amp; <span class="number">0x8000</span>)  player2-&gt;y -= <span class="number">10</span>;	<span class="comment">// 上面</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(<span class="number">83</span>) &amp; <span class="number">0x8000</span>)  player2-&gt;y += <span class="number">10</span>;	<span class="comment">// 下面</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(<span class="number">68</span>) &amp; <span class="number">0x8000</span>)  player2-&gt;x += <span class="number">10</span>;	<span class="comment">// 右边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NPC移动</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">movefish</span><span class="params">(fish* fish1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fish1-&gt;x += (<span class="built_in">rand</span>() % <span class="number">21</span>) - <span class="number">10</span>;</span><br><span class="line">	fish1-&gt;y += (<span class="built_in">rand</span>() &amp; <span class="number">21</span>) - <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形态升级</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">biggerplayer</span><span class="params">(player* player2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (player2-&gt;score &gt; ToBig)</span><br><span class="line">		player2-&gt;size = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NPC重生</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">reborn</span><span class="params">(fish* fish1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fish1-&gt;x = <span class="built_in">rand</span>() % (ScreenHeight - <span class="number">50</span>);</span><br><span class="line">	fish1-&gt;y = <span class="built_in">rand</span>() % (ScreenWidth - <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断玩家是否死亡</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ifDead</span><span class="params">(fish* fish1, player* player2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (fish1-&gt;size &lt; player2-&gt;size)</span><br><span class="line">	&#123;</span><br><span class="line">		player2-&gt;score++;</span><br><span class="line">		<span class="built_in">biggerplayer</span>(player2);</span><br><span class="line">		<span class="built_in">reborn</span>(fish1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (fish1-&gt;size &gt;= player2-&gt;size)</span><br><span class="line">	&#123;</span><br><span class="line">		player2-&gt;live = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断玩家与NPC是否相遇</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">iftouch</span><span class="params">(fish* fish1, player* player2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (((<span class="built_in">abs</span>(fish1-&gt;x - player2-&gt;x) &lt; N)) &amp;&amp; (<span class="built_in">abs</span>(fish1-&gt;y - player2-&gt;y) &lt; N))<span class="comment">//距离小于N，则相遇</span></span><br><span class="line">		ifDead(fish1, player2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">iftouch2</span><span class="params">(fish* fish1, player* player2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (((<span class="built_in">abs</span>(fish1-&gt;x - player2-&gt;x) &lt; N)) &amp;&amp; (<span class="built_in">abs</span>(fish1-&gt;y - player2-&gt;y) &lt; N))<span class="comment">//距离小于N，则相遇</span></span><br><span class="line">	&#123;</span><br><span class="line">		player2-&gt;score++;</span><br><span class="line">		<span class="built_in">biggerplayer</span>(player2);</span><br><span class="line">		<span class="built_in">reborn</span>(fish1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断鱼是否出界</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(fish* fish1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((fish1-&gt;x &lt; <span class="number">0</span>) || (fish1-&gt;x &gt; (ScreenHeight - <span class="number">50</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">reborn</span>(fish1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((fish1-&gt;y &lt; <span class="number">0</span>) || (fish1-&gt;y &gt; (ScreenWidth - <span class="number">50</span>)))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">reborn</span>(fish1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断玩家是否出界</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">playerout</span><span class="params">(player* player2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((player2-&gt;x &lt; <span class="number">0</span>) || (player2-&gt;x &gt; ScreenHeight - <span class="number">50</span>))</span><br><span class="line">		player2-&gt;live = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> ((player2-&gt;y &lt; <span class="number">0</span>) || (player2-&gt;y &gt; ScreenWidth - <span class="number">50</span>))</span><br><span class="line">		player2-&gt;live = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印计分板</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">ScorePrint</span><span class="params">(player* player2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">setbkmode</span>(TRANSPARENT);	<span class="comment">//设置字体背景色为透明</span></span><br><span class="line">	<span class="built_in">settextcolor</span>(BLACK);		<span class="comment">//设置字体颜色为红色</span></span><br><span class="line">	TCHAR str[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	_stprintf_s(str, _T(<span class="string">&quot;击杀：%d&quot;</span>), player2-&gt;score);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">5</span>, <span class="number">5</span>, str);</span><br><span class="line">	_stprintf_s(str, _T(<span class="string">&quot;形态：%d&quot;</span>), player2-&gt;size);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">5</span>, <span class="number">25</span>, str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !_Functions_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-main-cpp"><a href="#3-main-cpp" class="headerlink" title="3.main.cpp"></a>3.main.cpp</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;Functions.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	player player1;</span><br><span class="line">	fish bigfish[numB];</span><br><span class="line">	fish littlefish[numL];</span><br><span class="line">	fish shrimp[numS];</span><br><span class="line">	<span class="built_in">srand</span>(<span class="built_in"><span class="keyword">unsigned</span></span>(<span class="built_in">time</span>(<span class="number">0</span>)));</span><br><span class="line">	<span class="comment">//玩家初始位置</span></span><br><span class="line">	player* player2 = &amp;player1;</span><br><span class="line">	player2-&gt;x = <span class="built_in">rand</span>() % (ScreenHeight - <span class="number">50</span>);</span><br><span class="line">	player2-&gt;y = <span class="built_in">rand</span>() % (ScreenWidth - <span class="number">50</span>);</span><br><span class="line">	<span class="comment">//鱼初始位置</span></span><br><span class="line">	fish* shrimp1[<span class="number">15</span>];<span class="comment">//shrimp指针数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numS; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		shrimp1[i] = &amp;shrimp[i];</span><br><span class="line">		shrimp1[i]-&gt;x = <span class="built_in">rand</span>() % (ScreenHeight - <span class="number">50</span>);</span><br><span class="line">		shrimp1[i]-&gt;y = <span class="built_in">rand</span>() % (ScreenWidth - <span class="number">50</span>);</span><br><span class="line">		shrimp1[i]-&gt;size = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fish* littlefish1[numL];<span class="comment">//littlefish指针数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numL; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		littlefish1[i] = &amp;littlefish[i];</span><br><span class="line">		littlefish1[i]-&gt;x = <span class="built_in">rand</span>() % (ScreenHeight - <span class="number">50</span>);</span><br><span class="line">		littlefish1[i]-&gt;y = <span class="built_in">rand</span>() % (ScreenWidth - <span class="number">50</span>);</span><br><span class="line">		littlefish1[i]-&gt;size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	fish* bigfish1[numB];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numB; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		bigfish1[i] = &amp;bigfish[i];</span><br><span class="line">		bigfish1[i]-&gt;x = <span class="built_in">rand</span>() % (ScreenHeight - <span class="number">50</span>);</span><br><span class="line">		bigfish1[i]-&gt;y = <span class="built_in">rand</span>() % (ScreenWidth - <span class="number">50</span>);</span><br><span class="line">		bigfish1[i]-&gt;size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">loadImages</span>();<span class="comment">//加载图片</span></span><br><span class="line">	<span class="built_in">initgraph</span>(ScreenHeight, ScreenWidth);<span class="comment">//加载窗口界面</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;background);<span class="comment">//放置窗口背景板</span></span><br><span class="line">	<span class="built_in">mciSendString</span>(<span class="string">L&quot;open  music.mp3 &quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//将音乐文件放在与源文件同一目录下，alias  music的意思就是将这个音乐文件重新命名为music</span></span><br><span class="line">	<span class="built_in">mciSendString</span>(<span class="string">L&quot;play music.mp3 repeat&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//播放音乐，play意为播放，同样可换做pause:暂停，stop:停止，close:关闭，Resume:继续。Repeat意为重复播放。</span></span><br><span class="line">	<span class="comment">////mciSendstring(“stop music repeat”, NULL, NULL, NULL)；//暂停播放音乐。</span></span><br><span class="line">	<span class="built_in">setbkmode</span>(TRANSPARENT);	<span class="comment">//设置字体背景色为透明</span></span><br><span class="line">	<span class="built_in">settextcolor</span>(BLACK);		<span class="comment">//设置字体颜色为红色</span></span><br><span class="line">	<span class="comment">/*****************游戏规则*****************/</span></span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">200</span>, <span class="string">L&quot;游戏规则:&quot;</span>);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">230</span>, <span class="string">L&quot;玩家操作鱼吃比自己等级低的鱼&quot;</span>);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">260</span>, <span class="string">L&quot;遇到比自己等级高或同等级的鱼即死亡&quot;</span>);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">290</span>, <span class="string">L&quot;出界即死亡&quot;</span>);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">320</span>, <span class="string">L&quot;按回车键开始&quot;</span>);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">350</span>, <span class="string">L&quot;按P键暂停&quot;</span>);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">380</span>, <span class="string">L&quot;按ESC键自毁&quot;</span>);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">410</span>, <span class="string">L&quot;持续按C开启无敌模式&quot;</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();<span class="comment">//使得开始界面静止，当用户按下Enter键时继续执行指令</span></span><br><span class="line">	<span class="comment">//char s[] = &quot;blacksheepwall&quot;;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//程序运行</span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;background);<span class="comment">//放置游戏界面背景板</span></span><br><span class="line">		<span class="built_in">ScorePrint</span>(player2);<span class="comment">//打印计分板</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//如果用户没有按C键，按此模式运行</span></span><br><span class="line">		<span class="keyword">if</span> (!(<span class="built_in">GetAsyncKeyState</span>(<span class="string">&#x27;C&#x27;</span>) &amp; <span class="number">0x8000</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//打印NPC-BOSS鱼</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numS; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">movefish</span>(shrimp1[i]);<span class="comment">//NPC移动函数</span></span><br><span class="line">				<span class="built_in">changeImage</span>(Fish[<span class="number">0</span>], shrimp1[i]-&gt;x, shrimp1[i]-&gt;y);<span class="comment">//制作掩码图</span></span><br><span class="line">				iftouch(shrimp1[i], player2);<span class="comment">//判断玩家与NPC是否相遇</span></span><br><span class="line">				<span class="built_in">out</span>(shrimp1[i]);<span class="comment">//判断鱼是否出界</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//打印NPC-小鱼</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numL; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">movefish</span>(littlefish1[i]);</span><br><span class="line">				<span class="built_in">changeImage</span>(Fish[<span class="number">1</span>], littlefish1[i]-&gt;x, littlefish1[i]-&gt;y);</span><br><span class="line">				iftouch(littlefish1[i], player2);</span><br><span class="line">				<span class="built_in">out</span>(littlefish1[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//打印NPC-大鱼</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numB; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">movefish</span>(bigfish1[i]);</span><br><span class="line">				<span class="built_in">changeImage2</span>(Fish[<span class="number">2</span>], bigfish1[i]-&gt;x, bigfish1[i]-&gt;y);</span><br><span class="line">				iftouch(bigfish1[i], player2);</span><br><span class="line">				<span class="built_in">out</span>(bigfish1[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若用户按下C键，进入无敌模式</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">setbkmode</span>(TRANSPARENT);	<span class="comment">//设置字体背景色为透明</span></span><br><span class="line">			<span class="built_in">settextcolor</span>(BLACK);		<span class="comment">//设置字体颜色为红色</span></span><br><span class="line">			TCHAR str[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">			_stprintf_s(str, _T(<span class="string">&quot;已开始作弊模式&quot;</span>));<span class="comment">//提示操作者已进入无敌模式</span></span><br><span class="line">			<span class="built_in">outtextxy</span>(<span class="number">5</span>, <span class="number">45</span>, str);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numS; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">movefish</span>(shrimp1[i]);</span><br><span class="line">				<span class="built_in">changeImage</span>(Fish[<span class="number">0</span>], shrimp1[i]-&gt;x, shrimp1[i]-&gt;y);</span><br><span class="line">				iftouch2(shrimp1[i], player2);<span class="comment">//若接触，NPC必死</span></span><br><span class="line">				<span class="built_in">out</span>(shrimp1[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numL; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">movefish</span>(littlefish1[i]);</span><br><span class="line">				<span class="built_in">changeImage</span>(Fish[<span class="number">1</span>], littlefish1[i]-&gt;x, littlefish1[i]-&gt;y);</span><br><span class="line">				iftouch2(littlefish1[i], player2);<span class="comment">//若接触，NPC必死</span></span><br><span class="line">				<span class="built_in">out</span>(littlefish1[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numB; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">movefish</span>(bigfish1[i]);</span><br><span class="line">				<span class="built_in">changeImage2</span>(Fish[<span class="number">2</span>], bigfish1[i]-&gt;x, bigfish1[i]-&gt;y);</span><br><span class="line">				iftouch2(bigfish1[i], player2);<span class="comment">//若接触，NPC必死</span></span><br><span class="line">				<span class="built_in">out</span>(bigfish1[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//玩家的移动</span></span><br><span class="line">		<span class="built_in">move</span>(player2);</span><br><span class="line">		<span class="keyword">if</span> (Formerx &gt; player2-&gt;x)<span class="comment">//是否转弯</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (player2-&gt;size == <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">changeImage</span>(lplayerfish[player2-&gt;size - <span class="number">1</span>], player2-&gt;x, player2-&gt;y);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">changeImage2</span>(lplayerfish[player2-&gt;size - <span class="number">1</span>], player2-&gt;x, player2-&gt;y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (player2-&gt;size == <span class="number">1</span>)</span><br><span class="line">				<span class="built_in">changeImage</span>(rplayerfish[player2-&gt;size - <span class="number">1</span>], player2-&gt;x, player2-&gt;y);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">changeImage2</span>(rplayerfish[<span class="number">1</span>], player2-&gt;x, player2-&gt;y);</span><br><span class="line">		&#125;</span><br><span class="line">		Formerx = player2-&gt;x;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">playerout</span>(player2);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">GetAsyncKeyState</span>(<span class="string">&#x27;P&#x27;</span>) &amp; <span class="number">0x8000</span>)<span class="comment">//若按下P，则暂停</span></span><br><span class="line">			ret = _getwch();</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">40</span>);<span class="comment">//帧率</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (player2-&gt;live == <span class="literal">true</span> &amp;&amp; !(<span class="built_in">GetAsyncKeyState</span>(VK_ESCAPE) &amp; <span class="number">0x8000</span>));<span class="comment">//在没有按下ESC或者玩家未死亡时，持续执行</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置结束页面</span></span><br><span class="line">	<span class="built_in">putimage</span>(<span class="number">0</span>, <span class="number">0</span>, &amp;background);</span><br><span class="line">	<span class="built_in">setbkmode</span>(TRANSPARENT);	<span class="comment">//设置字体背景色为透明</span></span><br><span class="line">	<span class="built_in">settextcolor</span>(BLACK);		<span class="comment">//设置字体颜色为红色</span></span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">290</span>, <span class="string">L&quot;游戏结束:&quot;</span>);</span><br><span class="line">	<span class="built_in">outtextxy</span>(<span class="number">290</span>, <span class="number">320</span>, <span class="string">L&quot;按任意键退出:&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (_kbhit())<span class="comment">//键盘敲击，接受到任意键后退出</span></span><br><span class="line">		ret = _getwch();</span><br><span class="line">	ret = _getwch();</span><br><span class="line">	<span class="built_in">closegraph</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="三-后记"><a href="#三-后记" class="headerlink" title="三.后记"></a>三.后记</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当初写这个代码前前后后约摸花了一周半的时间，主要的难点在于刚接触完CPP的基础语法，就开始去编写这样一个对当时的我来说“十分不可思议”的“大程序”。包括要去学习一个新的库的用法，程序的组织……</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实一开始想去尝试使用类来编写这个程序，但是编写的过程中发现类的继承之类的知识都还没有掌握，==基础不牢，地动山摇==，所以就还是采用了面向过程的编程方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总而言之，感觉最终的程序虽然做出来了，但是组织程序的过程还是挺凌乱的，有些“不知道怎么了就做出来了”的感觉。谨以此文留作纪念。</p>
]]></content>
      <categories>
        <category>项目</category>
        <category>Cpp</category>
      </categories>
      <tags>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>【Git】 取消追踪文件夹</title>
    <url>/2022/05/23/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Git-git%E5%8F%96%E6%B6%88%E8%BF%BD%E8%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>需要使用 git 命令取消对某一文件/文件夹的追踪，可以通过以下方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm -r --cache 文件夹名/</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Git】 服务器上关联 Github</title>
    <url>/2023/02/21/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Git-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%85%B3%E8%81%94git/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先在所需目录将其变成 Git 可以管理的仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目录路径</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>配置 git 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;邮箱&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;名称&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后使用 <code>git add</code> 和 <code>git commit</code> 将内容添加到本地版本库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;说明内容&quot;</span></span><br></pre></td></tr></table></figure>
<p>接下来将本地 Git 仓库与远程 Git 仓库连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add 仓库名 git@github.com:Github的ID/仓库名.git</span><br></pre></td></tr></table></figure>
<p>这时候可以查看一下本地连接的远程库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>
<p>接下来生成自己的 <code>token</code>，在 Github 上点击右上角头像，进入 <code>Settings</code>，在左侧导航栏中点击 <code>Developer settings</code>，再点击 <code>Personal access tokens</code> 和 <code>Tokens</code>，进入 Token 生成页面。点击右上方的 <code>Generate new token</code> 按键，输入账号密码后，勾选 <code>repo</code>，设置使用期限，设置 <code>Note</code>，然后点击 <code>Generate token</code> 就可以生成一个令牌。复制令牌备用。</p>
<p>接下来，在命令行上设置 URL。其中，<code>&lt;your_token&gt;</code> 换成我们刚才得到的令牌，<code>&lt;USERNAME&gt;</code> 换成自己的 Github 用户名，<code>&lt;REPO&gt;</code> 是项目名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote set-url &lt;REPO&gt; https://&lt;your_token&gt;@github.com/&lt;USERNAME&gt;/&lt;REPO&gt;.git</span><br></pre></td></tr></table></figure>
<p>然后 push 上去即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u 仓库名 分支名</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】安装Hexo并绑定Github</title>
    <url>/2022/05/23/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Hexo-hexo%E5%AE%89%E8%A3%85%E5%92%8C%E7%BB%91%E5%AE%9Agithub/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍安装 hexo 并绑定 Github 的方式。</p>
<span id="more"></span>
<h1 id="安装并绑定-git"><a href="#安装并绑定-git" class="headerlink" title="安装并绑定 git"></a>安装并绑定 git</h1><p>鼠标右键打开菜单栏，点击 <code>Git Bash Here</code>，设置 <code>user.name</code> 和 <code>user.email</code> 的配置信息并生成 SSH 秘钥：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;注册邮箱&quot;</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>
<p>在 Mac OS 上直接在终端输入上述内容即可。</p>
<p>在生成的 <code>.ssh</code> 文件夹中复制 <code>id_rsa.pub</code> 的全部内容。</p>
<p>接下来在 Github 上进行绑定，打开 Github 网页版的 SSH 设置界面（<a href="https://github.com/settings/keys），点击">https://github.com/settings/keys），点击</a> <code>New SSH key</code>，任意输入 <code>Title</code> 内容，并把刚才复制的 <code>id_rsa.pub</code> 内容全部粘贴进 <code>Key</code>，然后点击 <code>Add SSH key</code> 进行确认。</p>
<p>这时回到 <code>Git Bash</code> 中，输入 <code>ssh git@github.com</code>，若成功连接，则设定完成。</p>
<h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><p>安装 hexo 之前要先安装 <code>Node.js</code>，下载地址为：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p>
<p>安装成功后，在命令行输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>检查 <code>Node.js</code> 和 <code>npm</code> 是否安装成功。</p>
<p>上述工作都完成后，进行 hexo 的安装。选定博客目录，本文以 <code>Blog</code> 为例。进入 <code>Blog</code> 文件夹，打开命令行，输入下述代码进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<p>运行完成后，输入下述命令搭建一个简易 demo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="built_in">test</span></span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>然后在浏览器中输入 <code>localhost:4000</code> ，若成功显示博客雏形，则表示安装完成。</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Hexo】使用Hexo对博客进行更新</title>
    <url>/2022/05/23/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Hexo-hexo%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍使用 hexo 更新博客的方式。</p>
<span id="more"></span>
<p>博客文章存储地址：<code>博客路径\source\_posts</code>，需要为 markdown 文件</p>
<p>文章打包到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>文章发布到 Github：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>若想先本地测试，则输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>然后在浏览器输入 <code>localhost:4000</code> 即可访问</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】 安装ns3</title>
    <url>/2022/05/23/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Linux-Ubuntu%E5%AE%89%E8%A3%85ns3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录了在 Ubuntu 系统安装 ns-3 的方式</p>
<span id="more"></span>
<h1 id="1-安装依赖"><a href="#1-安装依赖" class="headerlink" title="1 安装依赖"></a>1 安装依赖</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gcc g++ python</span><br><span class="line">sudo apt-get install gcc g++ python python-dev</span><br><span class="line">sudo apt-get install mercurial</span><br><span class="line">sudo apt-get install bzr</span><br><span class="line">sudo apt-get install gdb valgrind</span><br><span class="line">sudo apt-get install gsl-bin libgsl-dev libgslcblas0</span><br><span class="line">sudo apt-get install flex bison libfl-dev</span><br><span class="line">sudo apt-get install g++-3.4 gcc-3.4</span><br><span class="line">sudo apt-get install tcpdump</span><br><span class="line">sudo apt-get install sqlite sqlite3 libsqlite3-dev</span><br><span class="line">sudo apt-get install libxml2 libxml2-dev</span><br><span class="line">sudo apt-get install libgtk2.0-0 libgtk2.0-dev</span><br><span class="line">sudo apt-get install vtun lxc</span><br><span class="line">sudo apt-get install uncrustify</span><br><span class="line">sudo apt-get install doxygen graphviz imagemagick</span><br><span class="line">sudo apt-get install texlive texlive-extra-utils texlive-latex-extra</span><br><span class="line">sudo apt-get install python-sphinx dia</span><br><span class="line">sudo apt-get install gir1.2-goocanvas-2.0 python-gi python-gi-cairo python-pygraphviz python3-gi python3-gi-cairo python3-pygraphviz gir1.2-gtk-3.0 ipython ipython3 </span><br><span class="line">sudo apt-get install libboost-signals-dev libboost-filesystem-dev</span><br><span class="line">sudo apt-get install openmpi*</span><br></pre></td></tr></table></figure>
<h1 id="2-下载-ns-3"><a href="#2-下载-ns-3" class="headerlink" title="2 下载 ns-3"></a>2 下载 ns-3</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir tarballs</span><br><span class="line"><span class="built_in">cd</span> tarballs</span><br><span class="line">wget http://www.nsnam.org/release/ns-allinone-3.30.tar.bz2</span><br><span class="line">tar xjf ns-allinone-3.30.tar.bz2</span><br></pre></td></tr></table></figure>
<h1 id="3-安装-ns-3"><a href="#3-安装-ns-3" class="headerlink" title="3 安装 ns-3"></a>3 安装 ns-3</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ns-allinone-3.30</span><br><span class="line">./build.py</span><br><span class="line"><span class="built_in">cd</span> ns-3.30</span><br><span class="line">./waf distclean</span><br><span class="line">./waf configure --enable-examples --enable-tests</span><br><span class="line">./waf</span><br><span class="line">./test.py</span><br><span class="line">./waf --run hello-simulator</span><br></pre></td></tr></table></figure>
<p>若得到 Hello Simulator 的文字回应，即安装成功。</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】htop命令中显示相同进程</title>
    <url>/2023/10/23/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Linux-htop%E5%91%BD%E4%BB%A4%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9B%B8%E5%90%8C%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用 htop 的过程中会发现有很多同样的进程被标注了绿色大量显示。如下图所示。</p>
<p><img src="/2023/10/23/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Linux-htop%E5%91%BD%E4%BB%A4%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9B%B8%E5%90%8C%E8%BF%9B%E7%A8%8B/image-20231128200120548.png" alt="很多同样的进程被标注了绿色大量显示"></p>
<p>这使得在大量程序运行时想要找到需要观察的进程变的困难。本文介绍了如何省略这些重复现实的进程。</p>
<span id="more"></span>
<ol>
<li>输入 <code>htop</code>，显示出 htop 界面。</li>
<li>按下 F2 键，进入 Setup 模式</li>
<li>点击 <code>Display options</code> 选项，将 <code>Hide kernel threads</code> 和 <code>Hide userland process thread</code> 选中即可。</li>
</ol>
<p><img src="/2023/10/23/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Linux-htop%E5%91%BD%E4%BB%A4%E4%B8%AD%E6%98%BE%E7%A4%BA%E7%9B%B8%E5%90%8C%E8%BF%9B%E7%A8%8B/image-20231128201344616.png" alt="操作流程"></p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】docker限制容器内存的方法</title>
    <url>/2023/11/13/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Linux-docker%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在服务器中使用 docker 时，如果不对 docker 的可调用内存进行限制，当 docker 内的程序出现不可预测的问题时，就很有可能因为内存爆炸导致服务器主机的瘫痪。而对 docker 进行限制后，可以将瘫痪范围控制在 docker 内。</p>
<p>因此，本文将介绍使用 docker 进行容器内存限制的方法。</p>
<span id="more"></span>
<h3 id="容器内存限制"><a href="#容器内存限制" class="headerlink" title="容器内存限制"></a>容器内存限制</h3><p>使用 docker 进行容器内存限制有两种方法，一种是在启动时对容器内存进行限制；另一种是容器启动后对容器内存进行限制。</p>
<h4 id="（1）启动时进行限制"><a href="#（1）启动时进行限制" class="headerlink" title="（1）启动时进行限制"></a>（1）启动时进行限制</h4><p>在启动时，通过命令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run ... -m 40G ...</span><br></pre></td></tr></table></figure></p>
<p>中的 <code>-m 40G</code> 部分限制开启容器的可调用内存。此处限制容器可调用内存上限为 40 G。</p>
<h4 id="（2）启动后进行限制"><a href="#（2）启动后进行限制" class="headerlink" title="（2）启动后进行限制"></a>（2）启动后进行限制</h4><p>已经启动一个容器后，可以使用 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker update -m 40G &#123;container_id/container_name&#125;</span><br></pre></td></tr></table></figure>
<p>开启容器的内存限制。其中，<code>-m 40G</code> 部分限制了可调用内存上限为 40 G，后面 <code>&#123;container_id/container_name&#125;</code> 表示容器 ID 或者容器名。</p>
<h3 id="限制情况查看"><a href="#限制情况查看" class="headerlink" title="限制情况查看"></a>限制情况查看</h3><p>完成限制后，可以在容器内或主机内查看限制情况。</p>
<h4 id="（1）在主机内查看"><a href="#（1）在主机内查看" class="headerlink" title="（1）在主机内查看"></a>（1）在主机内查看</h4><p>在主机内，只需要通过命令 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stats &#123;container_id/container_name&#125;</span><br></pre></td></tr></table></figure>
<p>即可查看对容器的限制情况，如下图所示。</p>
<p><img src="/2023/11/13/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Linux-docker%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E6%B3%95/image-20231128210818583.png" alt="image-20231128210818583"></p>
<h4 id="2-在容器内查看"><a href="#2-在容器内查看" class="headerlink" title="(2) 在容器内查看"></a>(2) 在容器内查看</h4><p>在容器内，通过命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /sys/fs/cgroup/memory/memory.limit_in_bytes </span><br></pre></td></tr></table></figure>
<p>即可查看容器的内存限制，如下图所示。单位为 Byte。</p>
<p><img src="/2023/11/13/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Linux-docker%E9%99%90%E5%88%B6%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E6%B3%95/image-20231128211022287.png" alt="image-20231128211022287"></p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】 使用服务器虚拟环境运行 Python 代码</title>
    <url>/2022/04/16/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Linux-%E5%85%B3%E9%97%ADnohup%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录了在腾讯云 LINUX 服务器中运行 Python 的方式。（假设已经创建好虚拟环境）</p>
<span id="more"></span>
<h2 id="1-不间断运行-Python-程序"><a href="#1-不间断运行-Python-程序" class="headerlink" title="1 不间断运行 Python 程序"></a>1 不间断运行 Python 程序</h2><h3 id="1-1-进入虚拟环境"><a href="#1-1-进入虚拟环境" class="headerlink" title="1.1 进入虚拟环境"></a>1.1 进入虚拟环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> 项目路径/项目名_venv/bin/activate</span><br></pre></td></tr></table></figure>
<h3 id="1-2-运行项目"><a href="#1-2-运行项目" class="headerlink" title="1.2 运行项目"></a>1.2 运行项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目路径</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup python 程序名.py</span><br></pre></td></tr></table></figure>
<h2 id="2-停止运行"><a href="#2-停止运行" class="headerlink" title="2 停止运行"></a>2 停止运行</h2><h3 id="2-1-查看进程编号"><a href="#2-1-查看进程编号" class="headerlink" title="2.1 查看进程编号"></a>2.1 查看进程编号</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -aux | grep python</span><br></pre></td></tr></table></figure>
<h3 id="2-2-杀死进程"><a href="#2-2-杀死进程" class="headerlink" title="2.2 杀死进程"></a>2.2 杀死进程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 进程id</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux】 服务器免密登陆</title>
    <url>/2023/12/04/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于专业要求，我需要经常通过 VSCode、Terminal 等工具连接远程服务器开展工作。而每次连接都需要输入一次或多次密码无疑影响了工作体验。基于该背景，本文介绍了免密登陆远程服务器的方式。</p>
<span id="more"></span>
<h2 id="1-生成-id-rsa-pub-文件"><a href="#1-生成-id-rsa-pub-文件" class="headerlink" title="1. 生成 id_rsa.pub 文件"></a>1. 生成 id_rsa.pub 文件</h2><p>根据自己的邮箱地址，利用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;xxx@xxx.com&quot;</span><br></pre></td></tr></table></figure>
<p>生成自己的 <code>id_rsa.pub</code> 文件。此时，对于 MacOS 用户，在 <code>/Users/用户名/.ssh/</code>目录下可以找到 <code>id_rsa.pub</code> 文件；对于 Windows 用户可以在 <code>C://用户/用户名/.ssh/</code> 目录下找到 <code>id_rsa.pub</code> 文件。</p>
<h2 id="2-绑定服务器"><a href="#2-绑定服务器" class="headerlink" title="2. 绑定服务器"></a>2. 绑定服务器</h2><p>将第一步生成的 <code>id_rsa.pub</code> 文件拷贝到 Linux 服务器上的 <code>/root/.ssh/</code> 文件夹中。然后执行以下代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 700 /root/.ssh</span><br><span class="line"><span class="built_in">cd</span> /root/.ssh</span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line">chmod 600 authorized_keys</span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>
<p>至此，即可在该设备上实现免密登陆服务器。</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【MacOS】 IMAP命令“APPEND”（至Sent Messages）失败，服务器出错：Mail has saved by smtp！的解决方案</title>
    <url>/2023/10/12/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-MacOS-mac%E9%82%AE%E7%AE%B1%E5%8F%91%E4%BF%A1%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了在 MacOS 系统中，使用邮件 APP 进行发信后提示 IMAP 命令 “APPEND”（至 Sent Messages）失败，服务器出错：Mail has saved by smtp！的解决方案。</p>
<span id="more"></span>
<p>在使用邮件 APP 进行发信时，完成发信后邮件 APP 提示 IMAP命令“APPEND”（至Sent Messages）失败，服务器出错：Mail has saved by smtp！此时解决方案如下：</p>
<p>打开邮件 APP，选择“邮件-设置”，进入设置界面。</p>
<p><img src="/2023/10/12/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-MacOS-mac%E9%82%AE%E7%AE%B1%E5%8F%91%E4%BF%A1%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/image-20231012093510009.png" alt></p>
<p>选择“账户-发件箱”，将发件箱的内容更改为“所有已发邮件”，即可解决。</p>
<p><img src="/2023/10/12/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-MacOS-mac%E9%82%AE%E7%AE%B1%E5%8F%91%E4%BF%A1%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/image-20231012093605681.png" style="zoom:50%;"></p>
<p><img src="/2023/10/12/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-MacOS-mac%E9%82%AE%E7%AE%B1%E5%8F%91%E4%BF%A1%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/image-20231012093646159.png" style="zoom:67%;"></p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Tensorboard】 Tensorboard展示所有数据</title>
    <url>/2023/04/14/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Tensorboard-Tensorboard%E5%B1%95%E7%A4%BA%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了在 Tensorboard 展示数据时显示所有数据的方法</p>
<span id="more"></span>
<p>在调取 Tensorboard 的时候，当加载的数据量较多时，tensorboard 就会对数据曲线自动进行采样后展示。这样在 tensorboard 里就只能下载采样后的数据。</p>
<p>若要下载完整的数据，可以在启动 tensorboard 时加上如下参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--samples_per_plugin scalars=999999999</span><br></pre></td></tr></table></figure>
<p>即可显示所有数据</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Tensorboard</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【WinError 10013】 以一种访问权限不允许的方式做了一个访问套接字的尝试</title>
    <url>/2022/09/26/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-WinError10013/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用 Tensorboard 的过程中，遇到报错 <code>[WinError 10013] 以一种访问权限不允许的方式做了一个访问套接字的尝试</code></p>
<span id="more"></span>
<p><strong>可能原因：</strong> 当前端口被占用。</p>
<p><strong>解决方案：</strong> 以 6006 端口为例，首先打开命令行，输入命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -aon|findstr <span class="string">&quot;6006&quot;</span></span><br></pre></td></tr></table></figure>
<p>查找当前正在占用 6006 端口的进程 PID。</p>
<p>查询到对应进程 PID 后，打开 <code>任务管理器</code> ，点击 <code>详细信息</code>，找到 PID 对应的进程关闭即可。</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【QT】 Qt Creator 中文乱码问题解决</title>
    <url>/2021/08/08/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-QT-Qt%20Creator%20%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在编译 Qt Creator 项目时出现中文乱码</p>
<span id="more"></span>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>在 pro 文件下添加如下代码即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">msvc &#123;</span><br><span class="line">QMAKE_CFLAGS += /utf<span class="number">-8</span></span><br><span class="line">QMAKE_CXXFLAGS += /utf<span class="number">-8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>QT</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Win10】 解决文件夹被占用无法删除的情况</title>
    <url>/2021/12/11/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E7%9A%84%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了关闭文件夹后，对文件夹进行删除等操作时提示文件夹被占用，但此时没有打开文件夹中的文件的解决方法</p>
<span id="more"></span>
<ol>
<li><p>打开<strong>任务管理器</strong></p>
</li>
<li><p>点击<strong>性能</strong>，在最下方点击<strong>打开资源监视器</strong><br><img src="/2021/12/11/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E7%9A%84%E6%83%85%E5%86%B5/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGdjMDIwOA==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt=" "></p>
</li>
<li><p>点击<strong>CPU</strong>，在<strong>关联的句柄处</strong>输入无法进行操作的<strong>文件夹名称</strong><br><img src="/2021/12/11/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-%E8%A7%A3%E5%86%B3%E6%96%87%E4%BB%B6%E5%A4%B9%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E7%9A%84%E6%83%85%E5%86%B5/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGdjMDIwOA==,size_20,color_FFFFFF,t_70,g_se,x_16-16438698097762.png" alt=" "></p>
</li>
<li>在搜索结果中<strong>右键符合条件的结果</strong>，点击<strong>结束进程</strong>即可</li>
</ol>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Win10】 解决 Office 安装后图标空白的问题</title>
    <url>/2022/03/03/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-office%E5%9B%BE%E6%A0%87%E7%A9%BA%E7%99%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了安装 Office 后出现图标空白的解决方法。问题如下图所示。</p>
<p><img src="/2022/03/03/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-office%E5%9B%BE%E6%A0%87%E7%A9%BA%E7%99%BD/d000baa1cd11728bd6179c5fd8fcc3cec3fd2c90.png" alt="Office图标空白"></p>
<span id="more"></span>
<h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h2><ul>
<li>打开<code>控制面板</code> — <code>程序</code> — <code>默认程序</code> — <code>文件协议或类型关联</code>，将 Word 相关的文件类型（如.doc，.docx）与 Word 相关联。 PPT， Excel 等同理</li>
</ul>
<h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h2><ul>
<li>使用 <code>Win + R</code> 按键，在运行视窗中输入 <code>regedit</code> 打开注册表</li>
</ul>
<p><img src="/2022/03/03/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-office%E5%9B%BE%E6%A0%87%E7%A9%BA%E7%99%BD/image-20220303215844430.png" alt="打开注册表"></p>
<h2 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h2><ul>
<li>打开 <code>计算机\HKEY_CLASSES_ROOT</code> ，记录下 <code>.doc/.docx</code> (Word),  <code>.ppt/.pptx</code> (PPT), <code>.xls/.xlsx</code> (Excel) 的默认值，分别为 <code>Word.Document.8</code>，<code>Word.Document.12</code>， <code>Excel.Sheet.8</code>， <code>Excel.Sheet.12</code>， <code>PowerPoint.Show.8</code>， <code>PowerPoint.Show.12</code></li>
<li><code>HKEY_CLASSES_ROOT\Word.Document.12\DefaultIcon</code>，删除默认值</li>
<li>同理，删除 <code>HKEY_CLASSES_ROOT\Word.Document.8\DefaultIcon</code>，…… 的默认值</li>
</ul>
<p><img src="/2022/03/03/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-office%E5%9B%BE%E6%A0%87%E7%A9%BA%E7%99%BD/image-20220303220332515.png" alt="删除默认值"></p>
<h2 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h2><ul>
<li>打开任务管理器，在进程中找到 <code>Windows 资源管理器</code>，右键选择 <code>重新启动</code> 即可。</li>
</ul>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Win10】 代理服务器出现问题或地址有误</title>
    <url>/2022/04/13/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%88%96%E5%9C%B0%E5%9D%80%E6%9C%89%E8%AF%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了访问浏览器时显示代理服务器出现问题或地址有误的解决方案</p>
<span id="more"></span>
<h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述</h1><p>打开 Chrome 浏览器访问网页时，提示代理服务器出现问题或地址有误，无法连接至互联网</p>
<h1 id="2-问题排查"><a href="#2-问题排查" class="headerlink" title="2 问题排查"></a>2 问题排查</h1><ol>
<li><p>打开<code>cmd</code>，输入 <code>ping 127.0.0.1</code> 命令检查主机的网卡是否正常工作，发现正常工作，排除主机网卡问题</p>
</li>
<li><p>继续输入 <code>ipconfig</code> 命令获取网关地址，输入 <code>ping 网关地址</code> 命令检查主机与网关的连通性，发现正常工作，排除主机和网关的联通问题</p>
</li>
<li>输入 <code>ping www.baidu.com</code> 命令检查远端服务器是否正常工作，发现正常工作</li>
<li>右键右下角 Wi-Fi 图标，打开 <code>网络和 Internet</code> 设置，选择 <code>代理</code>，发现手动设置代理中使用代理服务器被打开了。关闭代理服务器后重新打开浏览器，恢复正常。</li>
</ol>
<p><img src="/2022/04/13/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E9%97%AE%E9%A2%98%E6%88%96%E5%9C%B0%E5%9D%80%E6%9C%89%E8%AF%AF/image-20220413101213948.png" alt="关闭代理服务器"></p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jupyter Notebook】 导出好看的中文PDF</title>
    <url>/2021/11/24/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows:Jupyter%20Notebook-JN%E5%AF%BC%E5%87%BA%E5%A5%BD%E7%9C%8B%E7%9A%84%E4%B8%AD%E6%96%87PDF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了使用 Jupyter Notebook 导出好看的中文PDF的方式。</p>
<span id="more"></span>
<h1 id="Step-1-导出-Tex-文件"><a href="#Step-1-导出-Tex-文件" class="headerlink" title="Step 1 导出 Tex 文件"></a>Step 1 导出 Tex 文件</h1><p>打开 $jupyter Notebook$，点击 $File \to Download \quad as \to LaTeX(.tex)$<br><img src="/2021/11/24/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows:Jupyter%20Notebook-JN%E5%AF%BC%E5%87%BA%E5%A5%BD%E7%9C%8B%E7%9A%84%E4%B8%AD%E6%96%87PDF/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAbGdjMDIwOA==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt=" "></p>
<h1 id="Step-2-修改-Tex-文件"><a href="#Step-2-修改-Tex-文件" class="headerlink" title="Step 2 修改 Tex 文件"></a>Step 2 修改 Tex 文件</h1><p>在指定位置会看到导出的  $.tex$ 文件。为了使输出的 PDF 中的中文正常显示，需要对导出的 $.tex$ 文件进行编辑：</p>
<p>在 <code>\documentclass</code> 的后面插入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\usepackage&#123;fontspec, xunicode, xltxtra&#125;</span><br><span class="line">\setmainfont&#123;Microsoft YaHei&#125;</span><br><span class="line">\usepackage&#123;ctex&#125;</span><br></pre></td></tr></table></figure>
<p>即可</p>
<h1 id="Step-3-导出-PDF"><a href="#Step-3-导出-PDF" class="headerlink" title="Step 3 导出 PDF"></a>Step 3 导出 PDF</h1><p>回到 $.tex$ 文件所在目录，在命令行中输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xelatex 文件名.tex</span><br></pre></td></tr></table></figure>
<p>即可得到好看的中文PDF</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Windows</category>
        <category>Jupyter Notebook</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Jupyter Notebook】 使用 Jupyter Notebook 打开C盘外的文件</title>
    <url>/2021/08/15/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows:Jupyter%20Notebook-JN%E6%89%93%E5%BC%80C%E7%9B%98%E5%A4%96%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>直接打开 Jupyter Notebook 会默认处理C盘中的文件，而许多项目文件保存在其他盘，因此存在使用 Jupyter Notebook 打开不属于C盘文件的需求</p>
<span id="more"></span>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li>打开 Anaconda Prompt</li>
<li>指定需要打开的盘，例如输入 <code>cd /d F:</code> 则定位到 F 盘</li>
<li>输入 <code>jupyter notebook</code> 即可在 F 盘中打开 Jupyter Notebook</li>
</ol>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Windows</category>
        <category>Jupyter Notebook</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Win10】 你需要 Lenovo 权限才能对此文件夹进行更改</title>
    <url>/2023/03/30/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows-%E9%9C%80%E8%A6%81Lenovo%E6%9D%83%E9%99%90%E6%89%8D%E8%83%BD%E5%88%A0%E9%99%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录了在删除文件时遇到 <code>你需要 Lenovo 权限才能对此文件夹进行更改</code> 的最简单解决方法</p>
<span id="more"></span>
<p>最近将一个代码文件下载到桌面后，想删除时遇到了 <code>你需要 Lenovo 权限才能对此文件夹进行更改</code> 问题。参考了很多修改权限等方式，都无法解决。最后发现了一个最简单的解决方法：</p>
<p>将所需要删除的文件夹剪切到 <code>C:\Program Files</code> 文件夹中，再进行删除，就可以直接删除了。</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【系统】 修改 hosts 文件</title>
    <url>/2022/05/23/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows:Linux:MacOS-%E4%BF%AE%E6%94%B9host%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录了在各种系统下修改 hosts 文件的方式</p>
<span id="more"></span>
<h1 id="1-hosts-文件的作用"><a href="#1-hosts-文件的作用" class="headerlink" title="1 hosts 文件的作用"></a>1 hosts 文件的作用</h1><p>hosts文件将域名与其对应的 IP 地址建立关联表，用户在浏览器中输入访问的域名时，系统会首先自动从 hosts 文件中寻找对应的 IP 地址</p>
<h1 id="2-hosts-文件的存放路径"><a href="#2-hosts-文件的存放路径" class="headerlink" title="2 hosts 文件的存放路径"></a>2 hosts 文件的存放路径</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p><code>C:\Windows\System32\drivers\etc</code></p>
<h2 id="Mac-OS-Linux-类-Unix"><a href="#Mac-OS-Linux-类-Unix" class="headerlink" title="Mac OS/Linux/类 Unix"></a>Mac OS/Linux/类 Unix</h2><p><code>/etc/</code></p>
<h2 id="Andriod"><a href="#Andriod" class="headerlink" title="Andriod"></a>Andriod</h2><p><code>/system/etc/</code></p>
<h1 id="3-激活-hosts-文件内容"><a href="#3-激活-hosts-文件内容" class="headerlink" title="3 激活 hosts 文件内容"></a>3 激活 hosts 文件内容</h1><p>通过刷新 DNS 缓存表的方式使 hosts 文件生效，需要使用命令行</p>
<h2 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipconfig /flushdns</span><br></pre></td></tr></table></figure>
<h2 id="Mac-OS-Linux-类-Unix-1"><a href="#Mac-OS-Linux-类-Unix-1" class="headerlink" title="Mac OS/Linux/类 Unix"></a>Mac OS/Linux/类 Unix</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Linux</category>
        <category>MacOS</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mathtype】 编辑时无法删除，只能输入的解决方法</title>
    <url>/2021/12/01/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows:Mathtype-Mathtype%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E5%8F%AA%E8%83%BD%E8%BE%93%E5%85%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了使用 Mathtype 编辑时无法删除，只能输入的解决方法</p>
<span id="more"></span>
<h1 id="1-点击-Preferences（预置）"><a href="#1-点击-Preferences（预置）" class="headerlink" title="1 点击 Preferences（预置）"></a>1 点击 Preferences（预置）</h1><p><img src="/2021/12/01/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows:Mathtype-Mathtype%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E5%8F%AA%E8%83%BD%E8%BE%93%E5%85%A5/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGdjMDIwOA==,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt=" "></p>
<h1 id="2-点击-Customize-Keyboard（自定义键盘）"><a href="#2-点击-Customize-Keyboard（自定义键盘）" class="headerlink" title="2 点击 Customize Keyboard（自定义键盘）"></a>2 点击 Customize Keyboard（自定义键盘）</h1><h1 id="3-点击-Reset-all-（重置所有）即可"><a href="#3-点击-Reset-all-（重置所有）即可" class="headerlink" title="3 点击 Reset all （重置所有）即可"></a>3 点击 Reset all （重置所有）即可</h1><p><img src="/2021/12/01/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows:Mathtype-Mathtype%E6%97%A0%E6%B3%95%E5%88%A0%E9%99%A4%E5%8F%AA%E8%83%BD%E8%BE%93%E5%85%A5/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGdjMDIwOA==,size_20,color_FFFFFF,t_70,g_se,x_16-16438697906722.png" alt=" "></p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Windows</category>
        <category>Mathtype</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Typora】 This beta version of Typora is expired, please download and install a newer version.</title>
    <url>/2022/07/24/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%B3%BB%E7%BB%9F:%E8%BD%AF%E4%BB%B6-Windows:Typora-typora%E5%8F%96%E6%B6%88%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在使用一段时间 beta 版本 Typora 后，打开 Typora 可能会跳出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This beta version of Typora is expired, please download and install a newer version.</span><br></pre></td></tr></table></figure>
<p>下面提供一个解决方法。</p>
<span id="more"></span>
<ol>
<li>输入 <code>Win + R</code>，输入 <code>regedit</code> 打开注册表。</li>
<li>在 <code>计算机\HKEY_CURRENT_USER\SOFTWARE</code> 中找到 <code>Typora</code> 文件夹。</li>
<li>右键 <code>Typora</code> 文件夹，打开 <code>修改权限</code>，将所有用户的 <code>完全控制</code> 和 <code>读取</code> 权限勾选为拒绝，然后点击 <code>应用</code> 即可。</li>
</ol>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>系统/软件</category>
        <category>Windows</category>
        <category>Typora</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【LaTeX】 将参考文献引用改为上标的方式</title>
    <url>/2021/08/30/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-LaTeX-Latex%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E4%B8%8A%E6%A0%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文介绍了LaTeX中将参考文献的引用改为上标的方式</p>
<span id="more"></span>
<p>改变 <code>\cite</code> 指令的格式，在文章中添加代码段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\makeatletter</span><br><span class="line">　　\def\@cite<span class="comment">#1#2&#123;\textsuperscript&#123;[&#123;#1\if@tempswa , #2\fi&#125;]&#125;&#125;</span></span><br><span class="line">\makeatother</span><br></pre></td></tr></table></figure>
<p>即可实现带中括号的上标引用，效果如下图所示</p>
<p><img src="/2021/08/30/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-LaTeX-Latex%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E4%B8%8A%E6%A0%87/ff237ca68f364b53a3cfd9a1edcd57d8.png" alt=" "></p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>编程语言</category>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】 module ‘h5py‘ has no attribute ‘File‘解决方案</title>
    <url>/2022/01/16/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Python-h5py%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>产生报错信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">module <span class="string">&#x27;h5py&#x27;</span> has no attribute <span class="string">&#x27;File&#x27;</span></span><br></pre></td></tr></table></figure>
<p>的解决方法</p>
<span id="more"></span>
<h2 id="1-普遍解决方案"><a href="#1-普遍解决方案" class="headerlink" title="1 普遍解决方案"></a>1 普遍解决方案</h2><p>可能与 pip 和 conda 的混用有关，先使用<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip uninstall h5py</span><br></pre></td></tr></table></figure><br>再输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install h5py</span><br></pre></td></tr></table></figure>
<h2 id="2-备用解决方案"><a href="#2-备用解决方案" class="headerlink" title="2 备用解决方案"></a>2 备用解决方案</h2><p>通过 1 节中介绍的方式笔者并没有解决报错问题，这时采用先输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 uninstall h5py</span><br></pre></td></tr></table></figure>
<p>再输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install h5py</span><br></pre></td></tr></table></figure>
<p>即可解决该问题</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】 导出项目依赖</title>
    <url>/2022/05/23/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Python-%E5%AF%BC%E5%87%BApython%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>介绍借助 <code>pipreqs</code> 导出 Python 项目所需依赖的方式</p>
<span id="more"></span>
<p>首先下载 <code>pipreqs</code> 包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pipreqs</span><br></pre></td></tr></table></figure>
<p>切换到项目根目录，输入以下指令即可生成包含项目依赖的 <code>requirements.txt</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipreqs ./ --encoding=utf8</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
  <entry>
    <title>【Python】【Flask】 使用 gunicorn 运行 flask app 时无法记录日志的解决方法</title>
    <url>/2022/02/02/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80-Python-flask%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用 <code>app.logger</code> 对日志进行记录时，在本地服务器上运行正常，而部署到 <code>gunicorn</code> 后无法正常工作</p>
<span id="more"></span>
<p>我的代码片段如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name: flask_LSTM.py</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/predict&#x27;</span></span>)</span></span><br><span class="line">app.logger.debug(<span class="string">&#x27;Running&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    file_handler = FileHandler(<span class="string">&#x27;logs/flask.log&#x27;</span>)</span><br><span class="line">    file_handler.setLevel(logging.DEBUG)</span><br><span class="line">    file_handler.setFormatter(Formatter(<span class="string">&#x27;%(asctime)s %(levelname)s: %(message)s &#x27;</span><span class="string">&#x27;[in %(pathname)s:%(lineno)d]&#x27;</span>))</span><br><span class="line">    app.logger.addHandler(file_handler)</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>在服务器上输入指令 <code>python flask_LSTM.py</code> 后，程序正常运行，使用 POSTMAN 进行访问后，<code>flask.log</code> 文件里获得期望输出</p>
<p>然而使用 <code>guinicorn</code> 运行程序时，程序运行后使用 POSTMAN 访问，日志文件没有任何新写入的信息</p>
<p>冥思苦想了一个晚上，于是还是决定直接采用</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">nohup python flask_LSTM.py</span><br></pre></td></tr></table></figure>
<p>运行程序。在此方法下，日志记录功能可以正常工作</p>
]]></content>
      <categories>
        <category>那些年我踩过的坑</category>
        <category>编程语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>踩过的坑</tag>
      </tags>
  </entry>
</search>
